diff -Npur projectq-orig/projectq/backends/_sim/_cppkernels/fusion.hpp projectq-new/projectq/backends/_sim/_cppkernels/fusion.hpp
--- projectq-orig/projectq/backends/_sim/_cppkernels/fusion.hpp	2022-04-27 11:49:17.000000000 +0200
+++ projectq-new/projectq/backends/_sim/_cppkernels/fusion.hpp	2022-06-17 12:37:17.816198916 +0200
@@ -15,29 +15,45 @@
 #ifndef GATE_QUEUE_HPP_
 #define GATE_QUEUE_HPP_
 
-#include <set>
-#include <vector>
-#include <complex>
 #include <algorithm>
+#include <complex>
+#include <iomanip>
 #include <iostream>
+#include <set>
+#include <utility>
+#include <vector>
+
 #include "intrin/alignedallocator.hpp"
 
-class Item{
-public:
+// #define MEASURE_TIMINGS
+
+#ifdef MEASURE_TIMINGS
+#    include <chrono>
+#endif  // MEASURE_TIMINGS
+
+namespace projectq {
+class Item {
+ public:
     using Index = unsigned;
     using IndexVector = std::vector<Index>;
     using Complex = std::complex<double>;
     using Matrix = std::vector<std::vector<Complex, aligned_allocator<Complex, 64>>>;
-    Item(Matrix mat, IndexVector idx) : mat_(mat), idx_(idx) {}
-    Matrix& get_matrix() { return mat_; }
-    IndexVector& get_indices() { return idx_; }
-private:
+    Item(Matrix mat, IndexVector idx) : mat_(std::move(mat)), idx_(std::move(idx)) {
+    }
+    Matrix& get_matrix() {
+        return mat_;
+    }
+    IndexVector& get_indices() {
+        return idx_;
+    }
+
+ private:
     Matrix mat_;
     IndexVector idx_;
 };
 
-class Fusion{
-public:
+class Fusion {
+ public:
     using Index = unsigned;
     using IndexSet = std::set<Index>;
     using IndexVector = std::vector<Index>;
@@ -53,49 +69,65 @@ public:
         return items_.size();
     }
 
-    void insert(Matrix matrix, IndexVector index_list, IndexVector const& ctrl_list = {}){
-        for (auto idx : index_list)
+    void clear() {
+        set_.clear();
+        items_.clear();
+        ctrl_set_.clear();
+    }
+
+    void insert(Matrix matrix, IndexVector index_list, IndexVector const& ctrl_list = {}) {
+        for (const auto& idx : index_list)
             set_.emplace(idx);
 
         handle_controls(matrix, index_list, ctrl_list);
-        Item item(matrix, index_list);
-        items_.push_back(item);
+        items_.emplace_back(std::move(matrix), std::move(index_list));
     }
 
-    void perform_fusion(Matrix& fused_matrix, IndexVector& index_list, IndexVector& ctrl_list){
-        for (auto idx : set_)
+    void perform_fusion(Matrix& fused_matrix, IndexVector& index_list, IndexVector& ctrl_list) {
+#ifdef MEASURE_TIMINGS
+        const auto start = std::chrono::high_resolution_clock::now();
+#endif  // MEASURE_TIMINGS
+        for (const auto& idx : set_)
             index_list.push_back(idx);
 
         std::size_t N = num_qubits();
-        fused_matrix = Matrix(1UL<<N, std::vector<Complex, aligned_allocator<Complex, 64>>(1UL<<N));
-        auto &M = fused_matrix;
+        fused_matrix = Matrix(1UL << N, std::vector<Complex, aligned_allocator<Complex, 64>>(1UL << N));
+        auto& M = fused_matrix;
+
+#ifdef MEASURE_TIMINGS
+        const auto create = std::chrono::high_resolution_clock::now();
+#endif  // MEASURE_TIMINGS
 
-        for (std::size_t i = 0; i < (1UL<<N); ++i)
+#pragma GCC ivdep
+        for (std::size_t i = 0; i < (1UL << N); ++i)
             M[i][i] = 1.;
 
-        for (auto& item : items_){
+        for (auto& item : items_) {
             auto const& idx = item.get_indices();
             IndexVector idx2mat(idx.size());
+
+#pragma GCC ivdep
             for (std::size_t i = 0; i < idx.size(); ++i)
-                idx2mat[i] = ((std::equal_range(index_list.begin(), index_list.end(), idx[i])).first - index_list.begin());
+                idx2mat[i] = ((std::equal_range(index_list.begin(), index_list.end(), idx[i])).first
+                              - index_list.begin());
 
-            for (std::size_t k = 0; k < (1UL<<N); ++k){ // loop over big matrix columns
+            for (std::size_t k = 0; k < (1UL << N); ++k) {  // loop over big matrix columns
                 // check if column index satisfies control-mask
                 // if not: leave it unchanged
-                std::vector<Complex> oldcol(1UL<<N);
-                for (std::size_t i = 0; i < (1UL<<N); ++i)
+                std::vector<Complex> oldcol(1UL << N);
+                for (std::size_t i = 0; i < (1UL << N); ++i)
                     oldcol[i] = M[i][k];
 
-                for (std::size_t i = 0; i < (1UL<<N); ++i){
+                for (std::size_t i = 0; i < (1UL << N); ++i) {
                     std::size_t local_i = 0;
                     for (std::size_t l = 0; l < idx.size(); ++l)
-                        local_i |= ((i >> idx2mat[l])&1UL)<<l;
+                        local_i |= ((i >> idx2mat[l]) & 1UL) << l;
 
                     Complex res = 0.;
-                    for (std::size_t j = 0; j < (1UL<<idx.size()); ++j){
+                    for (std::size_t j = 0; j < (1UL << idx.size()); ++j) {
                         std::size_t locidx = i;
                         for (std::size_t l = 0; l < idx.size(); ++l)
-                            if (((j >> l)&1UL) != ((i >> idx2mat[l])&1UL))
+                            if (((j >> l) & 1UL) != ((i >> idx2mat[l]) & 1UL))
                                 locidx ^= (1UL << idx2mat[l]);
                         res += oldcol[locidx] * item.get_matrix()[local_i][j];
                     }
@@ -103,58 +135,75 @@ public:
                 }
             }
         }
+#ifdef MEASURE_TIMINGS
+        const auto matrix = std::chrono::high_resolution_clock::now();
+#endif  // MEASURE_TIMINGS
+
         ctrl_list.reserve(ctrl_set_.size());
-        for (auto ctrl : ctrl_set_)
+        for (const auto& ctrl : ctrl_set_)
             ctrl_list.push_back(ctrl);
+
+#ifdef MEASURE_TIMINGS
+        using dur_t = std::chrono::duration<double, std::micro>;
+        const auto end = std::chrono::high_resolution_clock::now();
+        std::cout << "    " << std::setw(5) << index_list.size() << " / " << std::setw(5) << ctrl_list.size() << ": ";
+        std::cout << std::setprecision(10) << std::setw(20) << dur_t(create - start).count() << ", "
+                  << std::setprecision(10) << std::setw(20) << dur_t(matrix - create).count() << ", "
+                  << std::setprecision(10) << std::setw(20) << dur_t(end - matrix).count() << ", "
+                  << std::setprecision(10) << std::setw(20) << dur_t(end - start).count() << ", " << std::endl;
+#endif  // MEASURE_TIMINGS
     }
 
-private:
-    void add_controls(Matrix &matrix, IndexVector &indexList, IndexVector const& new_ctrls){
-        indexList.reserve(indexList.size()+new_ctrls.size());
+ private:
+    void add_controls(Matrix& matrix, IndexVector& indexList, IndexVector const& new_ctrls) {
+        indexList.reserve(indexList.size() + new_ctrls.size());
         indexList.insert(indexList.end(), new_ctrls.begin(), new_ctrls.end());
 
         std::size_t F = (1UL << new_ctrls.size());
-        Matrix newmatrix(F*matrix.size(), std::vector<Complex, aligned_allocator<Complex,64>>(F*matrix.size(), 0.));
+        Matrix newmatrix(F * matrix.size(),
+                         std::vector<Complex, aligned_allocator<Complex, 64>>(F * matrix.size(), 0.));
 
-        std::size_t Offset = newmatrix.size()-matrix.size();
+        std::size_t Offset = newmatrix.size() - matrix.size();
 
+#pragma GCC ivdep
         for (std::size_t i = 0; i < Offset; ++i)
             newmatrix[i][i] = 1.;
-        for (std::size_t i = 0; i < matrix.size(); ++i){
+#pragma GCC ivdep
+        for (std::size_t i = 0; i < matrix.size(); ++i) {
             for (std::size_t j = 0; j < matrix.size(); ++j)
-                newmatrix[Offset+i][Offset+j] = matrix[i][j];
+                newmatrix[Offset + i][Offset + j] = matrix[i][j];
         }
         matrix = std::move(newmatrix);
     }
 
-    void handle_controls(Matrix &matrix, IndexVector &indexList, IndexVector const& ctrlList){
-        auto unhandled_ctrl = ctrl_set_; // will contain all ctrls that are not part of the new command
-        // --> need to be removed from the global mask and the controls incorporated into the old
-        // commands (the ones already in the list).
-
-        for (auto ctrlIdx : ctrlList){
-            if (ctrl_set_.count(ctrlIdx) == 0){ // need to either add it to the list or to the command
-                if (items_.size() > 0){ // add it to the command
+    void handle_controls(Matrix& matrix, IndexVector& indexList, IndexVector const& ctrlList) {
+        auto unhandled_ctrl = ctrl_set_;  // will contain all ctrls that are
+                                          // not part of the new command
+        // --> need to be removed from the global mask and the controls
+        // incorporated into the old commands (the ones already in the list).
+
+        for (const auto& ctrlIdx : ctrlList) {
+            if (ctrl_set_.count(ctrlIdx) == 0) {  // need to either add it to the list or to the
+                                                  // command
+                if (items_.size() > 0) {          // add it to the command
                     add_controls(matrix, indexList, {ctrlIdx});
                     set_.insert(ctrlIdx);
-                }
-                else // add it to the list
+                } else  // add it to the list
                     ctrl_set_.emplace(ctrlIdx);
-            }
-            else
+            } else
                 unhandled_ctrl.erase(ctrlIdx);
         }
-        // remove global controls which are no longer global (because the current command didn't
-        // have it)
-        if (unhandled_ctrl.size() > 0){
+        // remove global controls which are no longer global (because the
+        // current command didn't have it)
+        if (unhandled_ctrl.size() > 0) {
             IndexVector new_ctrls;
             new_ctrls.reserve(unhandled_ctrl.size());
-            for (auto idx : unhandled_ctrl){
+            for (const auto& idx : unhandled_ctrl) {
                 new_ctrls.push_back(idx);
                 ctrl_set_.erase(idx);
                 set_.insert(idx);
             }
-            for (auto &item : items_)
+            for (auto& item : items_)
                 add_controls(item.get_matrix(), item.get_indices(), new_ctrls);
         }
     }
@@ -163,5 +212,6 @@ private:
     ItemVector items_;
     IndexSet ctrl_set_;
 };
+}  // namespace projectq
 
 #endif
diff -Npur projectq-orig/projectq/backends/_sim/_cppkernels/intrin/alignedallocator.hpp projectq-new/projectq/backends/_sim/_cppkernels/intrin/alignedallocator.hpp
--- projectq-orig/projectq/backends/_sim/_cppkernels/intrin/alignedallocator.hpp	2022-04-27 11:49:17.000000000 +0200
+++ projectq-new/projectq/backends/_sim/_cppkernels/intrin/alignedallocator.hpp	2022-06-17 12:37:17.816198916 +0200
@@ -15,22 +15,22 @@
 #pragma once
 
 #ifdef _WIN32
-#include <malloc.h>
+#    include <malloc.h>
 #else
-#include <cstdlib>
+#    include <cstdlib>
 #endif
 #include <cstddef>
 #include <memory>
 #include <new>
+#include <utility>
 
 #if __cplusplus < 201103L
-#define noexcept
+#    define noexcept
 #endif
 
-
+namespace projectq {
 template <typename T, unsigned int Alignment>
-class aligned_allocator
-{
+class aligned_allocator {
  public:
     typedef T* pointer;
     typedef T const* const_pointer;
@@ -41,26 +41,25 @@ class aligned_allocator
     typedef std::ptrdiff_t difference_type;
 
     template <typename U>
-    struct rebind
-    {
+    struct rebind {
         typedef aligned_allocator<U, Alignment> other;
     };
 
-    aligned_allocator() noexcept {}
-    aligned_allocator(aligned_allocator const&) noexcept {}
+    aligned_allocator() noexcept {
+    }
+    aligned_allocator(aligned_allocator const&) noexcept {
+    }
     template <typename U>
-    aligned_allocator(aligned_allocator<U, Alignment> const&) noexcept
-    {
+    aligned_allocator(aligned_allocator<U, Alignment> const&) noexcept {
     }
 
-    pointer allocate(size_type n)
-    {
+    pointer allocate(size_type n) {
         pointer p;
 
-
 #ifdef _WIN32
         p = reinterpret_cast<pointer>(_aligned_malloc(n * sizeof(T), Alignment));
-        if (p == 0) throw std::bad_alloc();
+        if (p == 0)
+            throw std::bad_alloc();
 #else
         if (posix_memalign(reinterpret_cast<void**>(&p), Alignment, n * sizeof(T)))
             throw std::bad_alloc();
@@ -68,8 +67,7 @@ class aligned_allocator
         return p;
     }
 
-    void deallocate(pointer p, size_type) noexcept
-    {
+    void deallocate(pointer p, size_type) noexcept {
 #ifdef _WIN32
         _aligned_free(p);
 #else
@@ -77,43 +75,40 @@ class aligned_allocator
 #endif
     }
 
-    size_type max_size() const noexcept
-    {
-        std::allocator<T> a;
-        return a.max_size();
-    }
-
 #if __cplusplus >= 201103L
     template <typename C, class... Args>
-    void construct(C* c, Args&&... args)
-    {
-        new ((void*)c) C(std::forward<Args>(args)...);
+    void construct(C* c, Args&&... args) {
+        new (reinterpret_cast<void*>(c)) C(std::forward<Args>(args)...);
     }
 #else
-    void construct(pointer p, const_reference t) { new ((void*)p) T(t); }
+    void construct(pointer p, const_reference t) {
+        new (reinterpret_cast<void*>(p)) T(t);
+    }
 #endif
 
     template <typename C>
-    void destroy(C* c)
-    {
+    void destroy(C* c) {
         c->~C();
     }
 
-    bool operator==(aligned_allocator const&) const noexcept { return true; }
-    bool operator!=(aligned_allocator const&) const noexcept { return false; }
+    bool operator==(aligned_allocator const&) const noexcept {
+        return true;
+    }
+    bool operator!=(aligned_allocator const&) const noexcept {
+        return false;
+    }
     template <typename U, unsigned int UAlignment>
-    bool operator==(aligned_allocator<U, UAlignment> const&) const noexcept
-    {
+    bool operator==(aligned_allocator<U, UAlignment> const&) const noexcept {
         return false;
     }
 
     template <typename U, unsigned int UAlignment>
-    bool operator!=(aligned_allocator<U, UAlignment> const&) const noexcept
-    {
+    bool operator!=(aligned_allocator<U, UAlignment> const&) const noexcept {
         return true;
     }
 };
+}  // namespace projectq
 
 #if __cplusplus < 201103L
-#undef noexcept
+#    undef noexcept
 #endif
diff -Npur projectq-orig/projectq/backends/_sim/_cppkernels/intrin/cintrin.hpp projectq-new/projectq/backends/_sim/_cppkernels/intrin/cintrin.hpp
--- projectq-orig/projectq/backends/_sim/_cppkernels/intrin/cintrin.hpp	2022-04-27 11:49:17.000000000 +0200
+++ projectq-new/projectq/backends/_sim/_cppkernels/intrin/cintrin.hpp	2022-06-17 12:37:17.816198916 +0200
@@ -16,109 +16,114 @@
 #define CINTRIN_HPP_
 
 #include <immintrin.h>
+
 #include <complex>
 
 #ifndef _mm256_set_m128d
-#define _mm256_set_m128d(hi,lo) _mm256_insertf128_pd(_mm256_castpd128_pd256(lo), (hi), 0x1)
+#    define _mm256_set_m128d(hi, lo) _mm256_insertf128_pd(_mm256_castpd128_pd256(lo), (hi), 0x1)
 #endif
 #ifndef _mm256_storeu2_m128d
-#define _mm256_storeu2_m128d(hiaddr,loaddr,a) do { __m256d _a = (a); _mm_storeu_pd((loaddr), _mm256_castpd256_pd128(_a)); _mm_storeu_pd((hiaddr), _mm256_extractf128_pd(_a, 0x1)); } while (0)
+#    define _mm256_storeu2_m128d(hiaddr, loaddr, a)                                                                    \
+        do {                                                                                                           \
+            __m256d _a = (a);                                                                                          \
+            _mm_storeu_pd((loaddr), _mm256_castpd256_pd128(_a));                                                       \
+            _mm_storeu_pd((hiaddr), _mm256_extractf128_pd(_a, 0x1));                                                   \
+        } while (0)
 #endif
 #ifndef _mm256_loadu2_m128d
-#define _mm256_loadu2_m128d(hiaddr,loaddr) _mm256_set_m128d(_mm_loadu_pd(hiaddr), _mm_loadu_pd(loaddr))
+#    define _mm256_loadu2_m128d(hiaddr, loaddr) _mm256_set_m128d(_mm_loadu_pd(hiaddr), _mm_loadu_pd(loaddr))
 #endif
 
 template <class T>
 class cintrin;
 
 template <>
-class cintrin<double>{
-public:
+class cintrin<double> {
+ public:
     using calc_t = double;
     using ret_t = cintrin<calc_t>;
 
-
-    cintrin() {}
+    cintrin() {
+    }
 
     template <class U>
-    cintrin(U const *p){
-        v_ = _mm256_load_pd((calc_t const*)p);
+    cintrin(U const* p) {
+        v_ = _mm256_load_pd((calc_t const*) p);
     }
 
     template <class U>
-    cintrin(U const *p1, U const *p2){
-        v_ = _mm256_loadu2_m128d((calc_t const*)p2, (calc_t const*)p1);
+    cintrin(U const* p1, U const* p2) {
+        v_ = _mm256_loadu2_m128d((calc_t const*) p2, (calc_t const*) p1);
     }
 
     template <class U>
-    cintrin(U const *p, bool broadcast){
-        auto tmp = _mm_load_pd((calc_t const*)p);
+    cintrin(U const* p, bool broadcast) {
+        auto tmp = _mm_load_pd((calc_t const*) p);
         v_ = _mm256_broadcast_pd(&tmp);
     }
 
-    explicit cintrin(calc_t const& s1){
+    explicit cintrin(calc_t const& s1) {
         v_ = _mm256_set1_pd(s1);
     }
 
-    cintrin(__m256d const& v) : v_(v) {  }
+    cintrin(__m256d const& v) : v_(v) {
+    }
 
-    std::complex<calc_t> operator[](unsigned i){
+    std::complex<calc_t> operator[](unsigned i) {
         calc_t v[4];
         _mm256_store_pd(v, v_);
-        return {v[i*2], v[i*2+1]};
+        return {v[i * 2], v[i * 2 + 1]};
     }
 
     template <class U>
-    void store(U *p) const{
-        _mm256_store_pd((calc_t *)p, v_);
+    void store(U* p) const {
+        _mm256_store_pd((calc_t*) p, v_);
     }
 
     template <class U>
-    void store(U *p1, U *p2) const{
-        _mm256_storeu2_m128d((calc_t *)p2, (calc_t *)p1, v_);
+    void store(U* p1, U* p2) const {
+        _mm256_storeu2_m128d((calc_t*) p2, (calc_t*) p1, v_);
     }
     __m256d v_;
 };
 
-inline cintrin<double> mul(cintrin<double> const& c1, cintrin<double> const& c2, cintrin<double> const& c2tm){
+inline cintrin<double> mul(cintrin<double> const& c1, cintrin<double> const& c2, cintrin<double> const& c2tm) {
     auto ac_bd = _mm256_mul_pd(c1.v_, c2.v_);
     auto multbmadmc = _mm256_mul_pd(c1.v_, c2tm.v_);
     return cintrin<double>(_mm256_hsub_pd(ac_bd, multbmadmc));
 }
-inline cintrin<double> operator*(cintrin<double> const& c1, cintrin<double> const& c2){
+inline cintrin<double> operator*(cintrin<double> const& c1, cintrin<double> const& c2) {
     __m256d neg = _mm256_setr_pd(1.0, -1.0, 1.0, -1.0);
     auto badc = _mm256_permute_pd(c2.v_, 5);
     auto bmadmc = _mm256_mul_pd(badc, neg);
     return mul(c1, c2, bmadmc);
 }
-inline cintrin<double> operator+(cintrin<double> const& c1, cintrin<double> const& c2){
+inline cintrin<double> operator+(cintrin<double> const& c1, cintrin<double> const& c2) {
     return cintrin<double>(_mm256_add_pd(c1.v_, c2.v_));
 }
-inline cintrin<double> operator*(cintrin<double> const& c1, double const& d){
+inline cintrin<double> operator*(cintrin<double> const& c1, double const& d) {
     auto d_d = _mm256_set1_pd(d);
     return _mm256_mul_pd(c1.v_, d_d);
 }
-inline cintrin<double> operator*(double const& d, cintrin<double> const& c1){
-    return c1*d;
+inline cintrin<double> operator*(double const& d, cintrin<double> const& c1) {
+    return c1 * d;
 }
 
-
-
-inline __m256d mul(__m256d const& c1, __m256d const& c2, __m256d const& c2tm){
+inline __m256d mul(__m256d const& c1, __m256d const& c2, __m256d const& c2tm) {
     auto ac_bd = _mm256_mul_pd(c1, c2);
     auto multbmadmc = _mm256_mul_pd(c1, c2tm);
     return _mm256_hsub_pd(ac_bd, multbmadmc);
 }
-inline __m256d add(__m256d const& c1, __m256d const& c2){
+inline __m256d add(__m256d const& c1, __m256d const& c2) {
     return _mm256_add_pd(c1, c2);
 }
 template <class U>
-inline __m256d load2(U *p){
-    auto tmp = _mm_load_pd((double const*)p);
+inline __m256d load2(U* p) {
+    auto tmp = _mm_load_pd((double const*) p);
     return _mm256_broadcast_pd(&tmp);
 }
 template <class U>
-inline __m256d load(U const*p1, U const*p2){
-    return _mm256_loadu2_m128d((double const*)p2, (double const*)p1);
+inline __m256d load(U const* p1, U const* p2) {
+    return _mm256_loadu2_m128d((double const*) p2, (double const*) p1);
 }
 #endif
diff -Npur projectq-orig/projectq/backends/_sim/_cppkernels/intrin/kernel1.hpp projectq-new/projectq/backends/_sim/_cppkernels/intrin/kernel1.hpp
--- projectq-orig/projectq/backends/_sim/_cppkernels/intrin/kernel1.hpp	2022-04-27 11:49:17.000000000 +0200
+++ projectq-new/projectq/backends/_sim/_cppkernels/intrin/kernel1.hpp	2022-06-17 12:37:17.816198916 +0200
@@ -13,21 +13,19 @@
 // limitations under the License.
 
 template <class V, class M>
-inline void kernel_core(V &psi, std::size_t I, std::size_t d0, M const& m, M const& mt)
-{
+inline void kernel_core(V& psi, std::size_t I, std::size_t d0, M const& m, M const& mt) {
     __m256d v[2];
 
     v[0] = load2(&psi[I]);
     v[1] = load2(&psi[I + d0]);
 
-    _mm256_storeu2_m128d((double*)&psi[I + d0], (double*)&psi[I], add(mul(v[0], m[0], mt[0]), mul(v[1], m[1], mt[1])));
-
+    _mm256_storeu2_m128d((double*) &psi[I + d0], (double*) &psi[I],
+                         add(mul(v[0], m[0], mt[0]), mul(v[1], m[1], mt[1])));
 }
 
 // bit indices id[.] are given from high to low (e.g. control first for CNOT)
 template <class V, class M>
-void kernel(V &psi, unsigned id0, M const& m, std::size_t ctrlmask)
-{
+void kernel(V& psi, unsigned id0, M const& m, std::size_t ctrlmask) {
     std::size_t n = psi.size();
     std::size_t d0 = 1UL << id0;
 
@@ -35,26 +33,25 @@ void kernel(V &psi, unsigned id0, M cons
     __m256d mmt[2];
 
     __m256d neg = _mm256_setr_pd(1.0, -1.0, 1.0, -1.0);
-    for (unsigned i = 0; i < 2; ++i){
+    for (unsigned i = 0; i < 2; ++i) {
         auto badc = _mm256_permute_pd(mm[i], 5);
         mmt[i] = _mm256_mul_pd(badc, neg);
     }
 
     std::size_t dsorted[] = {d0};
 
-    if (ctrlmask == 0){
-        #pragma omp for collapse(LOOP_COLLAPSE1) schedule(static)
-        for (std::size_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]){
-            for (std::size_t i1 = 0; i1 < dsorted[0]; ++i1){
+    if (ctrlmask == 0) {
+#pragma omp for collapse(LOOP_COLLAPSE1) schedule(static)
+        for (omp::idx_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]) {
+            for (omp::idx_t i1 = 0; i1 < dsorted[0]; ++i1) {
                 kernel_core(psi, i0 + i1, d0, mm, mmt);
             }
         }
-    }
-    else{
-        #pragma omp for collapse(LOOP_COLLAPSE1) schedule(static)
-        for (std::size_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]){
-            for (std::size_t i1 = 0; i1 < dsorted[0]; ++i1){
-                if (((i0 + i1)&ctrlmask) == ctrlmask)
+    } else {
+#pragma omp for collapse(LOOP_COLLAPSE1) schedule(static)
+        for (omp::idx_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]) {
+            for (omp::idx_t i1 = 0; i1 < dsorted[0]; ++i1) {
+                if (((i0 + i1) & ctrlmask) == ctrlmask)
                     kernel_core(psi, i0 + i1, d0, mm, mmt);
             }
         }
diff -Npur projectq-orig/projectq/backends/_sim/_cppkernels/intrin/kernel2.hpp projectq-new/projectq/backends/_sim/_cppkernels/intrin/kernel2.hpp
--- projectq-orig/projectq/backends/_sim/_cppkernels/intrin/kernel2.hpp	2022-04-27 11:49:17.000000000 +0200
+++ projectq-new/projectq/backends/_sim/_cppkernels/intrin/kernel2.hpp	2022-06-17 12:37:17.816198916 +0200
@@ -13,8 +13,7 @@
 // limitations under the License.
 
 template <class V, class M>
-inline void kernel_core(V &psi, std::size_t I, std::size_t d0, std::size_t d1, M const& m, M const& mt)
-{
+inline void kernel_core(V& psi, std::size_t I, std::size_t d0, std::size_t d1, M const& m, M const& mt) {
     __m256d v[4];
 
     v[0] = load2(&psi[I]);
@@ -22,47 +21,50 @@ inline void kernel_core(V &psi, std::siz
     v[2] = load2(&psi[I + d1]);
     v[3] = load2(&psi[I + d0 + d1]);
 
-    _mm256_storeu2_m128d((double*)&psi[I + d0], (double*)&psi[I], add(mul(v[0], m[0], mt[0]), add(mul(v[1], m[1], mt[1]), add(mul(v[2], m[2], mt[2]), mul(v[3], m[3], mt[3])))));
-    _mm256_storeu2_m128d((double*)&psi[I + d0 + d1], (double*)&psi[I + d1], add(mul(v[0], m[4], mt[4]), add(mul(v[1], m[5], mt[5]), add(mul(v[2], m[6], mt[6]), mul(v[3], m[7], mt[7])))));
-
+    _mm256_storeu2_m128d(
+        (double*) &psi[I + d0], (double*) &psi[I],
+        add(mul(v[0], m[0], mt[0]), add(mul(v[1], m[1], mt[1]), add(mul(v[2], m[2], mt[2]), mul(v[3], m[3], mt[3])))));
+    _mm256_storeu2_m128d(
+        (double*) &psi[I + d0 + d1], (double*) &psi[I + d1],
+        add(mul(v[0], m[4], mt[4]), add(mul(v[1], m[5], mt[5]), add(mul(v[2], m[6], mt[6]), mul(v[3], m[7], mt[7])))));
 }
 
 // bit indices id[.] are given from high to low (e.g. control first for CNOT)
 template <class V, class M>
-void kernel(V &psi, unsigned id1, unsigned id0, M const& m, std::size_t ctrlmask)
-{
+void kernel(V& psi, unsigned id1, unsigned id0, M const& m, std::size_t ctrlmask) {
     std::size_t n = psi.size();
     std::size_t d0 = 1UL << id0;
     std::size_t d1 = 1UL << id1;
 
-    __m256d mm[] = {load(&m[0][0], &m[1][0]), load(&m[0][1], &m[1][1]), load(&m[0][2], &m[1][2]), load(&m[0][3], &m[1][3]), load(&m[2][0], &m[3][0]), load(&m[2][1], &m[3][1]), load(&m[2][2], &m[3][2]), load(&m[2][3], &m[3][3])};
+    __m256d mm[] = {load(&m[0][0], &m[1][0]), load(&m[0][1], &m[1][1]), load(&m[0][2], &m[1][2]),
+                    load(&m[0][3], &m[1][3]), load(&m[2][0], &m[3][0]), load(&m[2][1], &m[3][1]),
+                    load(&m[2][2], &m[3][2]), load(&m[2][3], &m[3][3])};
     __m256d mmt[8];
 
     __m256d neg = _mm256_setr_pd(1.0, -1.0, 1.0, -1.0);
-    for (unsigned i = 0; i < 8; ++i){
+    for (unsigned i = 0; i < 8; ++i) {
         auto badc = _mm256_permute_pd(mm[i], 5);
         mmt[i] = _mm256_mul_pd(badc, neg);
     }
 
-    std::size_t dsorted[] = {d0 , d1};
+    std::size_t dsorted[] = {d0, d1};
     std::sort(dsorted, dsorted + 2, std::greater<std::size_t>());
 
-    if (ctrlmask == 0){
-        #pragma omp for collapse(LOOP_COLLAPSE2) schedule(static)
-        for (std::size_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]){
-            for (std::size_t i1 = 0; i1 < dsorted[0]; i1 += 2 * dsorted[1]){
-                for (std::size_t i2 = 0; i2 < dsorted[1]; ++i2){
+    if (ctrlmask == 0) {
+#pragma omp for collapse(LOOP_COLLAPSE2) schedule(static)
+        for (omp::idx_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]) {
+            for (omp::idx_t i1 = 0; i1 < dsorted[0]; i1 += 2 * dsorted[1]) {
+                for (omp::idx_t i2 = 0; i2 < dsorted[1]; ++i2) {
                     kernel_core(psi, i0 + i1 + i2, d0, d1, mm, mmt);
                 }
             }
         }
-    }
-    else{
-        #pragma omp for collapse(LOOP_COLLAPSE2) schedule(static)
-        for (std::size_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]){
-            for (std::size_t i1 = 0; i1 < dsorted[0]; i1 += 2 * dsorted[1]){
-                for (std::size_t i2 = 0; i2 < dsorted[1]; ++i2){
-                    if (((i0 + i1 + i2)&ctrlmask) == ctrlmask)
+    } else {
+#pragma omp for collapse(LOOP_COLLAPSE2) schedule(static)
+        for (omp::idx_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]) {
+            for (omp::idx_t i1 = 0; i1 < dsorted[0]; i1 += 2 * dsorted[1]) {
+                for (omp::idx_t i2 = 0; i2 < dsorted[1]; ++i2) {
+                    if (((i0 + i1 + i2) & ctrlmask) == ctrlmask)
                         kernel_core(psi, i0 + i1 + i2, d0, d1, mm, mmt);
                 }
             }
diff -Npur projectq-orig/projectq/backends/_sim/_cppkernels/intrin/kernel3.hpp projectq-new/projectq/backends/_sim/_cppkernels/intrin/kernel3.hpp
--- projectq-orig/projectq/backends/_sim/_cppkernels/intrin/kernel3.hpp	2022-04-27 11:49:17.000000000 +0200
+++ projectq-new/projectq/backends/_sim/_cppkernels/intrin/kernel3.hpp	2022-06-17 12:37:17.816198916 +0200
@@ -13,8 +13,8 @@
 // limitations under the License.
 
 template <class V, class M>
-inline void kernel_core(V &psi, std::size_t I, std::size_t d0, std::size_t d1, std::size_t d2, M const& m, M const& mt)
-{
+inline void kernel_core(V& psi, std::size_t I, std::size_t d0, std::size_t d1, std::size_t d2, M const& m,
+                        M const& mt) {
     __m256d v[4];
 
     v[0] = load2(&psi[I]);
@@ -24,63 +24,84 @@ inline void kernel_core(V &psi, std::siz
 
     __m256d tmp[4];
 
-    tmp[0] = add(mul(v[0], m[0], mt[0]), add(mul(v[1], m[1], mt[1]), add(mul(v[2], m[2], mt[2]), mul(v[3], m[3], mt[3]))));
-    tmp[1] = add(mul(v[0], m[4], mt[4]), add(mul(v[1], m[5], mt[5]), add(mul(v[2], m[6], mt[6]), mul(v[3], m[7], mt[7]))));
-    tmp[2] = add(mul(v[0], m[8], mt[8]), add(mul(v[1], m[9], mt[9]), add(mul(v[2], m[10], mt[10]), mul(v[3], m[11], mt[11]))));
-    tmp[3] = add(mul(v[0], m[12], mt[12]), add(mul(v[1], m[13], mt[13]), add(mul(v[2], m[14], mt[14]), mul(v[3], m[15], mt[15]))));
+    tmp[0] = add(mul(v[0], m[0], mt[0]),
+                 add(mul(v[1], m[1], mt[1]), add(mul(v[2], m[2], mt[2]), mul(v[3], m[3], mt[3]))));
+    tmp[1] = add(mul(v[0], m[4], mt[4]),
+                 add(mul(v[1], m[5], mt[5]), add(mul(v[2], m[6], mt[6]), mul(v[3], m[7], mt[7]))));
+    tmp[2] = add(mul(v[0], m[8], mt[8]),
+                 add(mul(v[1], m[9], mt[9]), add(mul(v[2], m[10], mt[10]), mul(v[3], m[11], mt[11]))));
+    tmp[3] = add(mul(v[0], m[12], mt[12]),
+                 add(mul(v[1], m[13], mt[13]), add(mul(v[2], m[14], mt[14]), mul(v[3], m[15], mt[15]))));
 
     v[0] = load2(&psi[I + d2]);
     v[1] = load2(&psi[I + d0 + d2]);
     v[2] = load2(&psi[I + d1 + d2]);
     v[3] = load2(&psi[I + d0 + d1 + d2]);
 
-    _mm256_storeu2_m128d((double*)&psi[I + d0], (double*)&psi[I], add(tmp[0], add(mul(v[0], m[16], mt[16]), add(mul(v[1], m[17], mt[17]), add(mul(v[2], m[18], mt[18]), mul(v[3], m[19], mt[19]))))));
-    _mm256_storeu2_m128d((double*)&psi[I + d0 + d1], (double*)&psi[I + d1], add(tmp[1], add(mul(v[0], m[20], mt[20]), add(mul(v[1], m[21], mt[21]), add(mul(v[2], m[22], mt[22]), mul(v[3], m[23], mt[23]))))));
-    _mm256_storeu2_m128d((double*)&psi[I + d0 + d2], (double*)&psi[I + d2], add(tmp[2], add(mul(v[0], m[24], mt[24]), add(mul(v[1], m[25], mt[25]), add(mul(v[2], m[26], mt[26]), mul(v[3], m[27], mt[27]))))));
-    _mm256_storeu2_m128d((double*)&psi[I + d0 + d1 + d2], (double*)&psi[I + d1 + d2], add(tmp[3], add(mul(v[0], m[28], mt[28]), add(mul(v[1], m[29], mt[29]), add(mul(v[2], m[30], mt[30]), mul(v[3], m[31], mt[31]))))));
-
+    _mm256_storeu2_m128d(
+        (double*) &psi[I + d0], (double*) &psi[I],
+        add(tmp[0], add(mul(v[0], m[16], mt[16]),
+                        add(mul(v[1], m[17], mt[17]), add(mul(v[2], m[18], mt[18]), mul(v[3], m[19], mt[19]))))));
+    _mm256_storeu2_m128d(
+        (double*) &psi[I + d0 + d1], (double*) &psi[I + d1],
+        add(tmp[1], add(mul(v[0], m[20], mt[20]),
+                        add(mul(v[1], m[21], mt[21]), add(mul(v[2], m[22], mt[22]), mul(v[3], m[23], mt[23]))))));
+    _mm256_storeu2_m128d(
+        (double*) &psi[I + d0 + d2], (double*) &psi[I + d2],
+        add(tmp[2], add(mul(v[0], m[24], mt[24]),
+                        add(mul(v[1], m[25], mt[25]), add(mul(v[2], m[26], mt[26]), mul(v[3], m[27], mt[27]))))));
+    _mm256_storeu2_m128d(
+        (double*) &psi[I + d0 + d1 + d2], (double*) &psi[I + d1 + d2],
+        add(tmp[3], add(mul(v[0], m[28], mt[28]),
+                        add(mul(v[1], m[29], mt[29]), add(mul(v[2], m[30], mt[30]), mul(v[3], m[31], mt[31]))))));
 }
 
 // bit indices id[.] are given from high to low (e.g. control first for CNOT)
 template <class V, class M>
-void kernel(V &psi, unsigned id2, unsigned id1, unsigned id0, M const& m, std::size_t ctrlmask)
-{
+void kernel(V& psi, unsigned id2, unsigned id1, unsigned id0, M const& m, std::size_t ctrlmask) {
     std::size_t n = psi.size();
     std::size_t d0 = 1UL << id0;
     std::size_t d1 = 1UL << id1;
     std::size_t d2 = 1UL << id2;
 
-    __m256d mm[] = {load(&m[0][0], &m[1][0]), load(&m[0][1], &m[1][1]), load(&m[0][2], &m[1][2]), load(&m[0][3], &m[1][3]), load(&m[2][0], &m[3][0]), load(&m[2][1], &m[3][1]), load(&m[2][2], &m[3][2]), load(&m[2][3], &m[3][3]), load(&m[4][0], &m[5][0]), load(&m[4][1], &m[5][1]), load(&m[4][2], &m[5][2]), load(&m[4][3], &m[5][3]), load(&m[6][0], &m[7][0]), load(&m[6][1], &m[7][1]), load(&m[6][2], &m[7][2]), load(&m[6][3], &m[7][3]), load(&m[0][4], &m[1][4]), load(&m[0][5], &m[1][5]), load(&m[0][6], &m[1][6]), load(&m[0][7], &m[1][7]), load(&m[2][4], &m[3][4]), load(&m[2][5], &m[3][5]), load(&m[2][6], &m[3][6]), load(&m[2][7], &m[3][7]), load(&m[4][4], &m[5][4]), load(&m[4][5], &m[5][5]), load(&m[4][6], &m[5][6]), load(&m[4][7], &m[5][7]), load(&m[6][4], &m[7][4]), load(&m[6][5], &m[7][5]), load(&m[6][6], &m[7][6]), load(&m[6][7], &m[7][7])};
+    __m256d mm[] = {
+        load(&m[0][0], &m[1][0]), load(&m[0][1], &m[1][1]), load(&m[0][2], &m[1][2]), load(&m[0][3], &m[1][3]),
+        load(&m[2][0], &m[3][0]), load(&m[2][1], &m[3][1]), load(&m[2][2], &m[3][2]), load(&m[2][3], &m[3][3]),
+        load(&m[4][0], &m[5][0]), load(&m[4][1], &m[5][1]), load(&m[4][2], &m[5][2]), load(&m[4][3], &m[5][3]),
+        load(&m[6][0], &m[7][0]), load(&m[6][1], &m[7][1]), load(&m[6][2], &m[7][2]), load(&m[6][3], &m[7][3]),
+        load(&m[0][4], &m[1][4]), load(&m[0][5], &m[1][5]), load(&m[0][6], &m[1][6]), load(&m[0][7], &m[1][7]),
+        load(&m[2][4], &m[3][4]), load(&m[2][5], &m[3][5]), load(&m[2][6], &m[3][6]), load(&m[2][7], &m[3][7]),
+        load(&m[4][4], &m[5][4]), load(&m[4][5], &m[5][5]), load(&m[4][6], &m[5][6]), load(&m[4][7], &m[5][7]),
+        load(&m[6][4], &m[7][4]), load(&m[6][5], &m[7][5]), load(&m[6][6], &m[7][6]), load(&m[6][7], &m[7][7])};
     __m256d mmt[32];
 
     __m256d neg = _mm256_setr_pd(1.0, -1.0, 1.0, -1.0);
-    for (unsigned i = 0; i < 32; ++i){
+    for (unsigned i = 0; i < 32; ++i) {
         auto badc = _mm256_permute_pd(mm[i], 5);
         mmt[i] = _mm256_mul_pd(badc, neg);
     }
 
-    std::size_t dsorted[] = {d0 , d1, d2};
+    std::size_t dsorted[] = {d0, d1, d2};
     std::sort(dsorted, dsorted + 3, std::greater<std::size_t>());
 
-    if (ctrlmask == 0){
-        #pragma omp for collapse(LOOP_COLLAPSE3) schedule(static)
-        for (std::size_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]){
-            for (std::size_t i1 = 0; i1 < dsorted[0]; i1 += 2 * dsorted[1]){
-                for (std::size_t i2 = 0; i2 < dsorted[1]; i2 += 2 * dsorted[2]){
-                    for (std::size_t i3 = 0; i3 < dsorted[2]; ++i3){
+    if (ctrlmask == 0) {
+#pragma omp for collapse(LOOP_COLLAPSE3) schedule(static)
+        for (omp::idx_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]) {
+            for (omp::idx_t i1 = 0; i1 < dsorted[0]; i1 += 2 * dsorted[1]) {
+                for (omp::idx_t i2 = 0; i2 < dsorted[1]; i2 += 2 * dsorted[2]) {
+                    for (omp::idx_t i3 = 0; i3 < dsorted[2]; ++i3) {
                         kernel_core(psi, i0 + i1 + i2 + i3, d0, d1, d2, mm, mmt);
                     }
                 }
             }
         }
-    }
-    else{
-        #pragma omp for collapse(LOOP_COLLAPSE3) schedule(static)
-        for (std::size_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]){
-            for (std::size_t i1 = 0; i1 < dsorted[0]; i1 += 2 * dsorted[1]){
-                for (std::size_t i2 = 0; i2 < dsorted[1]; i2 += 2 * dsorted[2]){
-                    for (std::size_t i3 = 0; i3 < dsorted[2]; ++i3){
-                        if (((i0 + i1 + i2 + i3)&ctrlmask) == ctrlmask)
+    } else {
+#pragma omp for collapse(LOOP_COLLAPSE3) schedule(static)
+        for (omp::idx_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]) {
+            for (omp::idx_t i1 = 0; i1 < dsorted[0]; i1 += 2 * dsorted[1]) {
+                for (omp::idx_t i2 = 0; i2 < dsorted[1]; i2 += 2 * dsorted[2]) {
+                    for (omp::idx_t i3 = 0; i3 < dsorted[2]; ++i3) {
+                        if (((i0 + i1 + i2 + i3) & ctrlmask) == ctrlmask)
                             kernel_core(psi, i0 + i1 + i2 + i3, d0, d1, d2, mm, mmt);
                     }
                 }
diff -Npur projectq-orig/projectq/backends/_sim/_cppkernels/intrin/kernel4.hpp projectq-new/projectq/backends/_sim/_cppkernels/intrin/kernel4.hpp
--- projectq-orig/projectq/backends/_sim/_cppkernels/intrin/kernel4.hpp	2022-04-27 11:49:17.000000000 +0200
+++ projectq-new/projectq/backends/_sim/_cppkernels/intrin/kernel4.hpp	2022-06-17 12:37:17.816198916 +0200
@@ -13,8 +13,8 @@
 // limitations under the License.
 
 template <class V, class M>
-inline void kernel_core(V &psi, std::size_t I, std::size_t d0, std::size_t d1, std::size_t d2, std::size_t d3, M const& m, M const& mt)
-{
+inline void kernel_core(V& psi, std::size_t I, std::size_t d0, std::size_t d1, std::size_t d2, std::size_t d3,
+                        M const& m, M const& mt) {
     __m256d v[4];
 
     v[0] = load2(&psi[I]);
@@ -24,103 +24,190 @@ inline void kernel_core(V &psi, std::siz
 
     __m256d tmp[8];
 
-    tmp[0] = add(mul(v[0], m[0], mt[0]), add(mul(v[1], m[1], mt[1]), add(mul(v[2], m[2], mt[2]), mul(v[3], m[3], mt[3]))));
-    tmp[1] = add(mul(v[0], m[4], mt[4]), add(mul(v[1], m[5], mt[5]), add(mul(v[2], m[6], mt[6]), mul(v[3], m[7], mt[7]))));
-    tmp[2] = add(mul(v[0], m[8], mt[8]), add(mul(v[1], m[9], mt[9]), add(mul(v[2], m[10], mt[10]), mul(v[3], m[11], mt[11]))));
-    tmp[3] = add(mul(v[0], m[12], mt[12]), add(mul(v[1], m[13], mt[13]), add(mul(v[2], m[14], mt[14]), mul(v[3], m[15], mt[15]))));
-    tmp[4] = add(mul(v[0], m[16], mt[16]), add(mul(v[1], m[17], mt[17]), add(mul(v[2], m[18], mt[18]), mul(v[3], m[19], mt[19]))));
-    tmp[5] = add(mul(v[0], m[20], mt[20]), add(mul(v[1], m[21], mt[21]), add(mul(v[2], m[22], mt[22]), mul(v[3], m[23], mt[23]))));
-    tmp[6] = add(mul(v[0], m[24], mt[24]), add(mul(v[1], m[25], mt[25]), add(mul(v[2], m[26], mt[26]), mul(v[3], m[27], mt[27]))));
-    tmp[7] = add(mul(v[0], m[28], mt[28]), add(mul(v[1], m[29], mt[29]), add(mul(v[2], m[30], mt[30]), mul(v[3], m[31], mt[31]))));
+    tmp[0] = add(mul(v[0], m[0], mt[0]),
+                 add(mul(v[1], m[1], mt[1]), add(mul(v[2], m[2], mt[2]), mul(v[3], m[3], mt[3]))));
+    tmp[1] = add(mul(v[0], m[4], mt[4]),
+                 add(mul(v[1], m[5], mt[5]), add(mul(v[2], m[6], mt[6]), mul(v[3], m[7], mt[7]))));
+    tmp[2] = add(mul(v[0], m[8], mt[8]),
+                 add(mul(v[1], m[9], mt[9]), add(mul(v[2], m[10], mt[10]), mul(v[3], m[11], mt[11]))));
+    tmp[3] = add(mul(v[0], m[12], mt[12]),
+                 add(mul(v[1], m[13], mt[13]), add(mul(v[2], m[14], mt[14]), mul(v[3], m[15], mt[15]))));
+    tmp[4] = add(mul(v[0], m[16], mt[16]),
+                 add(mul(v[1], m[17], mt[17]), add(mul(v[2], m[18], mt[18]), mul(v[3], m[19], mt[19]))));
+    tmp[5] = add(mul(v[0], m[20], mt[20]),
+                 add(mul(v[1], m[21], mt[21]), add(mul(v[2], m[22], mt[22]), mul(v[3], m[23], mt[23]))));
+    tmp[6] = add(mul(v[0], m[24], mt[24]),
+                 add(mul(v[1], m[25], mt[25]), add(mul(v[2], m[26], mt[26]), mul(v[3], m[27], mt[27]))));
+    tmp[7] = add(mul(v[0], m[28], mt[28]),
+                 add(mul(v[1], m[29], mt[29]), add(mul(v[2], m[30], mt[30]), mul(v[3], m[31], mt[31]))));
 
     v[0] = load2(&psi[I + d2]);
     v[1] = load2(&psi[I + d0 + d2]);
     v[2] = load2(&psi[I + d1 + d2]);
     v[3] = load2(&psi[I + d0 + d1 + d2]);
 
-    tmp[0] = add(tmp[0], add(mul(v[0], m[32], mt[32]), add(mul(v[1], m[33], mt[33]), add(mul(v[2], m[34], mt[34]), mul(v[3], m[35], mt[35])))));
-    tmp[1] = add(tmp[1], add(mul(v[0], m[36], mt[36]), add(mul(v[1], m[37], mt[37]), add(mul(v[2], m[38], mt[38]), mul(v[3], m[39], mt[39])))));
-    tmp[2] = add(tmp[2], add(mul(v[0], m[40], mt[40]), add(mul(v[1], m[41], mt[41]), add(mul(v[2], m[42], mt[42]), mul(v[3], m[43], mt[43])))));
-    tmp[3] = add(tmp[3], add(mul(v[0], m[44], mt[44]), add(mul(v[1], m[45], mt[45]), add(mul(v[2], m[46], mt[46]), mul(v[3], m[47], mt[47])))));
-    tmp[4] = add(tmp[4], add(mul(v[0], m[48], mt[48]), add(mul(v[1], m[49], mt[49]), add(mul(v[2], m[50], mt[50]), mul(v[3], m[51], mt[51])))));
-    tmp[5] = add(tmp[5], add(mul(v[0], m[52], mt[52]), add(mul(v[1], m[53], mt[53]), add(mul(v[2], m[54], mt[54]), mul(v[3], m[55], mt[55])))));
-    tmp[6] = add(tmp[6], add(mul(v[0], m[56], mt[56]), add(mul(v[1], m[57], mt[57]), add(mul(v[2], m[58], mt[58]), mul(v[3], m[59], mt[59])))));
-    tmp[7] = add(tmp[7], add(mul(v[0], m[60], mt[60]), add(mul(v[1], m[61], mt[61]), add(mul(v[2], m[62], mt[62]), mul(v[3], m[63], mt[63])))));
+    tmp[0] = add(tmp[0], add(mul(v[0], m[32], mt[32]),
+                             add(mul(v[1], m[33], mt[33]), add(mul(v[2], m[34], mt[34]), mul(v[3], m[35], mt[35])))));
+    tmp[1] = add(tmp[1], add(mul(v[0], m[36], mt[36]),
+                             add(mul(v[1], m[37], mt[37]), add(mul(v[2], m[38], mt[38]), mul(v[3], m[39], mt[39])))));
+    tmp[2] = add(tmp[2], add(mul(v[0], m[40], mt[40]),
+                             add(mul(v[1], m[41], mt[41]), add(mul(v[2], m[42], mt[42]), mul(v[3], m[43], mt[43])))));
+    tmp[3] = add(tmp[3], add(mul(v[0], m[44], mt[44]),
+                             add(mul(v[1], m[45], mt[45]), add(mul(v[2], m[46], mt[46]), mul(v[3], m[47], mt[47])))));
+    tmp[4] = add(tmp[4], add(mul(v[0], m[48], mt[48]),
+                             add(mul(v[1], m[49], mt[49]), add(mul(v[2], m[50], mt[50]), mul(v[3], m[51], mt[51])))));
+    tmp[5] = add(tmp[5], add(mul(v[0], m[52], mt[52]),
+                             add(mul(v[1], m[53], mt[53]), add(mul(v[2], m[54], mt[54]), mul(v[3], m[55], mt[55])))));
+    tmp[6] = add(tmp[6], add(mul(v[0], m[56], mt[56]),
+                             add(mul(v[1], m[57], mt[57]), add(mul(v[2], m[58], mt[58]), mul(v[3], m[59], mt[59])))));
+    tmp[7] = add(tmp[7], add(mul(v[0], m[60], mt[60]),
+                             add(mul(v[1], m[61], mt[61]), add(mul(v[2], m[62], mt[62]), mul(v[3], m[63], mt[63])))));
 
     v[0] = load2(&psi[I + d3]);
     v[1] = load2(&psi[I + d0 + d3]);
     v[2] = load2(&psi[I + d1 + d3]);
     v[3] = load2(&psi[I + d0 + d1 + d3]);
 
-    tmp[0] = add(tmp[0], add(mul(v[0], m[64], mt[64]), add(mul(v[1], m[65], mt[65]), add(mul(v[2], m[66], mt[66]), mul(v[3], m[67], mt[67])))));
-    tmp[1] = add(tmp[1], add(mul(v[0], m[68], mt[68]), add(mul(v[1], m[69], mt[69]), add(mul(v[2], m[70], mt[70]), mul(v[3], m[71], mt[71])))));
-    tmp[2] = add(tmp[2], add(mul(v[0], m[72], mt[72]), add(mul(v[1], m[73], mt[73]), add(mul(v[2], m[74], mt[74]), mul(v[3], m[75], mt[75])))));
-    tmp[3] = add(tmp[3], add(mul(v[0], m[76], mt[76]), add(mul(v[1], m[77], mt[77]), add(mul(v[2], m[78], mt[78]), mul(v[3], m[79], mt[79])))));
-    tmp[4] = add(tmp[4], add(mul(v[0], m[80], mt[80]), add(mul(v[1], m[81], mt[81]), add(mul(v[2], m[82], mt[82]), mul(v[3], m[83], mt[83])))));
-    tmp[5] = add(tmp[5], add(mul(v[0], m[84], mt[84]), add(mul(v[1], m[85], mt[85]), add(mul(v[2], m[86], mt[86]), mul(v[3], m[87], mt[87])))));
-    tmp[6] = add(tmp[6], add(mul(v[0], m[88], mt[88]), add(mul(v[1], m[89], mt[89]), add(mul(v[2], m[90], mt[90]), mul(v[3], m[91], mt[91])))));
-    tmp[7] = add(tmp[7], add(mul(v[0], m[92], mt[92]), add(mul(v[1], m[93], mt[93]), add(mul(v[2], m[94], mt[94]), mul(v[3], m[95], mt[95])))));
+    tmp[0] = add(tmp[0], add(mul(v[0], m[64], mt[64]),
+                             add(mul(v[1], m[65], mt[65]), add(mul(v[2], m[66], mt[66]), mul(v[3], m[67], mt[67])))));
+    tmp[1] = add(tmp[1], add(mul(v[0], m[68], mt[68]),
+                             add(mul(v[1], m[69], mt[69]), add(mul(v[2], m[70], mt[70]), mul(v[3], m[71], mt[71])))));
+    tmp[2] = add(tmp[2], add(mul(v[0], m[72], mt[72]),
+                             add(mul(v[1], m[73], mt[73]), add(mul(v[2], m[74], mt[74]), mul(v[3], m[75], mt[75])))));
+    tmp[3] = add(tmp[3], add(mul(v[0], m[76], mt[76]),
+                             add(mul(v[1], m[77], mt[77]), add(mul(v[2], m[78], mt[78]), mul(v[3], m[79], mt[79])))));
+    tmp[4] = add(tmp[4], add(mul(v[0], m[80], mt[80]),
+                             add(mul(v[1], m[81], mt[81]), add(mul(v[2], m[82], mt[82]), mul(v[3], m[83], mt[83])))));
+    tmp[5] = add(tmp[5], add(mul(v[0], m[84], mt[84]),
+                             add(mul(v[1], m[85], mt[85]), add(mul(v[2], m[86], mt[86]), mul(v[3], m[87], mt[87])))));
+    tmp[6] = add(tmp[6], add(mul(v[0], m[88], mt[88]),
+                             add(mul(v[1], m[89], mt[89]), add(mul(v[2], m[90], mt[90]), mul(v[3], m[91], mt[91])))));
+    tmp[7] = add(tmp[7], add(mul(v[0], m[92], mt[92]),
+                             add(mul(v[1], m[93], mt[93]), add(mul(v[2], m[94], mt[94]), mul(v[3], m[95], mt[95])))));
 
     v[0] = load2(&psi[I + d2 + d3]);
     v[1] = load2(&psi[I + d0 + d2 + d3]);
     v[2] = load2(&psi[I + d1 + d2 + d3]);
     v[3] = load2(&psi[I + d0 + d1 + d2 + d3]);
 
-    _mm256_storeu2_m128d((double*)&psi[I + d0], (double*)&psi[I], add(tmp[0], add(mul(v[0], m[96], mt[96]), add(mul(v[1], m[97], mt[97]), add(mul(v[2], m[98], mt[98]), mul(v[3], m[99], mt[99]))))));
-    _mm256_storeu2_m128d((double*)&psi[I + d0 + d1], (double*)&psi[I + d1], add(tmp[1], add(mul(v[0], m[100], mt[100]), add(mul(v[1], m[101], mt[101]), add(mul(v[2], m[102], mt[102]), mul(v[3], m[103], mt[103]))))));
-    _mm256_storeu2_m128d((double*)&psi[I + d0 + d2], (double*)&psi[I + d2], add(tmp[2], add(mul(v[0], m[104], mt[104]), add(mul(v[1], m[105], mt[105]), add(mul(v[2], m[106], mt[106]), mul(v[3], m[107], mt[107]))))));
-    _mm256_storeu2_m128d((double*)&psi[I + d0 + d1 + d2], (double*)&psi[I + d1 + d2], add(tmp[3], add(mul(v[0], m[108], mt[108]), add(mul(v[1], m[109], mt[109]), add(mul(v[2], m[110], mt[110]), mul(v[3], m[111], mt[111]))))));
-    _mm256_storeu2_m128d((double*)&psi[I + d0 + d3], (double*)&psi[I + d3], add(tmp[4], add(mul(v[0], m[112], mt[112]), add(mul(v[1], m[113], mt[113]), add(mul(v[2], m[114], mt[114]), mul(v[3], m[115], mt[115]))))));
-    _mm256_storeu2_m128d((double*)&psi[I + d0 + d1 + d3], (double*)&psi[I + d1 + d3], add(tmp[5], add(mul(v[0], m[116], mt[116]), add(mul(v[1], m[117], mt[117]), add(mul(v[2], m[118], mt[118]), mul(v[3], m[119], mt[119]))))));
-    _mm256_storeu2_m128d((double*)&psi[I + d0 + d2 + d3], (double*)&psi[I + d2 + d3], add(tmp[6], add(mul(v[0], m[120], mt[120]), add(mul(v[1], m[121], mt[121]), add(mul(v[2], m[122], mt[122]), mul(v[3], m[123], mt[123]))))));
-    _mm256_storeu2_m128d((double*)&psi[I + d0 + d1 + d2 + d3], (double*)&psi[I + d1 + d2 + d3], add(tmp[7], add(mul(v[0], m[124], mt[124]), add(mul(v[1], m[125], mt[125]), add(mul(v[2], m[126], mt[126]), mul(v[3], m[127], mt[127]))))));
-
+    _mm256_storeu2_m128d(
+        (double*) &psi[I + d0], (double*) &psi[I],
+        add(tmp[0], add(mul(v[0], m[96], mt[96]),
+                        add(mul(v[1], m[97], mt[97]), add(mul(v[2], m[98], mt[98]), mul(v[3], m[99], mt[99]))))));
+    _mm256_storeu2_m128d(
+        (double*) &psi[I + d0 + d1], (double*) &psi[I + d1],
+        add(tmp[1], add(mul(v[0], m[100], mt[100]),
+                        add(mul(v[1], m[101], mt[101]), add(mul(v[2], m[102], mt[102]), mul(v[3], m[103], mt[103]))))));
+    _mm256_storeu2_m128d(
+        (double*) &psi[I + d0 + d2], (double*) &psi[I + d2],
+        add(tmp[2], add(mul(v[0], m[104], mt[104]),
+                        add(mul(v[1], m[105], mt[105]), add(mul(v[2], m[106], mt[106]), mul(v[3], m[107], mt[107]))))));
+    _mm256_storeu2_m128d(
+        (double*) &psi[I + d0 + d1 + d2], (double*) &psi[I + d1 + d2],
+        add(tmp[3], add(mul(v[0], m[108], mt[108]),
+                        add(mul(v[1], m[109], mt[109]), add(mul(v[2], m[110], mt[110]), mul(v[3], m[111], mt[111]))))));
+    _mm256_storeu2_m128d(
+        (double*) &psi[I + d0 + d3], (double*) &psi[I + d3],
+        add(tmp[4], add(mul(v[0], m[112], mt[112]),
+                        add(mul(v[1], m[113], mt[113]), add(mul(v[2], m[114], mt[114]), mul(v[3], m[115], mt[115]))))));
+    _mm256_storeu2_m128d(
+        (double*) &psi[I + d0 + d1 + d3], (double*) &psi[I + d1 + d3],
+        add(tmp[5], add(mul(v[0], m[116], mt[116]),
+                        add(mul(v[1], m[117], mt[117]), add(mul(v[2], m[118], mt[118]), mul(v[3], m[119], mt[119]))))));
+    _mm256_storeu2_m128d(
+        (double*) &psi[I + d0 + d2 + d3], (double*) &psi[I + d2 + d3],
+        add(tmp[6], add(mul(v[0], m[120], mt[120]),
+                        add(mul(v[1], m[121], mt[121]), add(mul(v[2], m[122], mt[122]), mul(v[3], m[123], mt[123]))))));
+    _mm256_storeu2_m128d(
+        (double*) &psi[I + d0 + d1 + d2 + d3], (double*) &psi[I + d1 + d2 + d3],
+        add(tmp[7], add(mul(v[0], m[124], mt[124]),
+                        add(mul(v[1], m[125], mt[125]), add(mul(v[2], m[126], mt[126]), mul(v[3], m[127], mt[127]))))));
 }
 
 // bit indices id[.] are given from high to low (e.g. control first for CNOT)
 template <class V, class M>
-void kernel(V &psi, unsigned id3, unsigned id2, unsigned id1, unsigned id0, M const& m, std::size_t ctrlmask)
-{
+void kernel(V& psi, unsigned id3, unsigned id2, unsigned id1, unsigned id0, M const& m, std::size_t ctrlmask) {
     std::size_t n = psi.size();
     std::size_t d0 = 1UL << id0;
     std::size_t d1 = 1UL << id1;
     std::size_t d2 = 1UL << id2;
     std::size_t d3 = 1UL << id3;
 
-    __m256d mm[] = {load(&m[0][0], &m[1][0]), load(&m[0][1], &m[1][1]), load(&m[0][2], &m[1][2]), load(&m[0][3], &m[1][3]), load(&m[2][0], &m[3][0]), load(&m[2][1], &m[3][1]), load(&m[2][2], &m[3][2]), load(&m[2][3], &m[3][3]), load(&m[4][0], &m[5][0]), load(&m[4][1], &m[5][1]), load(&m[4][2], &m[5][2]), load(&m[4][3], &m[5][3]), load(&m[6][0], &m[7][0]), load(&m[6][1], &m[7][1]), load(&m[6][2], &m[7][2]), load(&m[6][3], &m[7][3]), load(&m[8][0], &m[9][0]), load(&m[8][1], &m[9][1]), load(&m[8][2], &m[9][2]), load(&m[8][3], &m[9][3]), load(&m[10][0], &m[11][0]), load(&m[10][1], &m[11][1]), load(&m[10][2], &m[11][2]), load(&m[10][3], &m[11][3]), load(&m[12][0], &m[13][0]), load(&m[12][1], &m[13][1]), load(&m[12][2], &m[13][2]), load(&m[12][3], &m[13][3]), load(&m[14][0], &m[15][0]), load(&m[14][1], &m[15][1]), load(&m[14][2], &m[15][2]), load(&m[14][3], &m[15][3]), load(&m[0][4], &m[1][4]), load(&m[0][5], &m[1][5]), load(&m[0][6], &m[1][6]), load(&m[0][7], &m[1][7]), load(&m[2][4], &m[3][4]), load(&m[2][5], &m[3][5]), load(&m[2][6], &m[3][6]), load(&m[2][7], &m[3][7]), load(&m[4][4], &m[5][4]), load(&m[4][5], &m[5][5]), load(&m[4][6], &m[5][6]), load(&m[4][7], &m[5][7]), load(&m[6][4], &m[7][4]), load(&m[6][5], &m[7][5]), load(&m[6][6], &m[7][6]), load(&m[6][7], &m[7][7]), load(&m[8][4], &m[9][4]), load(&m[8][5], &m[9][5]), load(&m[8][6], &m[9][6]), load(&m[8][7], &m[9][7]), load(&m[10][4], &m[11][4]), load(&m[10][5], &m[11][5]), load(&m[10][6], &m[11][6]), load(&m[10][7], &m[11][7]), load(&m[12][4], &m[13][4]), load(&m[12][5], &m[13][5]), load(&m[12][6], &m[13][6]), load(&m[12][7], &m[13][7]), load(&m[14][4], &m[15][4]), load(&m[14][5], &m[15][5]), load(&m[14][6], &m[15][6]), load(&m[14][7], &m[15][7]), load(&m[0][8], &m[1][8]), load(&m[0][9], &m[1][9]), load(&m[0][10], &m[1][10]), load(&m[0][11], &m[1][11]), load(&m[2][8], &m[3][8]), load(&m[2][9], &m[3][9]), load(&m[2][10], &m[3][10]), load(&m[2][11], &m[3][11]), load(&m[4][8], &m[5][8]), load(&m[4][9], &m[5][9]), load(&m[4][10], &m[5][10]), load(&m[4][11], &m[5][11]), load(&m[6][8], &m[7][8]), load(&m[6][9], &m[7][9]), load(&m[6][10], &m[7][10]), load(&m[6][11], &m[7][11]), load(&m[8][8], &m[9][8]), load(&m[8][9], &m[9][9]), load(&m[8][10], &m[9][10]), load(&m[8][11], &m[9][11]), load(&m[10][8], &m[11][8]), load(&m[10][9], &m[11][9]), load(&m[10][10], &m[11][10]), load(&m[10][11], &m[11][11]), load(&m[12][8], &m[13][8]), load(&m[12][9], &m[13][9]), load(&m[12][10], &m[13][10]), load(&m[12][11], &m[13][11]), load(&m[14][8], &m[15][8]), load(&m[14][9], &m[15][9]), load(&m[14][10], &m[15][10]), load(&m[14][11], &m[15][11]), load(&m[0][12], &m[1][12]), load(&m[0][13], &m[1][13]), load(&m[0][14], &m[1][14]), load(&m[0][15], &m[1][15]), load(&m[2][12], &m[3][12]), load(&m[2][13], &m[3][13]), load(&m[2][14], &m[3][14]), load(&m[2][15], &m[3][15]), load(&m[4][12], &m[5][12]), load(&m[4][13], &m[5][13]), load(&m[4][14], &m[5][14]), load(&m[4][15], &m[5][15]), load(&m[6][12], &m[7][12]), load(&m[6][13], &m[7][13]), load(&m[6][14], &m[7][14]), load(&m[6][15], &m[7][15]), load(&m[8][12], &m[9][12]), load(&m[8][13], &m[9][13]), load(&m[8][14], &m[9][14]), load(&m[8][15], &m[9][15]), load(&m[10][12], &m[11][12]), load(&m[10][13], &m[11][13]), load(&m[10][14], &m[11][14]), load(&m[10][15], &m[11][15]), load(&m[12][12], &m[13][12]), load(&m[12][13], &m[13][13]), load(&m[12][14], &m[13][14]), load(&m[12][15], &m[13][15]), load(&m[14][12], &m[15][12]), load(&m[14][13], &m[15][13]), load(&m[14][14], &m[15][14]), load(&m[14][15], &m[15][15])};
+    __m256d mm[] = {load(&m[0][0], &m[1][0]),     load(&m[0][1], &m[1][1]),     load(&m[0][2], &m[1][2]),
+                    load(&m[0][3], &m[1][3]),     load(&m[2][0], &m[3][0]),     load(&m[2][1], &m[3][1]),
+                    load(&m[2][2], &m[3][2]),     load(&m[2][3], &m[3][3]),     load(&m[4][0], &m[5][0]),
+                    load(&m[4][1], &m[5][1]),     load(&m[4][2], &m[5][2]),     load(&m[4][3], &m[5][3]),
+                    load(&m[6][0], &m[7][0]),     load(&m[6][1], &m[7][1]),     load(&m[6][2], &m[7][2]),
+                    load(&m[6][3], &m[7][3]),     load(&m[8][0], &m[9][0]),     load(&m[8][1], &m[9][1]),
+                    load(&m[8][2], &m[9][2]),     load(&m[8][3], &m[9][3]),     load(&m[10][0], &m[11][0]),
+                    load(&m[10][1], &m[11][1]),   load(&m[10][2], &m[11][2]),   load(&m[10][3], &m[11][3]),
+                    load(&m[12][0], &m[13][0]),   load(&m[12][1], &m[13][1]),   load(&m[12][2], &m[13][2]),
+                    load(&m[12][3], &m[13][3]),   load(&m[14][0], &m[15][0]),   load(&m[14][1], &m[15][1]),
+                    load(&m[14][2], &m[15][2]),   load(&m[14][3], &m[15][3]),   load(&m[0][4], &m[1][4]),
+                    load(&m[0][5], &m[1][5]),     load(&m[0][6], &m[1][6]),     load(&m[0][7], &m[1][7]),
+                    load(&m[2][4], &m[3][4]),     load(&m[2][5], &m[3][5]),     load(&m[2][6], &m[3][6]),
+                    load(&m[2][7], &m[3][7]),     load(&m[4][4], &m[5][4]),     load(&m[4][5], &m[5][5]),
+                    load(&m[4][6], &m[5][6]),     load(&m[4][7], &m[5][7]),     load(&m[6][4], &m[7][4]),
+                    load(&m[6][5], &m[7][5]),     load(&m[6][6], &m[7][6]),     load(&m[6][7], &m[7][7]),
+                    load(&m[8][4], &m[9][4]),     load(&m[8][5], &m[9][5]),     load(&m[8][6], &m[9][6]),
+                    load(&m[8][7], &m[9][7]),     load(&m[10][4], &m[11][4]),   load(&m[10][5], &m[11][5]),
+                    load(&m[10][6], &m[11][6]),   load(&m[10][7], &m[11][7]),   load(&m[12][4], &m[13][4]),
+                    load(&m[12][5], &m[13][5]),   load(&m[12][6], &m[13][6]),   load(&m[12][7], &m[13][7]),
+                    load(&m[14][4], &m[15][4]),   load(&m[14][5], &m[15][5]),   load(&m[14][6], &m[15][6]),
+                    load(&m[14][7], &m[15][7]),   load(&m[0][8], &m[1][8]),     load(&m[0][9], &m[1][9]),
+                    load(&m[0][10], &m[1][10]),   load(&m[0][11], &m[1][11]),   load(&m[2][8], &m[3][8]),
+                    load(&m[2][9], &m[3][9]),     load(&m[2][10], &m[3][10]),   load(&m[2][11], &m[3][11]),
+                    load(&m[4][8], &m[5][8]),     load(&m[4][9], &m[5][9]),     load(&m[4][10], &m[5][10]),
+                    load(&m[4][11], &m[5][11]),   load(&m[6][8], &m[7][8]),     load(&m[6][9], &m[7][9]),
+                    load(&m[6][10], &m[7][10]),   load(&m[6][11], &m[7][11]),   load(&m[8][8], &m[9][8]),
+                    load(&m[8][9], &m[9][9]),     load(&m[8][10], &m[9][10]),   load(&m[8][11], &m[9][11]),
+                    load(&m[10][8], &m[11][8]),   load(&m[10][9], &m[11][9]),   load(&m[10][10], &m[11][10]),
+                    load(&m[10][11], &m[11][11]), load(&m[12][8], &m[13][8]),   load(&m[12][9], &m[13][9]),
+                    load(&m[12][10], &m[13][10]), load(&m[12][11], &m[13][11]), load(&m[14][8], &m[15][8]),
+                    load(&m[14][9], &m[15][9]),   load(&m[14][10], &m[15][10]), load(&m[14][11], &m[15][11]),
+                    load(&m[0][12], &m[1][12]),   load(&m[0][13], &m[1][13]),   load(&m[0][14], &m[1][14]),
+                    load(&m[0][15], &m[1][15]),   load(&m[2][12], &m[3][12]),   load(&m[2][13], &m[3][13]),
+                    load(&m[2][14], &m[3][14]),   load(&m[2][15], &m[3][15]),   load(&m[4][12], &m[5][12]),
+                    load(&m[4][13], &m[5][13]),   load(&m[4][14], &m[5][14]),   load(&m[4][15], &m[5][15]),
+                    load(&m[6][12], &m[7][12]),   load(&m[6][13], &m[7][13]),   load(&m[6][14], &m[7][14]),
+                    load(&m[6][15], &m[7][15]),   load(&m[8][12], &m[9][12]),   load(&m[8][13], &m[9][13]),
+                    load(&m[8][14], &m[9][14]),   load(&m[8][15], &m[9][15]),   load(&m[10][12], &m[11][12]),
+                    load(&m[10][13], &m[11][13]), load(&m[10][14], &m[11][14]), load(&m[10][15], &m[11][15]),
+                    load(&m[12][12], &m[13][12]), load(&m[12][13], &m[13][13]), load(&m[12][14], &m[13][14]),
+                    load(&m[12][15], &m[13][15]), load(&m[14][12], &m[15][12]), load(&m[14][13], &m[15][13]),
+                    load(&m[14][14], &m[15][14]), load(&m[14][15], &m[15][15])};
     __m256d mmt[128];
 
     __m256d neg = _mm256_setr_pd(1.0, -1.0, 1.0, -1.0);
-    for (unsigned i = 0; i < 128; ++i){
+    for (unsigned i = 0; i < 128; ++i) {
         auto badc = _mm256_permute_pd(mm[i], 5);
         mmt[i] = _mm256_mul_pd(badc, neg);
     }
 
-    std::size_t dsorted[] = {d0 , d1, d2, d3};
+    std::size_t dsorted[] = {d0, d1, d2, d3};
     std::sort(dsorted, dsorted + 4, std::greater<std::size_t>());
 
-    if (ctrlmask == 0){
-        #pragma omp for collapse(LOOP_COLLAPSE4) schedule(static)
-        for (std::size_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]){
-            for (std::size_t i1 = 0; i1 < dsorted[0]; i1 += 2 * dsorted[1]){
-                for (std::size_t i2 = 0; i2 < dsorted[1]; i2 += 2 * dsorted[2]){
-                    for (std::size_t i3 = 0; i3 < dsorted[2]; i3 += 2 * dsorted[3]){
-                        for (std::size_t i4 = 0; i4 < dsorted[3]; ++i4){
+    if (ctrlmask == 0) {
+#pragma omp for collapse(LOOP_COLLAPSE4) schedule(static)
+        for (omp::idx_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]) {
+            for (omp::idx_t i1 = 0; i1 < dsorted[0]; i1 += 2 * dsorted[1]) {
+                for (omp::idx_t i2 = 0; i2 < dsorted[1]; i2 += 2 * dsorted[2]) {
+                    for (omp::idx_t i3 = 0; i3 < dsorted[2]; i3 += 2 * dsorted[3]) {
+                        for (omp::idx_t i4 = 0; i4 < dsorted[3]; ++i4) {
                             kernel_core(psi, i0 + i1 + i2 + i3 + i4, d0, d1, d2, d3, mm, mmt);
                         }
                     }
                 }
             }
         }
-    }
-    else{
-        #pragma omp for collapse(LOOP_COLLAPSE4) schedule(static)
-        for (std::size_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]){
-            for (std::size_t i1 = 0; i1 < dsorted[0]; i1 += 2 * dsorted[1]){
-                for (std::size_t i2 = 0; i2 < dsorted[1]; i2 += 2 * dsorted[2]){
-                    for (std::size_t i3 = 0; i3 < dsorted[2]; i3 += 2 * dsorted[3]){
-                        for (std::size_t i4 = 0; i4 < dsorted[3]; ++i4){
-                            if (((i0 + i1 + i2 + i3 + i4)&ctrlmask) == ctrlmask)
+    } else {
+#pragma omp for collapse(LOOP_COLLAPSE4) schedule(static)
+        for (omp::idx_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]) {
+            for (omp::idx_t i1 = 0; i1 < dsorted[0]; i1 += 2 * dsorted[1]) {
+                for (omp::idx_t i2 = 0; i2 < dsorted[1]; i2 += 2 * dsorted[2]) {
+                    for (omp::idx_t i3 = 0; i3 < dsorted[2]; i3 += 2 * dsorted[3]) {
+                        for (omp::idx_t i4 = 0; i4 < dsorted[3]; ++i4) {
+                            if (((i0 + i1 + i2 + i3 + i4) & ctrlmask) == ctrlmask)
                                 kernel_core(psi, i0 + i1 + i2 + i3 + i4, d0, d1, d2, d3, mm, mmt);
                         }
                     }
diff -Npur projectq-orig/projectq/backends/_sim/_cppkernels/intrin/kernel5.hpp projectq-new/projectq/backends/_sim/_cppkernels/intrin/kernel5.hpp
--- projectq-orig/projectq/backends/_sim/_cppkernels/intrin/kernel5.hpp	2022-04-27 11:49:17.000000000 +0200
+++ projectq-new/projectq/backends/_sim/_cppkernels/intrin/kernel5.hpp	2022-06-17 12:37:17.816198916 +0200
@@ -13,8 +13,8 @@
 // limitations under the License.
 
 template <class V, class M>
-inline void kernel_core(V &psi, std::size_t I, std::size_t d0, std::size_t d1, std::size_t d2, std::size_t d3, std::size_t d4, M const& m, M const& mt)
-{
+inline void kernel_core(V& psi, std::size_t I, std::size_t d0, std::size_t d1, std::size_t d2, std::size_t d3,
+                        std::size_t d4, M const& m, M const& mt) {
     __m256d v[4];
 
     v[0] = load2(&psi[I]);
@@ -24,183 +24,429 @@ inline void kernel_core(V &psi, std::siz
 
     __m256d tmp[16];
 
-    tmp[0] = add(mul(v[0], m[0], mt[0]), add(mul(v[1], m[1], mt[1]), add(mul(v[2], m[2], mt[2]), mul(v[3], m[3], mt[3]))));
-    tmp[1] = add(mul(v[0], m[4], mt[4]), add(mul(v[1], m[5], mt[5]), add(mul(v[2], m[6], mt[6]), mul(v[3], m[7], mt[7]))));
-    tmp[2] = add(mul(v[0], m[8], mt[8]), add(mul(v[1], m[9], mt[9]), add(mul(v[2], m[10], mt[10]), mul(v[3], m[11], mt[11]))));
-    tmp[3] = add(mul(v[0], m[12], mt[12]), add(mul(v[1], m[13], mt[13]), add(mul(v[2], m[14], mt[14]), mul(v[3], m[15], mt[15]))));
-    tmp[4] = add(mul(v[0], m[16], mt[16]), add(mul(v[1], m[17], mt[17]), add(mul(v[2], m[18], mt[18]), mul(v[3], m[19], mt[19]))));
-    tmp[5] = add(mul(v[0], m[20], mt[20]), add(mul(v[1], m[21], mt[21]), add(mul(v[2], m[22], mt[22]), mul(v[3], m[23], mt[23]))));
-    tmp[6] = add(mul(v[0], m[24], mt[24]), add(mul(v[1], m[25], mt[25]), add(mul(v[2], m[26], mt[26]), mul(v[3], m[27], mt[27]))));
-    tmp[7] = add(mul(v[0], m[28], mt[28]), add(mul(v[1], m[29], mt[29]), add(mul(v[2], m[30], mt[30]), mul(v[3], m[31], mt[31]))));
-    tmp[8] = add(mul(v[0], m[32], mt[32]), add(mul(v[1], m[33], mt[33]), add(mul(v[2], m[34], mt[34]), mul(v[3], m[35], mt[35]))));
-    tmp[9] = add(mul(v[0], m[36], mt[36]), add(mul(v[1], m[37], mt[37]), add(mul(v[2], m[38], mt[38]), mul(v[3], m[39], mt[39]))));
-    tmp[10] = add(mul(v[0], m[40], mt[40]), add(mul(v[1], m[41], mt[41]), add(mul(v[2], m[42], mt[42]), mul(v[3], m[43], mt[43]))));
-    tmp[11] = add(mul(v[0], m[44], mt[44]), add(mul(v[1], m[45], mt[45]), add(mul(v[2], m[46], mt[46]), mul(v[3], m[47], mt[47]))));
-    tmp[12] = add(mul(v[0], m[48], mt[48]), add(mul(v[1], m[49], mt[49]), add(mul(v[2], m[50], mt[50]), mul(v[3], m[51], mt[51]))));
-    tmp[13] = add(mul(v[0], m[52], mt[52]), add(mul(v[1], m[53], mt[53]), add(mul(v[2], m[54], mt[54]), mul(v[3], m[55], mt[55]))));
-    tmp[14] = add(mul(v[0], m[56], mt[56]), add(mul(v[1], m[57], mt[57]), add(mul(v[2], m[58], mt[58]), mul(v[3], m[59], mt[59]))));
-    tmp[15] = add(mul(v[0], m[60], mt[60]), add(mul(v[1], m[61], mt[61]), add(mul(v[2], m[62], mt[62]), mul(v[3], m[63], mt[63]))));
+    tmp[0] = add(mul(v[0], m[0], mt[0]),
+                 add(mul(v[1], m[1], mt[1]), add(mul(v[2], m[2], mt[2]), mul(v[3], m[3], mt[3]))));
+    tmp[1] = add(mul(v[0], m[4], mt[4]),
+                 add(mul(v[1], m[5], mt[5]), add(mul(v[2], m[6], mt[6]), mul(v[3], m[7], mt[7]))));
+    tmp[2] = add(mul(v[0], m[8], mt[8]),
+                 add(mul(v[1], m[9], mt[9]), add(mul(v[2], m[10], mt[10]), mul(v[3], m[11], mt[11]))));
+    tmp[3] = add(mul(v[0], m[12], mt[12]),
+                 add(mul(v[1], m[13], mt[13]), add(mul(v[2], m[14], mt[14]), mul(v[3], m[15], mt[15]))));
+    tmp[4] = add(mul(v[0], m[16], mt[16]),
+                 add(mul(v[1], m[17], mt[17]), add(mul(v[2], m[18], mt[18]), mul(v[3], m[19], mt[19]))));
+    tmp[5] = add(mul(v[0], m[20], mt[20]),
+                 add(mul(v[1], m[21], mt[21]), add(mul(v[2], m[22], mt[22]), mul(v[3], m[23], mt[23]))));
+    tmp[6] = add(mul(v[0], m[24], mt[24]),
+                 add(mul(v[1], m[25], mt[25]), add(mul(v[2], m[26], mt[26]), mul(v[3], m[27], mt[27]))));
+    tmp[7] = add(mul(v[0], m[28], mt[28]),
+                 add(mul(v[1], m[29], mt[29]), add(mul(v[2], m[30], mt[30]), mul(v[3], m[31], mt[31]))));
+    tmp[8] = add(mul(v[0], m[32], mt[32]),
+                 add(mul(v[1], m[33], mt[33]), add(mul(v[2], m[34], mt[34]), mul(v[3], m[35], mt[35]))));
+    tmp[9] = add(mul(v[0], m[36], mt[36]),
+                 add(mul(v[1], m[37], mt[37]), add(mul(v[2], m[38], mt[38]), mul(v[3], m[39], mt[39]))));
+    tmp[10] = add(mul(v[0], m[40], mt[40]),
+                  add(mul(v[1], m[41], mt[41]), add(mul(v[2], m[42], mt[42]), mul(v[3], m[43], mt[43]))));
+    tmp[11] = add(mul(v[0], m[44], mt[44]),
+                  add(mul(v[1], m[45], mt[45]), add(mul(v[2], m[46], mt[46]), mul(v[3], m[47], mt[47]))));
+    tmp[12] = add(mul(v[0], m[48], mt[48]),
+                  add(mul(v[1], m[49], mt[49]), add(mul(v[2], m[50], mt[50]), mul(v[3], m[51], mt[51]))));
+    tmp[13] = add(mul(v[0], m[52], mt[52]),
+                  add(mul(v[1], m[53], mt[53]), add(mul(v[2], m[54], mt[54]), mul(v[3], m[55], mt[55]))));
+    tmp[14] = add(mul(v[0], m[56], mt[56]),
+                  add(mul(v[1], m[57], mt[57]), add(mul(v[2], m[58], mt[58]), mul(v[3], m[59], mt[59]))));
+    tmp[15] = add(mul(v[0], m[60], mt[60]),
+                  add(mul(v[1], m[61], mt[61]), add(mul(v[2], m[62], mt[62]), mul(v[3], m[63], mt[63]))));
 
     v[0] = load2(&psi[I + d2]);
     v[1] = load2(&psi[I + d0 + d2]);
     v[2] = load2(&psi[I + d1 + d2]);
     v[3] = load2(&psi[I + d0 + d1 + d2]);
 
-    tmp[0] = add(tmp[0], add(mul(v[0], m[64], mt[64]), add(mul(v[1], m[65], mt[65]), add(mul(v[2], m[66], mt[66]), mul(v[3], m[67], mt[67])))));
-    tmp[1] = add(tmp[1], add(mul(v[0], m[68], mt[68]), add(mul(v[1], m[69], mt[69]), add(mul(v[2], m[70], mt[70]), mul(v[3], m[71], mt[71])))));
-    tmp[2] = add(tmp[2], add(mul(v[0], m[72], mt[72]), add(mul(v[1], m[73], mt[73]), add(mul(v[2], m[74], mt[74]), mul(v[3], m[75], mt[75])))));
-    tmp[3] = add(tmp[3], add(mul(v[0], m[76], mt[76]), add(mul(v[1], m[77], mt[77]), add(mul(v[2], m[78], mt[78]), mul(v[3], m[79], mt[79])))));
-    tmp[4] = add(tmp[4], add(mul(v[0], m[80], mt[80]), add(mul(v[1], m[81], mt[81]), add(mul(v[2], m[82], mt[82]), mul(v[3], m[83], mt[83])))));
-    tmp[5] = add(tmp[5], add(mul(v[0], m[84], mt[84]), add(mul(v[1], m[85], mt[85]), add(mul(v[2], m[86], mt[86]), mul(v[3], m[87], mt[87])))));
-    tmp[6] = add(tmp[6], add(mul(v[0], m[88], mt[88]), add(mul(v[1], m[89], mt[89]), add(mul(v[2], m[90], mt[90]), mul(v[3], m[91], mt[91])))));
-    tmp[7] = add(tmp[7], add(mul(v[0], m[92], mt[92]), add(mul(v[1], m[93], mt[93]), add(mul(v[2], m[94], mt[94]), mul(v[3], m[95], mt[95])))));
-    tmp[8] = add(tmp[8], add(mul(v[0], m[96], mt[96]), add(mul(v[1], m[97], mt[97]), add(mul(v[2], m[98], mt[98]), mul(v[3], m[99], mt[99])))));
-    tmp[9] = add(tmp[9], add(mul(v[0], m[100], mt[100]), add(mul(v[1], m[101], mt[101]), add(mul(v[2], m[102], mt[102]), mul(v[3], m[103], mt[103])))));
-    tmp[10] = add(tmp[10], add(mul(v[0], m[104], mt[104]), add(mul(v[1], m[105], mt[105]), add(mul(v[2], m[106], mt[106]), mul(v[3], m[107], mt[107])))));
-    tmp[11] = add(tmp[11], add(mul(v[0], m[108], mt[108]), add(mul(v[1], m[109], mt[109]), add(mul(v[2], m[110], mt[110]), mul(v[3], m[111], mt[111])))));
-    tmp[12] = add(tmp[12], add(mul(v[0], m[112], mt[112]), add(mul(v[1], m[113], mt[113]), add(mul(v[2], m[114], mt[114]), mul(v[3], m[115], mt[115])))));
-    tmp[13] = add(tmp[13], add(mul(v[0], m[116], mt[116]), add(mul(v[1], m[117], mt[117]), add(mul(v[2], m[118], mt[118]), mul(v[3], m[119], mt[119])))));
-    tmp[14] = add(tmp[14], add(mul(v[0], m[120], mt[120]), add(mul(v[1], m[121], mt[121]), add(mul(v[2], m[122], mt[122]), mul(v[3], m[123], mt[123])))));
-    tmp[15] = add(tmp[15], add(mul(v[0], m[124], mt[124]), add(mul(v[1], m[125], mt[125]), add(mul(v[2], m[126], mt[126]), mul(v[3], m[127], mt[127])))));
+    tmp[0] = add(tmp[0], add(mul(v[0], m[64], mt[64]),
+                             add(mul(v[1], m[65], mt[65]), add(mul(v[2], m[66], mt[66]), mul(v[3], m[67], mt[67])))));
+    tmp[1] = add(tmp[1], add(mul(v[0], m[68], mt[68]),
+                             add(mul(v[1], m[69], mt[69]), add(mul(v[2], m[70], mt[70]), mul(v[3], m[71], mt[71])))));
+    tmp[2] = add(tmp[2], add(mul(v[0], m[72], mt[72]),
+                             add(mul(v[1], m[73], mt[73]), add(mul(v[2], m[74], mt[74]), mul(v[3], m[75], mt[75])))));
+    tmp[3] = add(tmp[3], add(mul(v[0], m[76], mt[76]),
+                             add(mul(v[1], m[77], mt[77]), add(mul(v[2], m[78], mt[78]), mul(v[3], m[79], mt[79])))));
+    tmp[4] = add(tmp[4], add(mul(v[0], m[80], mt[80]),
+                             add(mul(v[1], m[81], mt[81]), add(mul(v[2], m[82], mt[82]), mul(v[3], m[83], mt[83])))));
+    tmp[5] = add(tmp[5], add(mul(v[0], m[84], mt[84]),
+                             add(mul(v[1], m[85], mt[85]), add(mul(v[2], m[86], mt[86]), mul(v[3], m[87], mt[87])))));
+    tmp[6] = add(tmp[6], add(mul(v[0], m[88], mt[88]),
+                             add(mul(v[1], m[89], mt[89]), add(mul(v[2], m[90], mt[90]), mul(v[3], m[91], mt[91])))));
+    tmp[7] = add(tmp[7], add(mul(v[0], m[92], mt[92]),
+                             add(mul(v[1], m[93], mt[93]), add(mul(v[2], m[94], mt[94]), mul(v[3], m[95], mt[95])))));
+    tmp[8] = add(tmp[8], add(mul(v[0], m[96], mt[96]),
+                             add(mul(v[1], m[97], mt[97]), add(mul(v[2], m[98], mt[98]), mul(v[3], m[99], mt[99])))));
+    tmp[9] = add(tmp[9],
+                 add(mul(v[0], m[100], mt[100]),
+                     add(mul(v[1], m[101], mt[101]), add(mul(v[2], m[102], mt[102]), mul(v[3], m[103], mt[103])))));
+    tmp[10] = add(tmp[10],
+                  add(mul(v[0], m[104], mt[104]),
+                      add(mul(v[1], m[105], mt[105]), add(mul(v[2], m[106], mt[106]), mul(v[3], m[107], mt[107])))));
+    tmp[11] = add(tmp[11],
+                  add(mul(v[0], m[108], mt[108]),
+                      add(mul(v[1], m[109], mt[109]), add(mul(v[2], m[110], mt[110]), mul(v[3], m[111], mt[111])))));
+    tmp[12] = add(tmp[12],
+                  add(mul(v[0], m[112], mt[112]),
+                      add(mul(v[1], m[113], mt[113]), add(mul(v[2], m[114], mt[114]), mul(v[3], m[115], mt[115])))));
+    tmp[13] = add(tmp[13],
+                  add(mul(v[0], m[116], mt[116]),
+                      add(mul(v[1], m[117], mt[117]), add(mul(v[2], m[118], mt[118]), mul(v[3], m[119], mt[119])))));
+    tmp[14] = add(tmp[14],
+                  add(mul(v[0], m[120], mt[120]),
+                      add(mul(v[1], m[121], mt[121]), add(mul(v[2], m[122], mt[122]), mul(v[3], m[123], mt[123])))));
+    tmp[15] = add(tmp[15],
+                  add(mul(v[0], m[124], mt[124]),
+                      add(mul(v[1], m[125], mt[125]), add(mul(v[2], m[126], mt[126]), mul(v[3], m[127], mt[127])))));
 
     v[0] = load2(&psi[I + d3]);
     v[1] = load2(&psi[I + d0 + d3]);
     v[2] = load2(&psi[I + d1 + d3]);
     v[3] = load2(&psi[I + d0 + d1 + d3]);
 
-    tmp[0] = add(tmp[0], add(mul(v[0], m[128], mt[128]), add(mul(v[1], m[129], mt[129]), add(mul(v[2], m[130], mt[130]), mul(v[3], m[131], mt[131])))));
-    tmp[1] = add(tmp[1], add(mul(v[0], m[132], mt[132]), add(mul(v[1], m[133], mt[133]), add(mul(v[2], m[134], mt[134]), mul(v[3], m[135], mt[135])))));
-    tmp[2] = add(tmp[2], add(mul(v[0], m[136], mt[136]), add(mul(v[1], m[137], mt[137]), add(mul(v[2], m[138], mt[138]), mul(v[3], m[139], mt[139])))));
-    tmp[3] = add(tmp[3], add(mul(v[0], m[140], mt[140]), add(mul(v[1], m[141], mt[141]), add(mul(v[2], m[142], mt[142]), mul(v[3], m[143], mt[143])))));
-    tmp[4] = add(tmp[4], add(mul(v[0], m[144], mt[144]), add(mul(v[1], m[145], mt[145]), add(mul(v[2], m[146], mt[146]), mul(v[3], m[147], mt[147])))));
-    tmp[5] = add(tmp[5], add(mul(v[0], m[148], mt[148]), add(mul(v[1], m[149], mt[149]), add(mul(v[2], m[150], mt[150]), mul(v[3], m[151], mt[151])))));
-    tmp[6] = add(tmp[6], add(mul(v[0], m[152], mt[152]), add(mul(v[1], m[153], mt[153]), add(mul(v[2], m[154], mt[154]), mul(v[3], m[155], mt[155])))));
-    tmp[7] = add(tmp[7], add(mul(v[0], m[156], mt[156]), add(mul(v[1], m[157], mt[157]), add(mul(v[2], m[158], mt[158]), mul(v[3], m[159], mt[159])))));
-    tmp[8] = add(tmp[8], add(mul(v[0], m[160], mt[160]), add(mul(v[1], m[161], mt[161]), add(mul(v[2], m[162], mt[162]), mul(v[3], m[163], mt[163])))));
-    tmp[9] = add(tmp[9], add(mul(v[0], m[164], mt[164]), add(mul(v[1], m[165], mt[165]), add(mul(v[2], m[166], mt[166]), mul(v[3], m[167], mt[167])))));
-    tmp[10] = add(tmp[10], add(mul(v[0], m[168], mt[168]), add(mul(v[1], m[169], mt[169]), add(mul(v[2], m[170], mt[170]), mul(v[3], m[171], mt[171])))));
-    tmp[11] = add(tmp[11], add(mul(v[0], m[172], mt[172]), add(mul(v[1], m[173], mt[173]), add(mul(v[2], m[174], mt[174]), mul(v[3], m[175], mt[175])))));
-    tmp[12] = add(tmp[12], add(mul(v[0], m[176], mt[176]), add(mul(v[1], m[177], mt[177]), add(mul(v[2], m[178], mt[178]), mul(v[3], m[179], mt[179])))));
-    tmp[13] = add(tmp[13], add(mul(v[0], m[180], mt[180]), add(mul(v[1], m[181], mt[181]), add(mul(v[2], m[182], mt[182]), mul(v[3], m[183], mt[183])))));
-    tmp[14] = add(tmp[14], add(mul(v[0], m[184], mt[184]), add(mul(v[1], m[185], mt[185]), add(mul(v[2], m[186], mt[186]), mul(v[3], m[187], mt[187])))));
-    tmp[15] = add(tmp[15], add(mul(v[0], m[188], mt[188]), add(mul(v[1], m[189], mt[189]), add(mul(v[2], m[190], mt[190]), mul(v[3], m[191], mt[191])))));
+    tmp[0] = add(tmp[0],
+                 add(mul(v[0], m[128], mt[128]),
+                     add(mul(v[1], m[129], mt[129]), add(mul(v[2], m[130], mt[130]), mul(v[3], m[131], mt[131])))));
+    tmp[1] = add(tmp[1],
+                 add(mul(v[0], m[132], mt[132]),
+                     add(mul(v[1], m[133], mt[133]), add(mul(v[2], m[134], mt[134]), mul(v[3], m[135], mt[135])))));
+    tmp[2] = add(tmp[2],
+                 add(mul(v[0], m[136], mt[136]),
+                     add(mul(v[1], m[137], mt[137]), add(mul(v[2], m[138], mt[138]), mul(v[3], m[139], mt[139])))));
+    tmp[3] = add(tmp[3],
+                 add(mul(v[0], m[140], mt[140]),
+                     add(mul(v[1], m[141], mt[141]), add(mul(v[2], m[142], mt[142]), mul(v[3], m[143], mt[143])))));
+    tmp[4] = add(tmp[4],
+                 add(mul(v[0], m[144], mt[144]),
+                     add(mul(v[1], m[145], mt[145]), add(mul(v[2], m[146], mt[146]), mul(v[3], m[147], mt[147])))));
+    tmp[5] = add(tmp[5],
+                 add(mul(v[0], m[148], mt[148]),
+                     add(mul(v[1], m[149], mt[149]), add(mul(v[2], m[150], mt[150]), mul(v[3], m[151], mt[151])))));
+    tmp[6] = add(tmp[6],
+                 add(mul(v[0], m[152], mt[152]),
+                     add(mul(v[1], m[153], mt[153]), add(mul(v[2], m[154], mt[154]), mul(v[3], m[155], mt[155])))));
+    tmp[7] = add(tmp[7],
+                 add(mul(v[0], m[156], mt[156]),
+                     add(mul(v[1], m[157], mt[157]), add(mul(v[2], m[158], mt[158]), mul(v[3], m[159], mt[159])))));
+    tmp[8] = add(tmp[8],
+                 add(mul(v[0], m[160], mt[160]),
+                     add(mul(v[1], m[161], mt[161]), add(mul(v[2], m[162], mt[162]), mul(v[3], m[163], mt[163])))));
+    tmp[9] = add(tmp[9],
+                 add(mul(v[0], m[164], mt[164]),
+                     add(mul(v[1], m[165], mt[165]), add(mul(v[2], m[166], mt[166]), mul(v[3], m[167], mt[167])))));
+    tmp[10] = add(tmp[10],
+                  add(mul(v[0], m[168], mt[168]),
+                      add(mul(v[1], m[169], mt[169]), add(mul(v[2], m[170], mt[170]), mul(v[3], m[171], mt[171])))));
+    tmp[11] = add(tmp[11],
+                  add(mul(v[0], m[172], mt[172]),
+                      add(mul(v[1], m[173], mt[173]), add(mul(v[2], m[174], mt[174]), mul(v[3], m[175], mt[175])))));
+    tmp[12] = add(tmp[12],
+                  add(mul(v[0], m[176], mt[176]),
+                      add(mul(v[1], m[177], mt[177]), add(mul(v[2], m[178], mt[178]), mul(v[3], m[179], mt[179])))));
+    tmp[13] = add(tmp[13],
+                  add(mul(v[0], m[180], mt[180]),
+                      add(mul(v[1], m[181], mt[181]), add(mul(v[2], m[182], mt[182]), mul(v[3], m[183], mt[183])))));
+    tmp[14] = add(tmp[14],
+                  add(mul(v[0], m[184], mt[184]),
+                      add(mul(v[1], m[185], mt[185]), add(mul(v[2], m[186], mt[186]), mul(v[3], m[187], mt[187])))));
+    tmp[15] = add(tmp[15],
+                  add(mul(v[0], m[188], mt[188]),
+                      add(mul(v[1], m[189], mt[189]), add(mul(v[2], m[190], mt[190]), mul(v[3], m[191], mt[191])))));
 
     v[0] = load2(&psi[I + d2 + d3]);
     v[1] = load2(&psi[I + d0 + d2 + d3]);
     v[2] = load2(&psi[I + d1 + d2 + d3]);
     v[3] = load2(&psi[I + d0 + d1 + d2 + d3]);
 
-    tmp[0] = add(tmp[0], add(mul(v[0], m[192], mt[192]), add(mul(v[1], m[193], mt[193]), add(mul(v[2], m[194], mt[194]), mul(v[3], m[195], mt[195])))));
-    tmp[1] = add(tmp[1], add(mul(v[0], m[196], mt[196]), add(mul(v[1], m[197], mt[197]), add(mul(v[2], m[198], mt[198]), mul(v[3], m[199], mt[199])))));
-    tmp[2] = add(tmp[2], add(mul(v[0], m[200], mt[200]), add(mul(v[1], m[201], mt[201]), add(mul(v[2], m[202], mt[202]), mul(v[3], m[203], mt[203])))));
-    tmp[3] = add(tmp[3], add(mul(v[0], m[204], mt[204]), add(mul(v[1], m[205], mt[205]), add(mul(v[2], m[206], mt[206]), mul(v[3], m[207], mt[207])))));
-    tmp[4] = add(tmp[4], add(mul(v[0], m[208], mt[208]), add(mul(v[1], m[209], mt[209]), add(mul(v[2], m[210], mt[210]), mul(v[3], m[211], mt[211])))));
-    tmp[5] = add(tmp[5], add(mul(v[0], m[212], mt[212]), add(mul(v[1], m[213], mt[213]), add(mul(v[2], m[214], mt[214]), mul(v[3], m[215], mt[215])))));
-    tmp[6] = add(tmp[6], add(mul(v[0], m[216], mt[216]), add(mul(v[1], m[217], mt[217]), add(mul(v[2], m[218], mt[218]), mul(v[3], m[219], mt[219])))));
-    tmp[7] = add(tmp[7], add(mul(v[0], m[220], mt[220]), add(mul(v[1], m[221], mt[221]), add(mul(v[2], m[222], mt[222]), mul(v[3], m[223], mt[223])))));
-    tmp[8] = add(tmp[8], add(mul(v[0], m[224], mt[224]), add(mul(v[1], m[225], mt[225]), add(mul(v[2], m[226], mt[226]), mul(v[3], m[227], mt[227])))));
-    tmp[9] = add(tmp[9], add(mul(v[0], m[228], mt[228]), add(mul(v[1], m[229], mt[229]), add(mul(v[2], m[230], mt[230]), mul(v[3], m[231], mt[231])))));
-    tmp[10] = add(tmp[10], add(mul(v[0], m[232], mt[232]), add(mul(v[1], m[233], mt[233]), add(mul(v[2], m[234], mt[234]), mul(v[3], m[235], mt[235])))));
-    tmp[11] = add(tmp[11], add(mul(v[0], m[236], mt[236]), add(mul(v[1], m[237], mt[237]), add(mul(v[2], m[238], mt[238]), mul(v[3], m[239], mt[239])))));
-    tmp[12] = add(tmp[12], add(mul(v[0], m[240], mt[240]), add(mul(v[1], m[241], mt[241]), add(mul(v[2], m[242], mt[242]), mul(v[3], m[243], mt[243])))));
-    tmp[13] = add(tmp[13], add(mul(v[0], m[244], mt[244]), add(mul(v[1], m[245], mt[245]), add(mul(v[2], m[246], mt[246]), mul(v[3], m[247], mt[247])))));
-    tmp[14] = add(tmp[14], add(mul(v[0], m[248], mt[248]), add(mul(v[1], m[249], mt[249]), add(mul(v[2], m[250], mt[250]), mul(v[3], m[251], mt[251])))));
-    tmp[15] = add(tmp[15], add(mul(v[0], m[252], mt[252]), add(mul(v[1], m[253], mt[253]), add(mul(v[2], m[254], mt[254]), mul(v[3], m[255], mt[255])))));
+    tmp[0] = add(tmp[0],
+                 add(mul(v[0], m[192], mt[192]),
+                     add(mul(v[1], m[193], mt[193]), add(mul(v[2], m[194], mt[194]), mul(v[3], m[195], mt[195])))));
+    tmp[1] = add(tmp[1],
+                 add(mul(v[0], m[196], mt[196]),
+                     add(mul(v[1], m[197], mt[197]), add(mul(v[2], m[198], mt[198]), mul(v[3], m[199], mt[199])))));
+    tmp[2] = add(tmp[2],
+                 add(mul(v[0], m[200], mt[200]),
+                     add(mul(v[1], m[201], mt[201]), add(mul(v[2], m[202], mt[202]), mul(v[3], m[203], mt[203])))));
+    tmp[3] = add(tmp[3],
+                 add(mul(v[0], m[204], mt[204]),
+                     add(mul(v[1], m[205], mt[205]), add(mul(v[2], m[206], mt[206]), mul(v[3], m[207], mt[207])))));
+    tmp[4] = add(tmp[4],
+                 add(mul(v[0], m[208], mt[208]),
+                     add(mul(v[1], m[209], mt[209]), add(mul(v[2], m[210], mt[210]), mul(v[3], m[211], mt[211])))));
+    tmp[5] = add(tmp[5],
+                 add(mul(v[0], m[212], mt[212]),
+                     add(mul(v[1], m[213], mt[213]), add(mul(v[2], m[214], mt[214]), mul(v[3], m[215], mt[215])))));
+    tmp[6] = add(tmp[6],
+                 add(mul(v[0], m[216], mt[216]),
+                     add(mul(v[1], m[217], mt[217]), add(mul(v[2], m[218], mt[218]), mul(v[3], m[219], mt[219])))));
+    tmp[7] = add(tmp[7],
+                 add(mul(v[0], m[220], mt[220]),
+                     add(mul(v[1], m[221], mt[221]), add(mul(v[2], m[222], mt[222]), mul(v[3], m[223], mt[223])))));
+    tmp[8] = add(tmp[8],
+                 add(mul(v[0], m[224], mt[224]),
+                     add(mul(v[1], m[225], mt[225]), add(mul(v[2], m[226], mt[226]), mul(v[3], m[227], mt[227])))));
+    tmp[9] = add(tmp[9],
+                 add(mul(v[0], m[228], mt[228]),
+                     add(mul(v[1], m[229], mt[229]), add(mul(v[2], m[230], mt[230]), mul(v[3], m[231], mt[231])))));
+    tmp[10] = add(tmp[10],
+                  add(mul(v[0], m[232], mt[232]),
+                      add(mul(v[1], m[233], mt[233]), add(mul(v[2], m[234], mt[234]), mul(v[3], m[235], mt[235])))));
+    tmp[11] = add(tmp[11],
+                  add(mul(v[0], m[236], mt[236]),
+                      add(mul(v[1], m[237], mt[237]), add(mul(v[2], m[238], mt[238]), mul(v[3], m[239], mt[239])))));
+    tmp[12] = add(tmp[12],
+                  add(mul(v[0], m[240], mt[240]),
+                      add(mul(v[1], m[241], mt[241]), add(mul(v[2], m[242], mt[242]), mul(v[3], m[243], mt[243])))));
+    tmp[13] = add(tmp[13],
+                  add(mul(v[0], m[244], mt[244]),
+                      add(mul(v[1], m[245], mt[245]), add(mul(v[2], m[246], mt[246]), mul(v[3], m[247], mt[247])))));
+    tmp[14] = add(tmp[14],
+                  add(mul(v[0], m[248], mt[248]),
+                      add(mul(v[1], m[249], mt[249]), add(mul(v[2], m[250], mt[250]), mul(v[3], m[251], mt[251])))));
+    tmp[15] = add(tmp[15],
+                  add(mul(v[0], m[252], mt[252]),
+                      add(mul(v[1], m[253], mt[253]), add(mul(v[2], m[254], mt[254]), mul(v[3], m[255], mt[255])))));
 
     v[0] = load2(&psi[I + d4]);
     v[1] = load2(&psi[I + d0 + d4]);
     v[2] = load2(&psi[I + d1 + d4]);
     v[3] = load2(&psi[I + d0 + d1 + d4]);
 
-    tmp[0] = add(tmp[0], add(mul(v[0], m[256], mt[256]), add(mul(v[1], m[257], mt[257]), add(mul(v[2], m[258], mt[258]), mul(v[3], m[259], mt[259])))));
-    tmp[1] = add(tmp[1], add(mul(v[0], m[260], mt[260]), add(mul(v[1], m[261], mt[261]), add(mul(v[2], m[262], mt[262]), mul(v[3], m[263], mt[263])))));
-    tmp[2] = add(tmp[2], add(mul(v[0], m[264], mt[264]), add(mul(v[1], m[265], mt[265]), add(mul(v[2], m[266], mt[266]), mul(v[3], m[267], mt[267])))));
-    tmp[3] = add(tmp[3], add(mul(v[0], m[268], mt[268]), add(mul(v[1], m[269], mt[269]), add(mul(v[2], m[270], mt[270]), mul(v[3], m[271], mt[271])))));
-    tmp[4] = add(tmp[4], add(mul(v[0], m[272], mt[272]), add(mul(v[1], m[273], mt[273]), add(mul(v[2], m[274], mt[274]), mul(v[3], m[275], mt[275])))));
-    tmp[5] = add(tmp[5], add(mul(v[0], m[276], mt[276]), add(mul(v[1], m[277], mt[277]), add(mul(v[2], m[278], mt[278]), mul(v[3], m[279], mt[279])))));
-    tmp[6] = add(tmp[6], add(mul(v[0], m[280], mt[280]), add(mul(v[1], m[281], mt[281]), add(mul(v[2], m[282], mt[282]), mul(v[3], m[283], mt[283])))));
-    tmp[7] = add(tmp[7], add(mul(v[0], m[284], mt[284]), add(mul(v[1], m[285], mt[285]), add(mul(v[2], m[286], mt[286]), mul(v[3], m[287], mt[287])))));
-    tmp[8] = add(tmp[8], add(mul(v[0], m[288], mt[288]), add(mul(v[1], m[289], mt[289]), add(mul(v[2], m[290], mt[290]), mul(v[3], m[291], mt[291])))));
-    tmp[9] = add(tmp[9], add(mul(v[0], m[292], mt[292]), add(mul(v[1], m[293], mt[293]), add(mul(v[2], m[294], mt[294]), mul(v[3], m[295], mt[295])))));
-    tmp[10] = add(tmp[10], add(mul(v[0], m[296], mt[296]), add(mul(v[1], m[297], mt[297]), add(mul(v[2], m[298], mt[298]), mul(v[3], m[299], mt[299])))));
-    tmp[11] = add(tmp[11], add(mul(v[0], m[300], mt[300]), add(mul(v[1], m[301], mt[301]), add(mul(v[2], m[302], mt[302]), mul(v[3], m[303], mt[303])))));
-    tmp[12] = add(tmp[12], add(mul(v[0], m[304], mt[304]), add(mul(v[1], m[305], mt[305]), add(mul(v[2], m[306], mt[306]), mul(v[3], m[307], mt[307])))));
-    tmp[13] = add(tmp[13], add(mul(v[0], m[308], mt[308]), add(mul(v[1], m[309], mt[309]), add(mul(v[2], m[310], mt[310]), mul(v[3], m[311], mt[311])))));
-    tmp[14] = add(tmp[14], add(mul(v[0], m[312], mt[312]), add(mul(v[1], m[313], mt[313]), add(mul(v[2], m[314], mt[314]), mul(v[3], m[315], mt[315])))));
-    tmp[15] = add(tmp[15], add(mul(v[0], m[316], mt[316]), add(mul(v[1], m[317], mt[317]), add(mul(v[2], m[318], mt[318]), mul(v[3], m[319], mt[319])))));
+    tmp[0] = add(tmp[0],
+                 add(mul(v[0], m[256], mt[256]),
+                     add(mul(v[1], m[257], mt[257]), add(mul(v[2], m[258], mt[258]), mul(v[3], m[259], mt[259])))));
+    tmp[1] = add(tmp[1],
+                 add(mul(v[0], m[260], mt[260]),
+                     add(mul(v[1], m[261], mt[261]), add(mul(v[2], m[262], mt[262]), mul(v[3], m[263], mt[263])))));
+    tmp[2] = add(tmp[2],
+                 add(mul(v[0], m[264], mt[264]),
+                     add(mul(v[1], m[265], mt[265]), add(mul(v[2], m[266], mt[266]), mul(v[3], m[267], mt[267])))));
+    tmp[3] = add(tmp[3],
+                 add(mul(v[0], m[268], mt[268]),
+                     add(mul(v[1], m[269], mt[269]), add(mul(v[2], m[270], mt[270]), mul(v[3], m[271], mt[271])))));
+    tmp[4] = add(tmp[4],
+                 add(mul(v[0], m[272], mt[272]),
+                     add(mul(v[1], m[273], mt[273]), add(mul(v[2], m[274], mt[274]), mul(v[3], m[275], mt[275])))));
+    tmp[5] = add(tmp[5],
+                 add(mul(v[0], m[276], mt[276]),
+                     add(mul(v[1], m[277], mt[277]), add(mul(v[2], m[278], mt[278]), mul(v[3], m[279], mt[279])))));
+    tmp[6] = add(tmp[6],
+                 add(mul(v[0], m[280], mt[280]),
+                     add(mul(v[1], m[281], mt[281]), add(mul(v[2], m[282], mt[282]), mul(v[3], m[283], mt[283])))));
+    tmp[7] = add(tmp[7],
+                 add(mul(v[0], m[284], mt[284]),
+                     add(mul(v[1], m[285], mt[285]), add(mul(v[2], m[286], mt[286]), mul(v[3], m[287], mt[287])))));
+    tmp[8] = add(tmp[8],
+                 add(mul(v[0], m[288], mt[288]),
+                     add(mul(v[1], m[289], mt[289]), add(mul(v[2], m[290], mt[290]), mul(v[3], m[291], mt[291])))));
+    tmp[9] = add(tmp[9],
+                 add(mul(v[0], m[292], mt[292]),
+                     add(mul(v[1], m[293], mt[293]), add(mul(v[2], m[294], mt[294]), mul(v[3], m[295], mt[295])))));
+    tmp[10] = add(tmp[10],
+                  add(mul(v[0], m[296], mt[296]),
+                      add(mul(v[1], m[297], mt[297]), add(mul(v[2], m[298], mt[298]), mul(v[3], m[299], mt[299])))));
+    tmp[11] = add(tmp[11],
+                  add(mul(v[0], m[300], mt[300]),
+                      add(mul(v[1], m[301], mt[301]), add(mul(v[2], m[302], mt[302]), mul(v[3], m[303], mt[303])))));
+    tmp[12] = add(tmp[12],
+                  add(mul(v[0], m[304], mt[304]),
+                      add(mul(v[1], m[305], mt[305]), add(mul(v[2], m[306], mt[306]), mul(v[3], m[307], mt[307])))));
+    tmp[13] = add(tmp[13],
+                  add(mul(v[0], m[308], mt[308]),
+                      add(mul(v[1], m[309], mt[309]), add(mul(v[2], m[310], mt[310]), mul(v[3], m[311], mt[311])))));
+    tmp[14] = add(tmp[14],
+                  add(mul(v[0], m[312], mt[312]),
+                      add(mul(v[1], m[313], mt[313]), add(mul(v[2], m[314], mt[314]), mul(v[3], m[315], mt[315])))));
+    tmp[15] = add(tmp[15],
+                  add(mul(v[0], m[316], mt[316]),
+                      add(mul(v[1], m[317], mt[317]), add(mul(v[2], m[318], mt[318]), mul(v[3], m[319], mt[319])))));
 
     v[0] = load2(&psi[I + d2 + d4]);
     v[1] = load2(&psi[I + d0 + d2 + d4]);
     v[2] = load2(&psi[I + d1 + d2 + d4]);
     v[3] = load2(&psi[I + d0 + d1 + d2 + d4]);
 
-    tmp[0] = add(tmp[0], add(mul(v[0], m[320], mt[320]), add(mul(v[1], m[321], mt[321]), add(mul(v[2], m[322], mt[322]), mul(v[3], m[323], mt[323])))));
-    tmp[1] = add(tmp[1], add(mul(v[0], m[324], mt[324]), add(mul(v[1], m[325], mt[325]), add(mul(v[2], m[326], mt[326]), mul(v[3], m[327], mt[327])))));
-    tmp[2] = add(tmp[2], add(mul(v[0], m[328], mt[328]), add(mul(v[1], m[329], mt[329]), add(mul(v[2], m[330], mt[330]), mul(v[3], m[331], mt[331])))));
-    tmp[3] = add(tmp[3], add(mul(v[0], m[332], mt[332]), add(mul(v[1], m[333], mt[333]), add(mul(v[2], m[334], mt[334]), mul(v[3], m[335], mt[335])))));
-    tmp[4] = add(tmp[4], add(mul(v[0], m[336], mt[336]), add(mul(v[1], m[337], mt[337]), add(mul(v[2], m[338], mt[338]), mul(v[3], m[339], mt[339])))));
-    tmp[5] = add(tmp[5], add(mul(v[0], m[340], mt[340]), add(mul(v[1], m[341], mt[341]), add(mul(v[2], m[342], mt[342]), mul(v[3], m[343], mt[343])))));
-    tmp[6] = add(tmp[6], add(mul(v[0], m[344], mt[344]), add(mul(v[1], m[345], mt[345]), add(mul(v[2], m[346], mt[346]), mul(v[3], m[347], mt[347])))));
-    tmp[7] = add(tmp[7], add(mul(v[0], m[348], mt[348]), add(mul(v[1], m[349], mt[349]), add(mul(v[2], m[350], mt[350]), mul(v[3], m[351], mt[351])))));
-    tmp[8] = add(tmp[8], add(mul(v[0], m[352], mt[352]), add(mul(v[1], m[353], mt[353]), add(mul(v[2], m[354], mt[354]), mul(v[3], m[355], mt[355])))));
-    tmp[9] = add(tmp[9], add(mul(v[0], m[356], mt[356]), add(mul(v[1], m[357], mt[357]), add(mul(v[2], m[358], mt[358]), mul(v[3], m[359], mt[359])))));
-    tmp[10] = add(tmp[10], add(mul(v[0], m[360], mt[360]), add(mul(v[1], m[361], mt[361]), add(mul(v[2], m[362], mt[362]), mul(v[3], m[363], mt[363])))));
-    tmp[11] = add(tmp[11], add(mul(v[0], m[364], mt[364]), add(mul(v[1], m[365], mt[365]), add(mul(v[2], m[366], mt[366]), mul(v[3], m[367], mt[367])))));
-    tmp[12] = add(tmp[12], add(mul(v[0], m[368], mt[368]), add(mul(v[1], m[369], mt[369]), add(mul(v[2], m[370], mt[370]), mul(v[3], m[371], mt[371])))));
-    tmp[13] = add(tmp[13], add(mul(v[0], m[372], mt[372]), add(mul(v[1], m[373], mt[373]), add(mul(v[2], m[374], mt[374]), mul(v[3], m[375], mt[375])))));
-    tmp[14] = add(tmp[14], add(mul(v[0], m[376], mt[376]), add(mul(v[1], m[377], mt[377]), add(mul(v[2], m[378], mt[378]), mul(v[3], m[379], mt[379])))));
-    tmp[15] = add(tmp[15], add(mul(v[0], m[380], mt[380]), add(mul(v[1], m[381], mt[381]), add(mul(v[2], m[382], mt[382]), mul(v[3], m[383], mt[383])))));
+    tmp[0] = add(tmp[0],
+                 add(mul(v[0], m[320], mt[320]),
+                     add(mul(v[1], m[321], mt[321]), add(mul(v[2], m[322], mt[322]), mul(v[3], m[323], mt[323])))));
+    tmp[1] = add(tmp[1],
+                 add(mul(v[0], m[324], mt[324]),
+                     add(mul(v[1], m[325], mt[325]), add(mul(v[2], m[326], mt[326]), mul(v[3], m[327], mt[327])))));
+    tmp[2] = add(tmp[2],
+                 add(mul(v[0], m[328], mt[328]),
+                     add(mul(v[1], m[329], mt[329]), add(mul(v[2], m[330], mt[330]), mul(v[3], m[331], mt[331])))));
+    tmp[3] = add(tmp[3],
+                 add(mul(v[0], m[332], mt[332]),
+                     add(mul(v[1], m[333], mt[333]), add(mul(v[2], m[334], mt[334]), mul(v[3], m[335], mt[335])))));
+    tmp[4] = add(tmp[4],
+                 add(mul(v[0], m[336], mt[336]),
+                     add(mul(v[1], m[337], mt[337]), add(mul(v[2], m[338], mt[338]), mul(v[3], m[339], mt[339])))));
+    tmp[5] = add(tmp[5],
+                 add(mul(v[0], m[340], mt[340]),
+                     add(mul(v[1], m[341], mt[341]), add(mul(v[2], m[342], mt[342]), mul(v[3], m[343], mt[343])))));
+    tmp[6] = add(tmp[6],
+                 add(mul(v[0], m[344], mt[344]),
+                     add(mul(v[1], m[345], mt[345]), add(mul(v[2], m[346], mt[346]), mul(v[3], m[347], mt[347])))));
+    tmp[7] = add(tmp[7],
+                 add(mul(v[0], m[348], mt[348]),
+                     add(mul(v[1], m[349], mt[349]), add(mul(v[2], m[350], mt[350]), mul(v[3], m[351], mt[351])))));
+    tmp[8] = add(tmp[8],
+                 add(mul(v[0], m[352], mt[352]),
+                     add(mul(v[1], m[353], mt[353]), add(mul(v[2], m[354], mt[354]), mul(v[3], m[355], mt[355])))));
+    tmp[9] = add(tmp[9],
+                 add(mul(v[0], m[356], mt[356]),
+                     add(mul(v[1], m[357], mt[357]), add(mul(v[2], m[358], mt[358]), mul(v[3], m[359], mt[359])))));
+    tmp[10] = add(tmp[10],
+                  add(mul(v[0], m[360], mt[360]),
+                      add(mul(v[1], m[361], mt[361]), add(mul(v[2], m[362], mt[362]), mul(v[3], m[363], mt[363])))));
+    tmp[11] = add(tmp[11],
+                  add(mul(v[0], m[364], mt[364]),
+                      add(mul(v[1], m[365], mt[365]), add(mul(v[2], m[366], mt[366]), mul(v[3], m[367], mt[367])))));
+    tmp[12] = add(tmp[12],
+                  add(mul(v[0], m[368], mt[368]),
+                      add(mul(v[1], m[369], mt[369]), add(mul(v[2], m[370], mt[370]), mul(v[3], m[371], mt[371])))));
+    tmp[13] = add(tmp[13],
+                  add(mul(v[0], m[372], mt[372]),
+                      add(mul(v[1], m[373], mt[373]), add(mul(v[2], m[374], mt[374]), mul(v[3], m[375], mt[375])))));
+    tmp[14] = add(tmp[14],
+                  add(mul(v[0], m[376], mt[376]),
+                      add(mul(v[1], m[377], mt[377]), add(mul(v[2], m[378], mt[378]), mul(v[3], m[379], mt[379])))));
+    tmp[15] = add(tmp[15],
+                  add(mul(v[0], m[380], mt[380]),
+                      add(mul(v[1], m[381], mt[381]), add(mul(v[2], m[382], mt[382]), mul(v[3], m[383], mt[383])))));
 
     v[0] = load2(&psi[I + d3 + d4]);
     v[1] = load2(&psi[I + d0 + d3 + d4]);
     v[2] = load2(&psi[I + d1 + d3 + d4]);
     v[3] = load2(&psi[I + d0 + d1 + d3 + d4]);
 
-    tmp[0] = add(tmp[0], add(mul(v[0], m[384], mt[384]), add(mul(v[1], m[385], mt[385]), add(mul(v[2], m[386], mt[386]), mul(v[3], m[387], mt[387])))));
-    tmp[1] = add(tmp[1], add(mul(v[0], m[388], mt[388]), add(mul(v[1], m[389], mt[389]), add(mul(v[2], m[390], mt[390]), mul(v[3], m[391], mt[391])))));
-    tmp[2] = add(tmp[2], add(mul(v[0], m[392], mt[392]), add(mul(v[1], m[393], mt[393]), add(mul(v[2], m[394], mt[394]), mul(v[3], m[395], mt[395])))));
-    tmp[3] = add(tmp[3], add(mul(v[0], m[396], mt[396]), add(mul(v[1], m[397], mt[397]), add(mul(v[2], m[398], mt[398]), mul(v[3], m[399], mt[399])))));
-    tmp[4] = add(tmp[4], add(mul(v[0], m[400], mt[400]), add(mul(v[1], m[401], mt[401]), add(mul(v[2], m[402], mt[402]), mul(v[3], m[403], mt[403])))));
-    tmp[5] = add(tmp[5], add(mul(v[0], m[404], mt[404]), add(mul(v[1], m[405], mt[405]), add(mul(v[2], m[406], mt[406]), mul(v[3], m[407], mt[407])))));
-    tmp[6] = add(tmp[6], add(mul(v[0], m[408], mt[408]), add(mul(v[1], m[409], mt[409]), add(mul(v[2], m[410], mt[410]), mul(v[3], m[411], mt[411])))));
-    tmp[7] = add(tmp[7], add(mul(v[0], m[412], mt[412]), add(mul(v[1], m[413], mt[413]), add(mul(v[2], m[414], mt[414]), mul(v[3], m[415], mt[415])))));
-    tmp[8] = add(tmp[8], add(mul(v[0], m[416], mt[416]), add(mul(v[1], m[417], mt[417]), add(mul(v[2], m[418], mt[418]), mul(v[3], m[419], mt[419])))));
-    tmp[9] = add(tmp[9], add(mul(v[0], m[420], mt[420]), add(mul(v[1], m[421], mt[421]), add(mul(v[2], m[422], mt[422]), mul(v[3], m[423], mt[423])))));
-    tmp[10] = add(tmp[10], add(mul(v[0], m[424], mt[424]), add(mul(v[1], m[425], mt[425]), add(mul(v[2], m[426], mt[426]), mul(v[3], m[427], mt[427])))));
-    tmp[11] = add(tmp[11], add(mul(v[0], m[428], mt[428]), add(mul(v[1], m[429], mt[429]), add(mul(v[2], m[430], mt[430]), mul(v[3], m[431], mt[431])))));
-    tmp[12] = add(tmp[12], add(mul(v[0], m[432], mt[432]), add(mul(v[1], m[433], mt[433]), add(mul(v[2], m[434], mt[434]), mul(v[3], m[435], mt[435])))));
-    tmp[13] = add(tmp[13], add(mul(v[0], m[436], mt[436]), add(mul(v[1], m[437], mt[437]), add(mul(v[2], m[438], mt[438]), mul(v[3], m[439], mt[439])))));
-    tmp[14] = add(tmp[14], add(mul(v[0], m[440], mt[440]), add(mul(v[1], m[441], mt[441]), add(mul(v[2], m[442], mt[442]), mul(v[3], m[443], mt[443])))));
-    tmp[15] = add(tmp[15], add(mul(v[0], m[444], mt[444]), add(mul(v[1], m[445], mt[445]), add(mul(v[2], m[446], mt[446]), mul(v[3], m[447], mt[447])))));
+    tmp[0] = add(tmp[0],
+                 add(mul(v[0], m[384], mt[384]),
+                     add(mul(v[1], m[385], mt[385]), add(mul(v[2], m[386], mt[386]), mul(v[3], m[387], mt[387])))));
+    tmp[1] = add(tmp[1],
+                 add(mul(v[0], m[388], mt[388]),
+                     add(mul(v[1], m[389], mt[389]), add(mul(v[2], m[390], mt[390]), mul(v[3], m[391], mt[391])))));
+    tmp[2] = add(tmp[2],
+                 add(mul(v[0], m[392], mt[392]),
+                     add(mul(v[1], m[393], mt[393]), add(mul(v[2], m[394], mt[394]), mul(v[3], m[395], mt[395])))));
+    tmp[3] = add(tmp[3],
+                 add(mul(v[0], m[396], mt[396]),
+                     add(mul(v[1], m[397], mt[397]), add(mul(v[2], m[398], mt[398]), mul(v[3], m[399], mt[399])))));
+    tmp[4] = add(tmp[4],
+                 add(mul(v[0], m[400], mt[400]),
+                     add(mul(v[1], m[401], mt[401]), add(mul(v[2], m[402], mt[402]), mul(v[3], m[403], mt[403])))));
+    tmp[5] = add(tmp[5],
+                 add(mul(v[0], m[404], mt[404]),
+                     add(mul(v[1], m[405], mt[405]), add(mul(v[2], m[406], mt[406]), mul(v[3], m[407], mt[407])))));
+    tmp[6] = add(tmp[6],
+                 add(mul(v[0], m[408], mt[408]),
+                     add(mul(v[1], m[409], mt[409]), add(mul(v[2], m[410], mt[410]), mul(v[3], m[411], mt[411])))));
+    tmp[7] = add(tmp[7],
+                 add(mul(v[0], m[412], mt[412]),
+                     add(mul(v[1], m[413], mt[413]), add(mul(v[2], m[414], mt[414]), mul(v[3], m[415], mt[415])))));
+    tmp[8] = add(tmp[8],
+                 add(mul(v[0], m[416], mt[416]),
+                     add(mul(v[1], m[417], mt[417]), add(mul(v[2], m[418], mt[418]), mul(v[3], m[419], mt[419])))));
+    tmp[9] = add(tmp[9],
+                 add(mul(v[0], m[420], mt[420]),
+                     add(mul(v[1], m[421], mt[421]), add(mul(v[2], m[422], mt[422]), mul(v[3], m[423], mt[423])))));
+    tmp[10] = add(tmp[10],
+                  add(mul(v[0], m[424], mt[424]),
+                      add(mul(v[1], m[425], mt[425]), add(mul(v[2], m[426], mt[426]), mul(v[3], m[427], mt[427])))));
+    tmp[11] = add(tmp[11],
+                  add(mul(v[0], m[428], mt[428]),
+                      add(mul(v[1], m[429], mt[429]), add(mul(v[2], m[430], mt[430]), mul(v[3], m[431], mt[431])))));
+    tmp[12] = add(tmp[12],
+                  add(mul(v[0], m[432], mt[432]),
+                      add(mul(v[1], m[433], mt[433]), add(mul(v[2], m[434], mt[434]), mul(v[3], m[435], mt[435])))));
+    tmp[13] = add(tmp[13],
+                  add(mul(v[0], m[436], mt[436]),
+                      add(mul(v[1], m[437], mt[437]), add(mul(v[2], m[438], mt[438]), mul(v[3], m[439], mt[439])))));
+    tmp[14] = add(tmp[14],
+                  add(mul(v[0], m[440], mt[440]),
+                      add(mul(v[1], m[441], mt[441]), add(mul(v[2], m[442], mt[442]), mul(v[3], m[443], mt[443])))));
+    tmp[15] = add(tmp[15],
+                  add(mul(v[0], m[444], mt[444]),
+                      add(mul(v[1], m[445], mt[445]), add(mul(v[2], m[446], mt[446]), mul(v[3], m[447], mt[447])))));
 
     v[0] = load2(&psi[I + d2 + d3 + d4]);
     v[1] = load2(&psi[I + d0 + d2 + d3 + d4]);
     v[2] = load2(&psi[I + d1 + d2 + d3 + d4]);
     v[3] = load2(&psi[I + d0 + d1 + d2 + d3 + d4]);
 
-    _mm256_storeu2_m128d((double*)&psi[I + d0], (double*)&psi[I], add(tmp[0], add(mul(v[0], m[448], mt[448]), add(mul(v[1], m[449], mt[449]), add(mul(v[2], m[450], mt[450]), mul(v[3], m[451], mt[451]))))));
-    _mm256_storeu2_m128d((double*)&psi[I + d0 + d1], (double*)&psi[I + d1], add(tmp[1], add(mul(v[0], m[452], mt[452]), add(mul(v[1], m[453], mt[453]), add(mul(v[2], m[454], mt[454]), mul(v[3], m[455], mt[455]))))));
-    _mm256_storeu2_m128d((double*)&psi[I + d0 + d2], (double*)&psi[I + d2], add(tmp[2], add(mul(v[0], m[456], mt[456]), add(mul(v[1], m[457], mt[457]), add(mul(v[2], m[458], mt[458]), mul(v[3], m[459], mt[459]))))));
-    _mm256_storeu2_m128d((double*)&psi[I + d0 + d1 + d2], (double*)&psi[I + d1 + d2], add(tmp[3], add(mul(v[0], m[460], mt[460]), add(mul(v[1], m[461], mt[461]), add(mul(v[2], m[462], mt[462]), mul(v[3], m[463], mt[463]))))));
-    _mm256_storeu2_m128d((double*)&psi[I + d0 + d3], (double*)&psi[I + d3], add(tmp[4], add(mul(v[0], m[464], mt[464]), add(mul(v[1], m[465], mt[465]), add(mul(v[2], m[466], mt[466]), mul(v[3], m[467], mt[467]))))));
-    _mm256_storeu2_m128d((double*)&psi[I + d0 + d1 + d3], (double*)&psi[I + d1 + d3], add(tmp[5], add(mul(v[0], m[468], mt[468]), add(mul(v[1], m[469], mt[469]), add(mul(v[2], m[470], mt[470]), mul(v[3], m[471], mt[471]))))));
-    _mm256_storeu2_m128d((double*)&psi[I + d0 + d2 + d3], (double*)&psi[I + d2 + d3], add(tmp[6], add(mul(v[0], m[472], mt[472]), add(mul(v[1], m[473], mt[473]), add(mul(v[2], m[474], mt[474]), mul(v[3], m[475], mt[475]))))));
-    _mm256_storeu2_m128d((double*)&psi[I + d0 + d1 + d2 + d3], (double*)&psi[I + d1 + d2 + d3], add(tmp[7], add(mul(v[0], m[476], mt[476]), add(mul(v[1], m[477], mt[477]), add(mul(v[2], m[478], mt[478]), mul(v[3], m[479], mt[479]))))));
-    _mm256_storeu2_m128d((double*)&psi[I + d0 + d4], (double*)&psi[I + d4], add(tmp[8], add(mul(v[0], m[480], mt[480]), add(mul(v[1], m[481], mt[481]), add(mul(v[2], m[482], mt[482]), mul(v[3], m[483], mt[483]))))));
-    _mm256_storeu2_m128d((double*)&psi[I + d0 + d1 + d4], (double*)&psi[I + d1 + d4], add(tmp[9], add(mul(v[0], m[484], mt[484]), add(mul(v[1], m[485], mt[485]), add(mul(v[2], m[486], mt[486]), mul(v[3], m[487], mt[487]))))));
-    _mm256_storeu2_m128d((double*)&psi[I + d0 + d2 + d4], (double*)&psi[I + d2 + d4], add(tmp[10], add(mul(v[0], m[488], mt[488]), add(mul(v[1], m[489], mt[489]), add(mul(v[2], m[490], mt[490]), mul(v[3], m[491], mt[491]))))));
-    _mm256_storeu2_m128d((double*)&psi[I + d0 + d1 + d2 + d4], (double*)&psi[I + d1 + d2 + d4], add(tmp[11], add(mul(v[0], m[492], mt[492]), add(mul(v[1], m[493], mt[493]), add(mul(v[2], m[494], mt[494]), mul(v[3], m[495], mt[495]))))));
-    _mm256_storeu2_m128d((double*)&psi[I + d0 + d3 + d4], (double*)&psi[I + d3 + d4], add(tmp[12], add(mul(v[0], m[496], mt[496]), add(mul(v[1], m[497], mt[497]), add(mul(v[2], m[498], mt[498]), mul(v[3], m[499], mt[499]))))));
-    _mm256_storeu2_m128d((double*)&psi[I + d0 + d1 + d3 + d4], (double*)&psi[I + d1 + d3 + d4], add(tmp[13], add(mul(v[0], m[500], mt[500]), add(mul(v[1], m[501], mt[501]), add(mul(v[2], m[502], mt[502]), mul(v[3], m[503], mt[503]))))));
-    _mm256_storeu2_m128d((double*)&psi[I + d0 + d2 + d3 + d4], (double*)&psi[I + d2 + d3 + d4], add(tmp[14], add(mul(v[0], m[504], mt[504]), add(mul(v[1], m[505], mt[505]), add(mul(v[2], m[506], mt[506]), mul(v[3], m[507], mt[507]))))));
-    _mm256_storeu2_m128d((double*)&psi[I + d0 + d1 + d2 + d3 + d4], (double*)&psi[I + d1 + d2 + d3 + d4], add(tmp[15], add(mul(v[0], m[508], mt[508]), add(mul(v[1], m[509], mt[509]), add(mul(v[2], m[510], mt[510]), mul(v[3], m[511], mt[511]))))));
-
+    _mm256_storeu2_m128d(
+        (double*) &psi[I + d0], (double*) &psi[I],
+        add(tmp[0], add(mul(v[0], m[448], mt[448]),
+                        add(mul(v[1], m[449], mt[449]), add(mul(v[2], m[450], mt[450]), mul(v[3], m[451], mt[451]))))));
+    _mm256_storeu2_m128d(
+        (double*) &psi[I + d0 + d1], (double*) &psi[I + d1],
+        add(tmp[1], add(mul(v[0], m[452], mt[452]),
+                        add(mul(v[1], m[453], mt[453]), add(mul(v[2], m[454], mt[454]), mul(v[3], m[455], mt[455]))))));
+    _mm256_storeu2_m128d(
+        (double*) &psi[I + d0 + d2], (double*) &psi[I + d2],
+        add(tmp[2], add(mul(v[0], m[456], mt[456]),
+                        add(mul(v[1], m[457], mt[457]), add(mul(v[2], m[458], mt[458]), mul(v[3], m[459], mt[459]))))));
+    _mm256_storeu2_m128d(
+        (double*) &psi[I + d0 + d1 + d2], (double*) &psi[I + d1 + d2],
+        add(tmp[3], add(mul(v[0], m[460], mt[460]),
+                        add(mul(v[1], m[461], mt[461]), add(mul(v[2], m[462], mt[462]), mul(v[3], m[463], mt[463]))))));
+    _mm256_storeu2_m128d(
+        (double*) &psi[I + d0 + d3], (double*) &psi[I + d3],
+        add(tmp[4], add(mul(v[0], m[464], mt[464]),
+                        add(mul(v[1], m[465], mt[465]), add(mul(v[2], m[466], mt[466]), mul(v[3], m[467], mt[467]))))));
+    _mm256_storeu2_m128d(
+        (double*) &psi[I + d0 + d1 + d3], (double*) &psi[I + d1 + d3],
+        add(tmp[5], add(mul(v[0], m[468], mt[468]),
+                        add(mul(v[1], m[469], mt[469]), add(mul(v[2], m[470], mt[470]), mul(v[3], m[471], mt[471]))))));
+    _mm256_storeu2_m128d(
+        (double*) &psi[I + d0 + d2 + d3], (double*) &psi[I + d2 + d3],
+        add(tmp[6], add(mul(v[0], m[472], mt[472]),
+                        add(mul(v[1], m[473], mt[473]), add(mul(v[2], m[474], mt[474]), mul(v[3], m[475], mt[475]))))));
+    _mm256_storeu2_m128d(
+        (double*) &psi[I + d0 + d1 + d2 + d3], (double*) &psi[I + d1 + d2 + d3],
+        add(tmp[7], add(mul(v[0], m[476], mt[476]),
+                        add(mul(v[1], m[477], mt[477]), add(mul(v[2], m[478], mt[478]), mul(v[3], m[479], mt[479]))))));
+    _mm256_storeu2_m128d(
+        (double*) &psi[I + d0 + d4], (double*) &psi[I + d4],
+        add(tmp[8], add(mul(v[0], m[480], mt[480]),
+                        add(mul(v[1], m[481], mt[481]), add(mul(v[2], m[482], mt[482]), mul(v[3], m[483], mt[483]))))));
+    _mm256_storeu2_m128d(
+        (double*) &psi[I + d0 + d1 + d4], (double*) &psi[I + d1 + d4],
+        add(tmp[9], add(mul(v[0], m[484], mt[484]),
+                        add(mul(v[1], m[485], mt[485]), add(mul(v[2], m[486], mt[486]), mul(v[3], m[487], mt[487]))))));
+    _mm256_storeu2_m128d((double*) &psi[I + d0 + d2 + d4], (double*) &psi[I + d2 + d4],
+                         add(tmp[10], add(mul(v[0], m[488], mt[488]),
+                                          add(mul(v[1], m[489], mt[489]),
+                                              add(mul(v[2], m[490], mt[490]), mul(v[3], m[491], mt[491]))))));
+    _mm256_storeu2_m128d((double*) &psi[I + d0 + d1 + d2 + d4], (double*) &psi[I + d1 + d2 + d4],
+                         add(tmp[11], add(mul(v[0], m[492], mt[492]),
+                                          add(mul(v[1], m[493], mt[493]),
+                                              add(mul(v[2], m[494], mt[494]), mul(v[3], m[495], mt[495]))))));
+    _mm256_storeu2_m128d((double*) &psi[I + d0 + d3 + d4], (double*) &psi[I + d3 + d4],
+                         add(tmp[12], add(mul(v[0], m[496], mt[496]),
+                                          add(mul(v[1], m[497], mt[497]),
+                                              add(mul(v[2], m[498], mt[498]), mul(v[3], m[499], mt[499]))))));
+    _mm256_storeu2_m128d((double*) &psi[I + d0 + d1 + d3 + d4], (double*) &psi[I + d1 + d3 + d4],
+                         add(tmp[13], add(mul(v[0], m[500], mt[500]),
+                                          add(mul(v[1], m[501], mt[501]),
+                                              add(mul(v[2], m[502], mt[502]), mul(v[3], m[503], mt[503]))))));
+    _mm256_storeu2_m128d((double*) &psi[I + d0 + d2 + d3 + d4], (double*) &psi[I + d2 + d3 + d4],
+                         add(tmp[14], add(mul(v[0], m[504], mt[504]),
+                                          add(mul(v[1], m[505], mt[505]),
+                                              add(mul(v[2], m[506], mt[506]), mul(v[3], m[507], mt[507]))))));
+    _mm256_storeu2_m128d((double*) &psi[I + d0 + d1 + d2 + d3 + d4], (double*) &psi[I + d1 + d2 + d3 + d4],
+                         add(tmp[15], add(mul(v[0], m[508], mt[508]),
+                                          add(mul(v[1], m[509], mt[509]),
+                                              add(mul(v[2], m[510], mt[510]), mul(v[3], m[511], mt[511]))))));
 }
 
 // bit indices id[.] are given from high to low (e.g. control first for CNOT)
 template <class V, class M>
-void kernel(V &psi, unsigned id4, unsigned id3, unsigned id2, unsigned id1, unsigned id0, M const& m, std::size_t ctrlmask)
-{
+void kernel(V& psi, unsigned id4, unsigned id3, unsigned id2, unsigned id1, unsigned id0, M const& m,
+            std::size_t ctrlmask) {
     std::size_t n = psi.size();
     std::size_t d0 = 1UL << id0;
     std::size_t d1 = 1UL << id1;
@@ -208,26 +454,196 @@ void kernel(V &psi, unsigned id4, unsign
     std::size_t d3 = 1UL << id3;
     std::size_t d4 = 1UL << id4;
 
-    __m256d mm[] = {load(&m[0][0], &m[1][0]), load(&m[0][1], &m[1][1]), load(&m[0][2], &m[1][2]), load(&m[0][3], &m[1][3]), load(&m[2][0], &m[3][0]), load(&m[2][1], &m[3][1]), load(&m[2][2], &m[3][2]), load(&m[2][3], &m[3][3]), load(&m[4][0], &m[5][0]), load(&m[4][1], &m[5][1]), load(&m[4][2], &m[5][2]), load(&m[4][3], &m[5][3]), load(&m[6][0], &m[7][0]), load(&m[6][1], &m[7][1]), load(&m[6][2], &m[7][2]), load(&m[6][3], &m[7][3]), load(&m[8][0], &m[9][0]), load(&m[8][1], &m[9][1]), load(&m[8][2], &m[9][2]), load(&m[8][3], &m[9][3]), load(&m[10][0], &m[11][0]), load(&m[10][1], &m[11][1]), load(&m[10][2], &m[11][2]), load(&m[10][3], &m[11][3]), load(&m[12][0], &m[13][0]), load(&m[12][1], &m[13][1]), load(&m[12][2], &m[13][2]), load(&m[12][3], &m[13][3]), load(&m[14][0], &m[15][0]), load(&m[14][1], &m[15][1]), load(&m[14][2], &m[15][2]), load(&m[14][3], &m[15][3]), load(&m[16][0], &m[17][0]), load(&m[16][1], &m[17][1]), load(&m[16][2], &m[17][2]), load(&m[16][3], &m[17][3]), load(&m[18][0], &m[19][0]), load(&m[18][1], &m[19][1]), load(&m[18][2], &m[19][2]), load(&m[18][3], &m[19][3]), load(&m[20][0], &m[21][0]), load(&m[20][1], &m[21][1]), load(&m[20][2], &m[21][2]), load(&m[20][3], &m[21][3]), load(&m[22][0], &m[23][0]), load(&m[22][1], &m[23][1]), load(&m[22][2], &m[23][2]), load(&m[22][3], &m[23][3]), load(&m[24][0], &m[25][0]), load(&m[24][1], &m[25][1]), load(&m[24][2], &m[25][2]), load(&m[24][3], &m[25][3]), load(&m[26][0], &m[27][0]), load(&m[26][1], &m[27][1]), load(&m[26][2], &m[27][2]), load(&m[26][3], &m[27][3]), load(&m[28][0], &m[29][0]), load(&m[28][1], &m[29][1]), load(&m[28][2], &m[29][2]), load(&m[28][3], &m[29][3]), load(&m[30][0], &m[31][0]), load(&m[30][1], &m[31][1]), load(&m[30][2], &m[31][2]), load(&m[30][3], &m[31][3]), load(&m[0][4], &m[1][4]), load(&m[0][5], &m[1][5]), load(&m[0][6], &m[1][6]), load(&m[0][7], &m[1][7]), load(&m[2][4], &m[3][4]), load(&m[2][5], &m[3][5]), load(&m[2][6], &m[3][6]), load(&m[2][7], &m[3][7]), load(&m[4][4], &m[5][4]), load(&m[4][5], &m[5][5]), load(&m[4][6], &m[5][6]), load(&m[4][7], &m[5][7]), load(&m[6][4], &m[7][4]), load(&m[6][5], &m[7][5]), load(&m[6][6], &m[7][6]), load(&m[6][7], &m[7][7]), load(&m[8][4], &m[9][4]), load(&m[8][5], &m[9][5]), load(&m[8][6], &m[9][6]), load(&m[8][7], &m[9][7]), load(&m[10][4], &m[11][4]), load(&m[10][5], &m[11][5]), load(&m[10][6], &m[11][6]), load(&m[10][7], &m[11][7]), load(&m[12][4], &m[13][4]), load(&m[12][5], &m[13][5]), load(&m[12][6], &m[13][6]), load(&m[12][7], &m[13][7]), load(&m[14][4], &m[15][4]), load(&m[14][5], &m[15][5]), load(&m[14][6], &m[15][6]), load(&m[14][7], &m[15][7]), load(&m[16][4], &m[17][4]), load(&m[16][5], &m[17][5]), load(&m[16][6], &m[17][6]), load(&m[16][7], &m[17][7]), load(&m[18][4], &m[19][4]), load(&m[18][5], &m[19][5]), load(&m[18][6], &m[19][6]), load(&m[18][7], &m[19][7]), load(&m[20][4], &m[21][4]), load(&m[20][5], &m[21][5]), load(&m[20][6], &m[21][6]), load(&m[20][7], &m[21][7]), load(&m[22][4], &m[23][4]), load(&m[22][5], &m[23][5]), load(&m[22][6], &m[23][6]), load(&m[22][7], &m[23][7]), load(&m[24][4], &m[25][4]), load(&m[24][5], &m[25][5]), load(&m[24][6], &m[25][6]), load(&m[24][7], &m[25][7]), load(&m[26][4], &m[27][4]), load(&m[26][5], &m[27][5]), load(&m[26][6], &m[27][6]), load(&m[26][7], &m[27][7]), load(&m[28][4], &m[29][4]), load(&m[28][5], &m[29][5]), load(&m[28][6], &m[29][6]), load(&m[28][7], &m[29][7]), load(&m[30][4], &m[31][4]), load(&m[30][5], &m[31][5]), load(&m[30][6], &m[31][6]), load(&m[30][7], &m[31][7]), load(&m[0][8], &m[1][8]), load(&m[0][9], &m[1][9]), load(&m[0][10], &m[1][10]), load(&m[0][11], &m[1][11]), load(&m[2][8], &m[3][8]), load(&m[2][9], &m[3][9]), load(&m[2][10], &m[3][10]), load(&m[2][11], &m[3][11]), load(&m[4][8], &m[5][8]), load(&m[4][9], &m[5][9]), load(&m[4][10], &m[5][10]), load(&m[4][11], &m[5][11]), load(&m[6][8], &m[7][8]), load(&m[6][9], &m[7][9]), load(&m[6][10], &m[7][10]), load(&m[6][11], &m[7][11]), load(&m[8][8], &m[9][8]), load(&m[8][9], &m[9][9]), load(&m[8][10], &m[9][10]), load(&m[8][11], &m[9][11]), load(&m[10][8], &m[11][8]), load(&m[10][9], &m[11][9]), load(&m[10][10], &m[11][10]), load(&m[10][11], &m[11][11]), load(&m[12][8], &m[13][8]), load(&m[12][9], &m[13][9]), load(&m[12][10], &m[13][10]), load(&m[12][11], &m[13][11]), load(&m[14][8], &m[15][8]), load(&m[14][9], &m[15][9]), load(&m[14][10], &m[15][10]), load(&m[14][11], &m[15][11]), load(&m[16][8], &m[17][8]), load(&m[16][9], &m[17][9]), load(&m[16][10], &m[17][10]), load(&m[16][11], &m[17][11]), load(&m[18][8], &m[19][8]), load(&m[18][9], &m[19][9]), load(&m[18][10], &m[19][10]), load(&m[18][11], &m[19][11]), load(&m[20][8], &m[21][8]), load(&m[20][9], &m[21][9]), load(&m[20][10], &m[21][10]), load(&m[20][11], &m[21][11]), load(&m[22][8], &m[23][8]), load(&m[22][9], &m[23][9]), load(&m[22][10], &m[23][10]), load(&m[22][11], &m[23][11]), load(&m[24][8], &m[25][8]), load(&m[24][9], &m[25][9]), load(&m[24][10], &m[25][10]), load(&m[24][11], &m[25][11]), load(&m[26][8], &m[27][8]), load(&m[26][9], &m[27][9]), load(&m[26][10], &m[27][10]), load(&m[26][11], &m[27][11]), load(&m[28][8], &m[29][8]), load(&m[28][9], &m[29][9]), load(&m[28][10], &m[29][10]), load(&m[28][11], &m[29][11]), load(&m[30][8], &m[31][8]), load(&m[30][9], &m[31][9]), load(&m[30][10], &m[31][10]), load(&m[30][11], &m[31][11]), load(&m[0][12], &m[1][12]), load(&m[0][13], &m[1][13]), load(&m[0][14], &m[1][14]), load(&m[0][15], &m[1][15]), load(&m[2][12], &m[3][12]), load(&m[2][13], &m[3][13]), load(&m[2][14], &m[3][14]), load(&m[2][15], &m[3][15]), load(&m[4][12], &m[5][12]), load(&m[4][13], &m[5][13]), load(&m[4][14], &m[5][14]), load(&m[4][15], &m[5][15]), load(&m[6][12], &m[7][12]), load(&m[6][13], &m[7][13]), load(&m[6][14], &m[7][14]), load(&m[6][15], &m[7][15]), load(&m[8][12], &m[9][12]), load(&m[8][13], &m[9][13]), load(&m[8][14], &m[9][14]), load(&m[8][15], &m[9][15]), load(&m[10][12], &m[11][12]), load(&m[10][13], &m[11][13]), load(&m[10][14], &m[11][14]), load(&m[10][15], &m[11][15]), load(&m[12][12], &m[13][12]), load(&m[12][13], &m[13][13]), load(&m[12][14], &m[13][14]), load(&m[12][15], &m[13][15]), load(&m[14][12], &m[15][12]), load(&m[14][13], &m[15][13]), load(&m[14][14], &m[15][14]), load(&m[14][15], &m[15][15]), load(&m[16][12], &m[17][12]), load(&m[16][13], &m[17][13]), load(&m[16][14], &m[17][14]), load(&m[16][15], &m[17][15]), load(&m[18][12], &m[19][12]), load(&m[18][13], &m[19][13]), load(&m[18][14], &m[19][14]), load(&m[18][15], &m[19][15]), load(&m[20][12], &m[21][12]), load(&m[20][13], &m[21][13]), load(&m[20][14], &m[21][14]), load(&m[20][15], &m[21][15]), load(&m[22][12], &m[23][12]), load(&m[22][13], &m[23][13]), load(&m[22][14], &m[23][14]), load(&m[22][15], &m[23][15]), load(&m[24][12], &m[25][12]), load(&m[24][13], &m[25][13]), load(&m[24][14], &m[25][14]), load(&m[24][15], &m[25][15]), load(&m[26][12], &m[27][12]), load(&m[26][13], &m[27][13]), load(&m[26][14], &m[27][14]), load(&m[26][15], &m[27][15]), load(&m[28][12], &m[29][12]), load(&m[28][13], &m[29][13]), load(&m[28][14], &m[29][14]), load(&m[28][15], &m[29][15]), load(&m[30][12], &m[31][12]), load(&m[30][13], &m[31][13]), load(&m[30][14], &m[31][14]), load(&m[30][15], &m[31][15]), load(&m[0][16], &m[1][16]), load(&m[0][17], &m[1][17]), load(&m[0][18], &m[1][18]), load(&m[0][19], &m[1][19]), load(&m[2][16], &m[3][16]), load(&m[2][17], &m[3][17]), load(&m[2][18], &m[3][18]), load(&m[2][19], &m[3][19]), load(&m[4][16], &m[5][16]), load(&m[4][17], &m[5][17]), load(&m[4][18], &m[5][18]), load(&m[4][19], &m[5][19]), load(&m[6][16], &m[7][16]), load(&m[6][17], &m[7][17]), load(&m[6][18], &m[7][18]), load(&m[6][19], &m[7][19]), load(&m[8][16], &m[9][16]), load(&m[8][17], &m[9][17]), load(&m[8][18], &m[9][18]), load(&m[8][19], &m[9][19]), load(&m[10][16], &m[11][16]), load(&m[10][17], &m[11][17]), load(&m[10][18], &m[11][18]), load(&m[10][19], &m[11][19]), load(&m[12][16], &m[13][16]), load(&m[12][17], &m[13][17]), load(&m[12][18], &m[13][18]), load(&m[12][19], &m[13][19]), load(&m[14][16], &m[15][16]), load(&m[14][17], &m[15][17]), load(&m[14][18], &m[15][18]), load(&m[14][19], &m[15][19]), load(&m[16][16], &m[17][16]), load(&m[16][17], &m[17][17]), load(&m[16][18], &m[17][18]), load(&m[16][19], &m[17][19]), load(&m[18][16], &m[19][16]), load(&m[18][17], &m[19][17]), load(&m[18][18], &m[19][18]), load(&m[18][19], &m[19][19]), load(&m[20][16], &m[21][16]), load(&m[20][17], &m[21][17]), load(&m[20][18], &m[21][18]), load(&m[20][19], &m[21][19]), load(&m[22][16], &m[23][16]), load(&m[22][17], &m[23][17]), load(&m[22][18], &m[23][18]), load(&m[22][19], &m[23][19]), load(&m[24][16], &m[25][16]), load(&m[24][17], &m[25][17]), load(&m[24][18], &m[25][18]), load(&m[24][19], &m[25][19]), load(&m[26][16], &m[27][16]), load(&m[26][17], &m[27][17]), load(&m[26][18], &m[27][18]), load(&m[26][19], &m[27][19]), load(&m[28][16], &m[29][16]), load(&m[28][17], &m[29][17]), load(&m[28][18], &m[29][18]), load(&m[28][19], &m[29][19]), load(&m[30][16], &m[31][16]), load(&m[30][17], &m[31][17]), load(&m[30][18], &m[31][18]), load(&m[30][19], &m[31][19]), load(&m[0][20], &m[1][20]), load(&m[0][21], &m[1][21]), load(&m[0][22], &m[1][22]), load(&m[0][23], &m[1][23]), load(&m[2][20], &m[3][20]), load(&m[2][21], &m[3][21]), load(&m[2][22], &m[3][22]), load(&m[2][23], &m[3][23]), load(&m[4][20], &m[5][20]), load(&m[4][21], &m[5][21]), load(&m[4][22], &m[5][22]), load(&m[4][23], &m[5][23]), load(&m[6][20], &m[7][20]), load(&m[6][21], &m[7][21]), load(&m[6][22], &m[7][22]), load(&m[6][23], &m[7][23]), load(&m[8][20], &m[9][20]), load(&m[8][21], &m[9][21]), load(&m[8][22], &m[9][22]), load(&m[8][23], &m[9][23]), load(&m[10][20], &m[11][20]), load(&m[10][21], &m[11][21]), load(&m[10][22], &m[11][22]), load(&m[10][23], &m[11][23]), load(&m[12][20], &m[13][20]), load(&m[12][21], &m[13][21]), load(&m[12][22], &m[13][22]), load(&m[12][23], &m[13][23]), load(&m[14][20], &m[15][20]), load(&m[14][21], &m[15][21]), load(&m[14][22], &m[15][22]), load(&m[14][23], &m[15][23]), load(&m[16][20], &m[17][20]), load(&m[16][21], &m[17][21]), load(&m[16][22], &m[17][22]), load(&m[16][23], &m[17][23]), load(&m[18][20], &m[19][20]), load(&m[18][21], &m[19][21]), load(&m[18][22], &m[19][22]), load(&m[18][23], &m[19][23]), load(&m[20][20], &m[21][20]), load(&m[20][21], &m[21][21]), load(&m[20][22], &m[21][22]), load(&m[20][23], &m[21][23]), load(&m[22][20], &m[23][20]), load(&m[22][21], &m[23][21]), load(&m[22][22], &m[23][22]), load(&m[22][23], &m[23][23]), load(&m[24][20], &m[25][20]), load(&m[24][21], &m[25][21]), load(&m[24][22], &m[25][22]), load(&m[24][23], &m[25][23]), load(&m[26][20], &m[27][20]), load(&m[26][21], &m[27][21]), load(&m[26][22], &m[27][22]), load(&m[26][23], &m[27][23]), load(&m[28][20], &m[29][20]), load(&m[28][21], &m[29][21]), load(&m[28][22], &m[29][22]), load(&m[28][23], &m[29][23]), load(&m[30][20], &m[31][20]), load(&m[30][21], &m[31][21]), load(&m[30][22], &m[31][22]), load(&m[30][23], &m[31][23]), load(&m[0][24], &m[1][24]), load(&m[0][25], &m[1][25]), load(&m[0][26], &m[1][26]), load(&m[0][27], &m[1][27]), load(&m[2][24], &m[3][24]), load(&m[2][25], &m[3][25]), load(&m[2][26], &m[3][26]), load(&m[2][27], &m[3][27]), load(&m[4][24], &m[5][24]), load(&m[4][25], &m[5][25]), load(&m[4][26], &m[5][26]), load(&m[4][27], &m[5][27]), load(&m[6][24], &m[7][24]), load(&m[6][25], &m[7][25]), load(&m[6][26], &m[7][26]), load(&m[6][27], &m[7][27]), load(&m[8][24], &m[9][24]), load(&m[8][25], &m[9][25]), load(&m[8][26], &m[9][26]), load(&m[8][27], &m[9][27]), load(&m[10][24], &m[11][24]), load(&m[10][25], &m[11][25]), load(&m[10][26], &m[11][26]), load(&m[10][27], &m[11][27]), load(&m[12][24], &m[13][24]), load(&m[12][25], &m[13][25]), load(&m[12][26], &m[13][26]), load(&m[12][27], &m[13][27]), load(&m[14][24], &m[15][24]), load(&m[14][25], &m[15][25]), load(&m[14][26], &m[15][26]), load(&m[14][27], &m[15][27]), load(&m[16][24], &m[17][24]), load(&m[16][25], &m[17][25]), load(&m[16][26], &m[17][26]), load(&m[16][27], &m[17][27]), load(&m[18][24], &m[19][24]), load(&m[18][25], &m[19][25]), load(&m[18][26], &m[19][26]), load(&m[18][27], &m[19][27]), load(&m[20][24], &m[21][24]), load(&m[20][25], &m[21][25]), load(&m[20][26], &m[21][26]), load(&m[20][27], &m[21][27]), load(&m[22][24], &m[23][24]), load(&m[22][25], &m[23][25]), load(&m[22][26], &m[23][26]), load(&m[22][27], &m[23][27]), load(&m[24][24], &m[25][24]), load(&m[24][25], &m[25][25]), load(&m[24][26], &m[25][26]), load(&m[24][27], &m[25][27]), load(&m[26][24], &m[27][24]), load(&m[26][25], &m[27][25]), load(&m[26][26], &m[27][26]), load(&m[26][27], &m[27][27]), load(&m[28][24], &m[29][24]), load(&m[28][25], &m[29][25]), load(&m[28][26], &m[29][26]), load(&m[28][27], &m[29][27]), load(&m[30][24], &m[31][24]), load(&m[30][25], &m[31][25]), load(&m[30][26], &m[31][26]), load(&m[30][27], &m[31][27]), load(&m[0][28], &m[1][28]), load(&m[0][29], &m[1][29]), load(&m[0][30], &m[1][30]), load(&m[0][31], &m[1][31]), load(&m[2][28], &m[3][28]), load(&m[2][29], &m[3][29]), load(&m[2][30], &m[3][30]), load(&m[2][31], &m[3][31]), load(&m[4][28], &m[5][28]), load(&m[4][29], &m[5][29]), load(&m[4][30], &m[5][30]), load(&m[4][31], &m[5][31]), load(&m[6][28], &m[7][28]), load(&m[6][29], &m[7][29]), load(&m[6][30], &m[7][30]), load(&m[6][31], &m[7][31]), load(&m[8][28], &m[9][28]), load(&m[8][29], &m[9][29]), load(&m[8][30], &m[9][30]), load(&m[8][31], &m[9][31]), load(&m[10][28], &m[11][28]), load(&m[10][29], &m[11][29]), load(&m[10][30], &m[11][30]), load(&m[10][31], &m[11][31]), load(&m[12][28], &m[13][28]), load(&m[12][29], &m[13][29]), load(&m[12][30], &m[13][30]), load(&m[12][31], &m[13][31]), load(&m[14][28], &m[15][28]), load(&m[14][29], &m[15][29]), load(&m[14][30], &m[15][30]), load(&m[14][31], &m[15][31]), load(&m[16][28], &m[17][28]), load(&m[16][29], &m[17][29]), load(&m[16][30], &m[17][30]), load(&m[16][31], &m[17][31]), load(&m[18][28], &m[19][28]), load(&m[18][29], &m[19][29]), load(&m[18][30], &m[19][30]), load(&m[18][31], &m[19][31]), load(&m[20][28], &m[21][28]), load(&m[20][29], &m[21][29]), load(&m[20][30], &m[21][30]), load(&m[20][31], &m[21][31]), load(&m[22][28], &m[23][28]), load(&m[22][29], &m[23][29]), load(&m[22][30], &m[23][30]), load(&m[22][31], &m[23][31]), load(&m[24][28], &m[25][28]), load(&m[24][29], &m[25][29]), load(&m[24][30], &m[25][30]), load(&m[24][31], &m[25][31]), load(&m[26][28], &m[27][28]), load(&m[26][29], &m[27][29]), load(&m[26][30], &m[27][30]), load(&m[26][31], &m[27][31]), load(&m[28][28], &m[29][28]), load(&m[28][29], &m[29][29]), load(&m[28][30], &m[29][30]), load(&m[28][31], &m[29][31]), load(&m[30][28], &m[31][28]), load(&m[30][29], &m[31][29]), load(&m[30][30], &m[31][30]), load(&m[30][31], &m[31][31])};
+    __m256d mm[] = {load(&m[0][0], &m[1][0]),     load(&m[0][1], &m[1][1]),     load(&m[0][2], &m[1][2]),
+                    load(&m[0][3], &m[1][3]),     load(&m[2][0], &m[3][0]),     load(&m[2][1], &m[3][1]),
+                    load(&m[2][2], &m[3][2]),     load(&m[2][3], &m[3][3]),     load(&m[4][0], &m[5][0]),
+                    load(&m[4][1], &m[5][1]),     load(&m[4][2], &m[5][2]),     load(&m[4][3], &m[5][3]),
+                    load(&m[6][0], &m[7][0]),     load(&m[6][1], &m[7][1]),     load(&m[6][2], &m[7][2]),
+                    load(&m[6][3], &m[7][3]),     load(&m[8][0], &m[9][0]),     load(&m[8][1], &m[9][1]),
+                    load(&m[8][2], &m[9][2]),     load(&m[8][3], &m[9][3]),     load(&m[10][0], &m[11][0]),
+                    load(&m[10][1], &m[11][1]),   load(&m[10][2], &m[11][2]),   load(&m[10][3], &m[11][3]),
+                    load(&m[12][0], &m[13][0]),   load(&m[12][1], &m[13][1]),   load(&m[12][2], &m[13][2]),
+                    load(&m[12][3], &m[13][3]),   load(&m[14][0], &m[15][0]),   load(&m[14][1], &m[15][1]),
+                    load(&m[14][2], &m[15][2]),   load(&m[14][3], &m[15][3]),   load(&m[16][0], &m[17][0]),
+                    load(&m[16][1], &m[17][1]),   load(&m[16][2], &m[17][2]),   load(&m[16][3], &m[17][3]),
+                    load(&m[18][0], &m[19][0]),   load(&m[18][1], &m[19][1]),   load(&m[18][2], &m[19][2]),
+                    load(&m[18][3], &m[19][3]),   load(&m[20][0], &m[21][0]),   load(&m[20][1], &m[21][1]),
+                    load(&m[20][2], &m[21][2]),   load(&m[20][3], &m[21][3]),   load(&m[22][0], &m[23][0]),
+                    load(&m[22][1], &m[23][1]),   load(&m[22][2], &m[23][2]),   load(&m[22][3], &m[23][3]),
+                    load(&m[24][0], &m[25][0]),   load(&m[24][1], &m[25][1]),   load(&m[24][2], &m[25][2]),
+                    load(&m[24][3], &m[25][3]),   load(&m[26][0], &m[27][0]),   load(&m[26][1], &m[27][1]),
+                    load(&m[26][2], &m[27][2]),   load(&m[26][3], &m[27][3]),   load(&m[28][0], &m[29][0]),
+                    load(&m[28][1], &m[29][1]),   load(&m[28][2], &m[29][2]),   load(&m[28][3], &m[29][3]),
+                    load(&m[30][0], &m[31][0]),   load(&m[30][1], &m[31][1]),   load(&m[30][2], &m[31][2]),
+                    load(&m[30][3], &m[31][3]),   load(&m[0][4], &m[1][4]),     load(&m[0][5], &m[1][5]),
+                    load(&m[0][6], &m[1][6]),     load(&m[0][7], &m[1][7]),     load(&m[2][4], &m[3][4]),
+                    load(&m[2][5], &m[3][5]),     load(&m[2][6], &m[3][6]),     load(&m[2][7], &m[3][7]),
+                    load(&m[4][4], &m[5][4]),     load(&m[4][5], &m[5][5]),     load(&m[4][6], &m[5][6]),
+                    load(&m[4][7], &m[5][7]),     load(&m[6][4], &m[7][4]),     load(&m[6][5], &m[7][5]),
+                    load(&m[6][6], &m[7][6]),     load(&m[6][7], &m[7][7]),     load(&m[8][4], &m[9][4]),
+                    load(&m[8][5], &m[9][5]),     load(&m[8][6], &m[9][6]),     load(&m[8][7], &m[9][7]),
+                    load(&m[10][4], &m[11][4]),   load(&m[10][5], &m[11][5]),   load(&m[10][6], &m[11][6]),
+                    load(&m[10][7], &m[11][7]),   load(&m[12][4], &m[13][4]),   load(&m[12][5], &m[13][5]),
+                    load(&m[12][6], &m[13][6]),   load(&m[12][7], &m[13][7]),   load(&m[14][4], &m[15][4]),
+                    load(&m[14][5], &m[15][5]),   load(&m[14][6], &m[15][6]),   load(&m[14][7], &m[15][7]),
+                    load(&m[16][4], &m[17][4]),   load(&m[16][5], &m[17][5]),   load(&m[16][6], &m[17][6]),
+                    load(&m[16][7], &m[17][7]),   load(&m[18][4], &m[19][4]),   load(&m[18][5], &m[19][5]),
+                    load(&m[18][6], &m[19][6]),   load(&m[18][7], &m[19][7]),   load(&m[20][4], &m[21][4]),
+                    load(&m[20][5], &m[21][5]),   load(&m[20][6], &m[21][6]),   load(&m[20][7], &m[21][7]),
+                    load(&m[22][4], &m[23][4]),   load(&m[22][5], &m[23][5]),   load(&m[22][6], &m[23][6]),
+                    load(&m[22][7], &m[23][7]),   load(&m[24][4], &m[25][4]),   load(&m[24][5], &m[25][5]),
+                    load(&m[24][6], &m[25][6]),   load(&m[24][7], &m[25][7]),   load(&m[26][4], &m[27][4]),
+                    load(&m[26][5], &m[27][5]),   load(&m[26][6], &m[27][6]),   load(&m[26][7], &m[27][7]),
+                    load(&m[28][4], &m[29][4]),   load(&m[28][5], &m[29][5]),   load(&m[28][6], &m[29][6]),
+                    load(&m[28][7], &m[29][7]),   load(&m[30][4], &m[31][4]),   load(&m[30][5], &m[31][5]),
+                    load(&m[30][6], &m[31][6]),   load(&m[30][7], &m[31][7]),   load(&m[0][8], &m[1][8]),
+                    load(&m[0][9], &m[1][9]),     load(&m[0][10], &m[1][10]),   load(&m[0][11], &m[1][11]),
+                    load(&m[2][8], &m[3][8]),     load(&m[2][9], &m[3][9]),     load(&m[2][10], &m[3][10]),
+                    load(&m[2][11], &m[3][11]),   load(&m[4][8], &m[5][8]),     load(&m[4][9], &m[5][9]),
+                    load(&m[4][10], &m[5][10]),   load(&m[4][11], &m[5][11]),   load(&m[6][8], &m[7][8]),
+                    load(&m[6][9], &m[7][9]),     load(&m[6][10], &m[7][10]),   load(&m[6][11], &m[7][11]),
+                    load(&m[8][8], &m[9][8]),     load(&m[8][9], &m[9][9]),     load(&m[8][10], &m[9][10]),
+                    load(&m[8][11], &m[9][11]),   load(&m[10][8], &m[11][8]),   load(&m[10][9], &m[11][9]),
+                    load(&m[10][10], &m[11][10]), load(&m[10][11], &m[11][11]), load(&m[12][8], &m[13][8]),
+                    load(&m[12][9], &m[13][9]),   load(&m[12][10], &m[13][10]), load(&m[12][11], &m[13][11]),
+                    load(&m[14][8], &m[15][8]),   load(&m[14][9], &m[15][9]),   load(&m[14][10], &m[15][10]),
+                    load(&m[14][11], &m[15][11]), load(&m[16][8], &m[17][8]),   load(&m[16][9], &m[17][9]),
+                    load(&m[16][10], &m[17][10]), load(&m[16][11], &m[17][11]), load(&m[18][8], &m[19][8]),
+                    load(&m[18][9], &m[19][9]),   load(&m[18][10], &m[19][10]), load(&m[18][11], &m[19][11]),
+                    load(&m[20][8], &m[21][8]),   load(&m[20][9], &m[21][9]),   load(&m[20][10], &m[21][10]),
+                    load(&m[20][11], &m[21][11]), load(&m[22][8], &m[23][8]),   load(&m[22][9], &m[23][9]),
+                    load(&m[22][10], &m[23][10]), load(&m[22][11], &m[23][11]), load(&m[24][8], &m[25][8]),
+                    load(&m[24][9], &m[25][9]),   load(&m[24][10], &m[25][10]), load(&m[24][11], &m[25][11]),
+                    load(&m[26][8], &m[27][8]),   load(&m[26][9], &m[27][9]),   load(&m[26][10], &m[27][10]),
+                    load(&m[26][11], &m[27][11]), load(&m[28][8], &m[29][8]),   load(&m[28][9], &m[29][9]),
+                    load(&m[28][10], &m[29][10]), load(&m[28][11], &m[29][11]), load(&m[30][8], &m[31][8]),
+                    load(&m[30][9], &m[31][9]),   load(&m[30][10], &m[31][10]), load(&m[30][11], &m[31][11]),
+                    load(&m[0][12], &m[1][12]),   load(&m[0][13], &m[1][13]),   load(&m[0][14], &m[1][14]),
+                    load(&m[0][15], &m[1][15]),   load(&m[2][12], &m[3][12]),   load(&m[2][13], &m[3][13]),
+                    load(&m[2][14], &m[3][14]),   load(&m[2][15], &m[3][15]),   load(&m[4][12], &m[5][12]),
+                    load(&m[4][13], &m[5][13]),   load(&m[4][14], &m[5][14]),   load(&m[4][15], &m[5][15]),
+                    load(&m[6][12], &m[7][12]),   load(&m[6][13], &m[7][13]),   load(&m[6][14], &m[7][14]),
+                    load(&m[6][15], &m[7][15]),   load(&m[8][12], &m[9][12]),   load(&m[8][13], &m[9][13]),
+                    load(&m[8][14], &m[9][14]),   load(&m[8][15], &m[9][15]),   load(&m[10][12], &m[11][12]),
+                    load(&m[10][13], &m[11][13]), load(&m[10][14], &m[11][14]), load(&m[10][15], &m[11][15]),
+                    load(&m[12][12], &m[13][12]), load(&m[12][13], &m[13][13]), load(&m[12][14], &m[13][14]),
+                    load(&m[12][15], &m[13][15]), load(&m[14][12], &m[15][12]), load(&m[14][13], &m[15][13]),
+                    load(&m[14][14], &m[15][14]), load(&m[14][15], &m[15][15]), load(&m[16][12], &m[17][12]),
+                    load(&m[16][13], &m[17][13]), load(&m[16][14], &m[17][14]), load(&m[16][15], &m[17][15]),
+                    load(&m[18][12], &m[19][12]), load(&m[18][13], &m[19][13]), load(&m[18][14], &m[19][14]),
+                    load(&m[18][15], &m[19][15]), load(&m[20][12], &m[21][12]), load(&m[20][13], &m[21][13]),
+                    load(&m[20][14], &m[21][14]), load(&m[20][15], &m[21][15]), load(&m[22][12], &m[23][12]),
+                    load(&m[22][13], &m[23][13]), load(&m[22][14], &m[23][14]), load(&m[22][15], &m[23][15]),
+                    load(&m[24][12], &m[25][12]), load(&m[24][13], &m[25][13]), load(&m[24][14], &m[25][14]),
+                    load(&m[24][15], &m[25][15]), load(&m[26][12], &m[27][12]), load(&m[26][13], &m[27][13]),
+                    load(&m[26][14], &m[27][14]), load(&m[26][15], &m[27][15]), load(&m[28][12], &m[29][12]),
+                    load(&m[28][13], &m[29][13]), load(&m[28][14], &m[29][14]), load(&m[28][15], &m[29][15]),
+                    load(&m[30][12], &m[31][12]), load(&m[30][13], &m[31][13]), load(&m[30][14], &m[31][14]),
+                    load(&m[30][15], &m[31][15]), load(&m[0][16], &m[1][16]),   load(&m[0][17], &m[1][17]),
+                    load(&m[0][18], &m[1][18]),   load(&m[0][19], &m[1][19]),   load(&m[2][16], &m[3][16]),
+                    load(&m[2][17], &m[3][17]),   load(&m[2][18], &m[3][18]),   load(&m[2][19], &m[3][19]),
+                    load(&m[4][16], &m[5][16]),   load(&m[4][17], &m[5][17]),   load(&m[4][18], &m[5][18]),
+                    load(&m[4][19], &m[5][19]),   load(&m[6][16], &m[7][16]),   load(&m[6][17], &m[7][17]),
+                    load(&m[6][18], &m[7][18]),   load(&m[6][19], &m[7][19]),   load(&m[8][16], &m[9][16]),
+                    load(&m[8][17], &m[9][17]),   load(&m[8][18], &m[9][18]),   load(&m[8][19], &m[9][19]),
+                    load(&m[10][16], &m[11][16]), load(&m[10][17], &m[11][17]), load(&m[10][18], &m[11][18]),
+                    load(&m[10][19], &m[11][19]), load(&m[12][16], &m[13][16]), load(&m[12][17], &m[13][17]),
+                    load(&m[12][18], &m[13][18]), load(&m[12][19], &m[13][19]), load(&m[14][16], &m[15][16]),
+                    load(&m[14][17], &m[15][17]), load(&m[14][18], &m[15][18]), load(&m[14][19], &m[15][19]),
+                    load(&m[16][16], &m[17][16]), load(&m[16][17], &m[17][17]), load(&m[16][18], &m[17][18]),
+                    load(&m[16][19], &m[17][19]), load(&m[18][16], &m[19][16]), load(&m[18][17], &m[19][17]),
+                    load(&m[18][18], &m[19][18]), load(&m[18][19], &m[19][19]), load(&m[20][16], &m[21][16]),
+                    load(&m[20][17], &m[21][17]), load(&m[20][18], &m[21][18]), load(&m[20][19], &m[21][19]),
+                    load(&m[22][16], &m[23][16]), load(&m[22][17], &m[23][17]), load(&m[22][18], &m[23][18]),
+                    load(&m[22][19], &m[23][19]), load(&m[24][16], &m[25][16]), load(&m[24][17], &m[25][17]),
+                    load(&m[24][18], &m[25][18]), load(&m[24][19], &m[25][19]), load(&m[26][16], &m[27][16]),
+                    load(&m[26][17], &m[27][17]), load(&m[26][18], &m[27][18]), load(&m[26][19], &m[27][19]),
+                    load(&m[28][16], &m[29][16]), load(&m[28][17], &m[29][17]), load(&m[28][18], &m[29][18]),
+                    load(&m[28][19], &m[29][19]), load(&m[30][16], &m[31][16]), load(&m[30][17], &m[31][17]),
+                    load(&m[30][18], &m[31][18]), load(&m[30][19], &m[31][19]), load(&m[0][20], &m[1][20]),
+                    load(&m[0][21], &m[1][21]),   load(&m[0][22], &m[1][22]),   load(&m[0][23], &m[1][23]),
+                    load(&m[2][20], &m[3][20]),   load(&m[2][21], &m[3][21]),   load(&m[2][22], &m[3][22]),
+                    load(&m[2][23], &m[3][23]),   load(&m[4][20], &m[5][20]),   load(&m[4][21], &m[5][21]),
+                    load(&m[4][22], &m[5][22]),   load(&m[4][23], &m[5][23]),   load(&m[6][20], &m[7][20]),
+                    load(&m[6][21], &m[7][21]),   load(&m[6][22], &m[7][22]),   load(&m[6][23], &m[7][23]),
+                    load(&m[8][20], &m[9][20]),   load(&m[8][21], &m[9][21]),   load(&m[8][22], &m[9][22]),
+                    load(&m[8][23], &m[9][23]),   load(&m[10][20], &m[11][20]), load(&m[10][21], &m[11][21]),
+                    load(&m[10][22], &m[11][22]), load(&m[10][23], &m[11][23]), load(&m[12][20], &m[13][20]),
+                    load(&m[12][21], &m[13][21]), load(&m[12][22], &m[13][22]), load(&m[12][23], &m[13][23]),
+                    load(&m[14][20], &m[15][20]), load(&m[14][21], &m[15][21]), load(&m[14][22], &m[15][22]),
+                    load(&m[14][23], &m[15][23]), load(&m[16][20], &m[17][20]), load(&m[16][21], &m[17][21]),
+                    load(&m[16][22], &m[17][22]), load(&m[16][23], &m[17][23]), load(&m[18][20], &m[19][20]),
+                    load(&m[18][21], &m[19][21]), load(&m[18][22], &m[19][22]), load(&m[18][23], &m[19][23]),
+                    load(&m[20][20], &m[21][20]), load(&m[20][21], &m[21][21]), load(&m[20][22], &m[21][22]),
+                    load(&m[20][23], &m[21][23]), load(&m[22][20], &m[23][20]), load(&m[22][21], &m[23][21]),
+                    load(&m[22][22], &m[23][22]), load(&m[22][23], &m[23][23]), load(&m[24][20], &m[25][20]),
+                    load(&m[24][21], &m[25][21]), load(&m[24][22], &m[25][22]), load(&m[24][23], &m[25][23]),
+                    load(&m[26][20], &m[27][20]), load(&m[26][21], &m[27][21]), load(&m[26][22], &m[27][22]),
+                    load(&m[26][23], &m[27][23]), load(&m[28][20], &m[29][20]), load(&m[28][21], &m[29][21]),
+                    load(&m[28][22], &m[29][22]), load(&m[28][23], &m[29][23]), load(&m[30][20], &m[31][20]),
+                    load(&m[30][21], &m[31][21]), load(&m[30][22], &m[31][22]), load(&m[30][23], &m[31][23]),
+                    load(&m[0][24], &m[1][24]),   load(&m[0][25], &m[1][25]),   load(&m[0][26], &m[1][26]),
+                    load(&m[0][27], &m[1][27]),   load(&m[2][24], &m[3][24]),   load(&m[2][25], &m[3][25]),
+                    load(&m[2][26], &m[3][26]),   load(&m[2][27], &m[3][27]),   load(&m[4][24], &m[5][24]),
+                    load(&m[4][25], &m[5][25]),   load(&m[4][26], &m[5][26]),   load(&m[4][27], &m[5][27]),
+                    load(&m[6][24], &m[7][24]),   load(&m[6][25], &m[7][25]),   load(&m[6][26], &m[7][26]),
+                    load(&m[6][27], &m[7][27]),   load(&m[8][24], &m[9][24]),   load(&m[8][25], &m[9][25]),
+                    load(&m[8][26], &m[9][26]),   load(&m[8][27], &m[9][27]),   load(&m[10][24], &m[11][24]),
+                    load(&m[10][25], &m[11][25]), load(&m[10][26], &m[11][26]), load(&m[10][27], &m[11][27]),
+                    load(&m[12][24], &m[13][24]), load(&m[12][25], &m[13][25]), load(&m[12][26], &m[13][26]),
+                    load(&m[12][27], &m[13][27]), load(&m[14][24], &m[15][24]), load(&m[14][25], &m[15][25]),
+                    load(&m[14][26], &m[15][26]), load(&m[14][27], &m[15][27]), load(&m[16][24], &m[17][24]),
+                    load(&m[16][25], &m[17][25]), load(&m[16][26], &m[17][26]), load(&m[16][27], &m[17][27]),
+                    load(&m[18][24], &m[19][24]), load(&m[18][25], &m[19][25]), load(&m[18][26], &m[19][26]),
+                    load(&m[18][27], &m[19][27]), load(&m[20][24], &m[21][24]), load(&m[20][25], &m[21][25]),
+                    load(&m[20][26], &m[21][26]), load(&m[20][27], &m[21][27]), load(&m[22][24], &m[23][24]),
+                    load(&m[22][25], &m[23][25]), load(&m[22][26], &m[23][26]), load(&m[22][27], &m[23][27]),
+                    load(&m[24][24], &m[25][24]), load(&m[24][25], &m[25][25]), load(&m[24][26], &m[25][26]),
+                    load(&m[24][27], &m[25][27]), load(&m[26][24], &m[27][24]), load(&m[26][25], &m[27][25]),
+                    load(&m[26][26], &m[27][26]), load(&m[26][27], &m[27][27]), load(&m[28][24], &m[29][24]),
+                    load(&m[28][25], &m[29][25]), load(&m[28][26], &m[29][26]), load(&m[28][27], &m[29][27]),
+                    load(&m[30][24], &m[31][24]), load(&m[30][25], &m[31][25]), load(&m[30][26], &m[31][26]),
+                    load(&m[30][27], &m[31][27]), load(&m[0][28], &m[1][28]),   load(&m[0][29], &m[1][29]),
+                    load(&m[0][30], &m[1][30]),   load(&m[0][31], &m[1][31]),   load(&m[2][28], &m[3][28]),
+                    load(&m[2][29], &m[3][29]),   load(&m[2][30], &m[3][30]),   load(&m[2][31], &m[3][31]),
+                    load(&m[4][28], &m[5][28]),   load(&m[4][29], &m[5][29]),   load(&m[4][30], &m[5][30]),
+                    load(&m[4][31], &m[5][31]),   load(&m[6][28], &m[7][28]),   load(&m[6][29], &m[7][29]),
+                    load(&m[6][30], &m[7][30]),   load(&m[6][31], &m[7][31]),   load(&m[8][28], &m[9][28]),
+                    load(&m[8][29], &m[9][29]),   load(&m[8][30], &m[9][30]),   load(&m[8][31], &m[9][31]),
+                    load(&m[10][28], &m[11][28]), load(&m[10][29], &m[11][29]), load(&m[10][30], &m[11][30]),
+                    load(&m[10][31], &m[11][31]), load(&m[12][28], &m[13][28]), load(&m[12][29], &m[13][29]),
+                    load(&m[12][30], &m[13][30]), load(&m[12][31], &m[13][31]), load(&m[14][28], &m[15][28]),
+                    load(&m[14][29], &m[15][29]), load(&m[14][30], &m[15][30]), load(&m[14][31], &m[15][31]),
+                    load(&m[16][28], &m[17][28]), load(&m[16][29], &m[17][29]), load(&m[16][30], &m[17][30]),
+                    load(&m[16][31], &m[17][31]), load(&m[18][28], &m[19][28]), load(&m[18][29], &m[19][29]),
+                    load(&m[18][30], &m[19][30]), load(&m[18][31], &m[19][31]), load(&m[20][28], &m[21][28]),
+                    load(&m[20][29], &m[21][29]), load(&m[20][30], &m[21][30]), load(&m[20][31], &m[21][31]),
+                    load(&m[22][28], &m[23][28]), load(&m[22][29], &m[23][29]), load(&m[22][30], &m[23][30]),
+                    load(&m[22][31], &m[23][31]), load(&m[24][28], &m[25][28]), load(&m[24][29], &m[25][29]),
+                    load(&m[24][30], &m[25][30]), load(&m[24][31], &m[25][31]), load(&m[26][28], &m[27][28]),
+                    load(&m[26][29], &m[27][29]), load(&m[26][30], &m[27][30]), load(&m[26][31], &m[27][31]),
+                    load(&m[28][28], &m[29][28]), load(&m[28][29], &m[29][29]), load(&m[28][30], &m[29][30]),
+                    load(&m[28][31], &m[29][31]), load(&m[30][28], &m[31][28]), load(&m[30][29], &m[31][29]),
+                    load(&m[30][30], &m[31][30]), load(&m[30][31], &m[31][31])};
     __m256d mmt[512];
 
     __m256d neg = _mm256_setr_pd(1.0, -1.0, 1.0, -1.0);
-    for (unsigned i = 0; i < 512; ++i){
+    for (unsigned i = 0; i < 512; ++i) {
         auto badc = _mm256_permute_pd(mm[i], 5);
         mmt[i] = _mm256_mul_pd(badc, neg);
     }
 
-    std::size_t dsorted[] = {d0 , d1, d2, d3, d4};
+    std::size_t dsorted[] = {d0, d1, d2, d3, d4};
     std::sort(dsorted, dsorted + 5, std::greater<std::size_t>());
 
-    if (ctrlmask == 0){
-        #pragma omp for collapse(LOOP_COLLAPSE5) schedule(static)
-        for (std::size_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]){
-            for (std::size_t i1 = 0; i1 < dsorted[0]; i1 += 2 * dsorted[1]){
-                for (std::size_t i2 = 0; i2 < dsorted[1]; i2 += 2 * dsorted[2]){
-                    for (std::size_t i3 = 0; i3 < dsorted[2]; i3 += 2 * dsorted[3]){
-                        for (std::size_t i4 = 0; i4 < dsorted[3]; i4 += 2 * dsorted[4]){
-                            for (std::size_t i5 = 0; i5 < dsorted[4]; ++i5){
+    if (ctrlmask == 0) {
+#pragma omp for collapse(LOOP_COLLAPSE5) schedule(static)
+        for (omp::idx_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]) {
+            for (omp::idx_t i1 = 0; i1 < dsorted[0]; i1 += 2 * dsorted[1]) {
+                for (omp::idx_t i2 = 0; i2 < dsorted[1]; i2 += 2 * dsorted[2]) {
+                    for (omp::idx_t i3 = 0; i3 < dsorted[2]; i3 += 2 * dsorted[3]) {
+                        for (omp::idx_t i4 = 0; i4 < dsorted[3]; i4 += 2 * dsorted[4]) {
+                            for (omp::idx_t i5 = 0; i5 < dsorted[4]; ++i5) {
                                 kernel_core(psi, i0 + i1 + i2 + i3 + i4 + i5, d0, d1, d2, d3, d4, mm, mmt);
                             }
                         }
@@ -235,16 +651,15 @@ void kernel(V &psi, unsigned id4, unsign
                 }
             }
         }
-    }
-    else{
-        #pragma omp for collapse(LOOP_COLLAPSE5) schedule(static)
-        for (std::size_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]){
-            for (std::size_t i1 = 0; i1 < dsorted[0]; i1 += 2 * dsorted[1]){
-                for (std::size_t i2 = 0; i2 < dsorted[1]; i2 += 2 * dsorted[2]){
-                    for (std::size_t i3 = 0; i3 < dsorted[2]; i3 += 2 * dsorted[3]){
-                        for (std::size_t i4 = 0; i4 < dsorted[3]; i4 += 2 * dsorted[4]){
-                            for (std::size_t i5 = 0; i5 < dsorted[4]; ++i5){
-                                if (((i0 + i1 + i2 + i3 + i4 + i5)&ctrlmask) == ctrlmask)
+    } else {
+#pragma omp for collapse(LOOP_COLLAPSE5) schedule(static)
+        for (omp::idx_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]) {
+            for (omp::idx_t i1 = 0; i1 < dsorted[0]; i1 += 2 * dsorted[1]) {
+                for (omp::idx_t i2 = 0; i2 < dsorted[1]; i2 += 2 * dsorted[2]) {
+                    for (omp::idx_t i3 = 0; i3 < dsorted[2]; i3 += 2 * dsorted[3]) {
+                        for (omp::idx_t i4 = 0; i4 < dsorted[3]; i4 += 2 * dsorted[4]) {
+                            for (omp::idx_t i5 = 0; i5 < dsorted[4]; ++i5) {
+                                if (((i0 + i1 + i2 + i3 + i4 + i5) & ctrlmask) == ctrlmask)
                                     kernel_core(psi, i0 + i1 + i2 + i3 + i4 + i5, d0, d1, d2, d3, d4, mm, mmt);
                             }
                         }
diff -Npur projectq-orig/projectq/backends/_sim/_cppkernels/intrin/kernels.hpp projectq-new/projectq/backends/_sim/_cppkernels/intrin/kernels.hpp
--- projectq-orig/projectq/backends/_sim/_cppkernels/intrin/kernels.hpp	2022-04-27 11:49:17.000000000 +0200
+++ projectq-new/projectq/backends/_sim/_cppkernels/intrin/kernels.hpp	2022-06-17 12:37:17.816198916 +0200
@@ -13,13 +13,16 @@
 // limitations under the License.
 
 #include <cmath>
-#include <cstdlib>
-#include <vector>
+
+#include <algorithm>
 #include <complex>
+#include <cstdlib>
 #include <functional>
-#include <algorithm>
-#include "cintrin.hpp"
+#include <vector>
+
 #include "alignedallocator.hpp"
+#include "cintrin.hpp"
+#include "config/openmp.hpp"
 
 #define LOOP_COLLAPSE1 2
 #define LOOP_COLLAPSE2 3
diff -Npur projectq-orig/projectq/backends/_sim/_cppkernels/nointrin/kernel1.hpp projectq-new/projectq/backends/_sim/_cppkernels/nointrin/kernel1.hpp
--- projectq-orig/projectq/backends/_sim/_cppkernels/nointrin/kernel1.hpp	2022-04-27 11:49:17.000000000 +0200
+++ projectq-new/projectq/backends/_sim/_cppkernels/nointrin/kernel1.hpp	2022-06-17 12:37:17.816198916 +0200
@@ -13,39 +13,35 @@
 // limitations under the License.
 
 template <class V, class M>
-inline void kernel_core(V &psi, std::size_t I, std::size_t d0, M const& m)
-{
+inline void kernel_core(V& psi, std::size_t I, std::size_t d0, M const& m) {
     std::complex<double> v[2];
     v[0] = psi[I];
     v[1] = psi[I + d0];
 
     psi[I] = (add(mul(v[0], m[0][0]), mul(v[1], m[0][1])));
     psi[I + d0] = (add(mul(v[0], m[1][0]), mul(v[1], m[1][1])));
-
 }
 
 // bit indices id[.] are given from high to low (e.g. control first for CNOT)
 template <class V, class M>
-void kernel(V &psi, unsigned id0, M const& m, std::size_t ctrlmask)
-{
+void kernel(V& psi, unsigned id0, M const& m, std::size_t ctrlmask) {
     std::size_t n = psi.size();
     std::size_t d0 = 1UL << id0;
-    std::size_t dsorted[] = {d0 };
+    std::size_t dsorted[] = {d0};
     std::sort(dsorted, dsorted + 1, std::greater<std::size_t>());
 
-    if (ctrlmask == 0){
-        #pragma omp for collapse(LOOP_COLLAPSE1) schedule(static)
-        for (std::size_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]){
-            for (std::size_t i1 = 0; i1 < dsorted[0]; ++i1){
+    if (ctrlmask == 0) {
+#pragma omp for collapse(LOOP_COLLAPSE1) schedule(static)
+        for (omp::idx_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]) {
+            for (std::size_t i1 = 0; i1 < dsorted[0]; ++i1) {
                 kernel_core(psi, i0 + i1, d0, m);
             }
         }
-    }
-    else{
-        #pragma omp for collapse(LOOP_COLLAPSE1) schedule(static)
-        for (std::size_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]){
-            for (std::size_t i1 = 0; i1 < dsorted[0]; ++i1){
-                if (((i0 + i1)&ctrlmask) == ctrlmask)
+    } else {
+#pragma omp for collapse(LOOP_COLLAPSE1) schedule(static)
+        for (omp::idx_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]) {
+            for (omp::idx_t i1 = 0; i1 < dsorted[0]; ++i1) {
+                if (((i0 + i1) & ctrlmask) == ctrlmask)
                     kernel_core(psi, i0 + i1, d0, m);
             }
         }
diff -Npur projectq-orig/projectq/backends/_sim/_cppkernels/nointrin/kernel2.hpp projectq-new/projectq/backends/_sim/_cppkernels/nointrin/kernel2.hpp
--- projectq-orig/projectq/backends/_sim/_cppkernels/nointrin/kernel2.hpp	2022-04-27 11:49:17.000000000 +0200
+++ projectq-new/projectq/backends/_sim/_cppkernels/nointrin/kernel2.hpp	2022-06-17 12:37:17.816198916 +0200
@@ -13,8 +13,7 @@
 // limitations under the License.
 
 template <class V, class M>
-inline void kernel_core(V &psi, std::size_t I, std::size_t d0, std::size_t d1, M const& m)
-{
+inline void kernel_core(V& psi, std::size_t I, std::size_t d0, std::size_t d1, M const& m) {
     std::complex<double> v[4];
     v[0] = psi[I];
     v[1] = psi[I + d0];
@@ -25,35 +24,32 @@ inline void kernel_core(V &psi, std::siz
     psi[I + d0] = (add(mul(v[0], m[1][0]), add(mul(v[1], m[1][1]), add(mul(v[2], m[1][2]), mul(v[3], m[1][3])))));
     psi[I + d1] = (add(mul(v[0], m[2][0]), add(mul(v[1], m[2][1]), add(mul(v[2], m[2][2]), mul(v[3], m[2][3])))));
     psi[I + d0 + d1] = (add(mul(v[0], m[3][0]), add(mul(v[1], m[3][1]), add(mul(v[2], m[3][2]), mul(v[3], m[3][3])))));
-
 }
 
 // bit indices id[.] are given from high to low (e.g. control first for CNOT)
 template <class V, class M>
-void kernel(V &psi, unsigned id1, unsigned id0, M const& m, std::size_t ctrlmask)
-{
+void kernel(V& psi, unsigned id1, unsigned id0, M const& m, std::size_t ctrlmask) {
     std::size_t n = psi.size();
     std::size_t d0 = 1UL << id0;
     std::size_t d1 = 1UL << id1;
-    std::size_t dsorted[] = {d0 , d1};
+    std::size_t dsorted[] = {d0, d1};
     std::sort(dsorted, dsorted + 2, std::greater<std::size_t>());
 
-    if (ctrlmask == 0){
-        #pragma omp for collapse(LOOP_COLLAPSE2) schedule(static)
-        for (std::size_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]){
-            for (std::size_t i1 = 0; i1 < dsorted[0]; i1 += 2 * dsorted[1]){
-                for (std::size_t i2 = 0; i2 < dsorted[1]; ++i2){
+    if (ctrlmask == 0) {
+#pragma omp for collapse(LOOP_COLLAPSE2) schedule(static)
+        for (omp::idx_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]) {
+            for (omp::idx_t i1 = 0; i1 < dsorted[0]; i1 += 2 * dsorted[1]) {
+                for (omp::idx_t i2 = 0; i2 < dsorted[1]; ++i2) {
                     kernel_core(psi, i0 + i1 + i2, d0, d1, m);
                 }
             }
         }
-    }
-    else{
-        #pragma omp for collapse(LOOP_COLLAPSE2) schedule(static)
-        for (std::size_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]){
-            for (std::size_t i1 = 0; i1 < dsorted[0]; i1 += 2 * dsorted[1]){
-                for (std::size_t i2 = 0; i2 < dsorted[1]; ++i2){
-                    if (((i0 + i1 + i2)&ctrlmask) == ctrlmask)
+    } else {
+#pragma omp for collapse(LOOP_COLLAPSE2) schedule(static)
+        for (omp::idx_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]) {
+            for (omp::idx_t i1 = 0; i1 < dsorted[0]; i1 += 2 * dsorted[1]) {
+                for (omp::idx_t i2 = 0; i2 < dsorted[1]; ++i2) {
+                    if (((i0 + i1 + i2) & ctrlmask) == ctrlmask)
                         kernel_core(psi, i0 + i1 + i2, d0, d1, m);
                 }
             }
diff -Npur projectq-orig/projectq/backends/_sim/_cppkernels/nointrin/kernel3.hpp projectq-new/projectq/backends/_sim/_cppkernels/nointrin/kernel3.hpp
--- projectq-orig/projectq/backends/_sim/_cppkernels/nointrin/kernel3.hpp	2022-04-27 11:49:17.000000000 +0200
+++ projectq-new/projectq/backends/_sim/_cppkernels/nointrin/kernel3.hpp	2022-06-17 12:37:17.816198916 +0200
@@ -13,8 +13,7 @@
 // limitations under the License.
 
 template <class V, class M>
-inline void kernel_core(V &psi, std::size_t I, std::size_t d0, std::size_t d1, std::size_t d2, M const& m)
-{
+inline void kernel_core(V& psi, std::size_t I, std::size_t d0, std::size_t d1, std::size_t d2, M const& m) {
     std::complex<double> v[4];
     v[0] = psi[I];
     v[1] = psi[I + d0];
@@ -37,47 +36,52 @@ inline void kernel_core(V &psi, std::siz
     v[2] = psi[I + d1 + d2];
     v[3] = psi[I + d0 + d1 + d2];
 
-    psi[I] = (add(tmp[0], add(mul(v[0], m[0][4]), add(mul(v[1], m[0][5]), add(mul(v[2], m[0][6]), mul(v[3], m[0][7]))))));
-    psi[I + d0] = (add(tmp[1], add(mul(v[0], m[1][4]), add(mul(v[1], m[1][5]), add(mul(v[2], m[1][6]), mul(v[3], m[1][7]))))));
-    psi[I + d1] = (add(tmp[2], add(mul(v[0], m[2][4]), add(mul(v[1], m[2][5]), add(mul(v[2], m[2][6]), mul(v[3], m[2][7]))))));
-    psi[I + d0 + d1] = (add(tmp[3], add(mul(v[0], m[3][4]), add(mul(v[1], m[3][5]), add(mul(v[2], m[3][6]), mul(v[3], m[3][7]))))));
-    psi[I + d2] = (add(tmp[4], add(mul(v[0], m[4][4]), add(mul(v[1], m[4][5]), add(mul(v[2], m[4][6]), mul(v[3], m[4][7]))))));
-    psi[I + d0 + d2] = (add(tmp[5], add(mul(v[0], m[5][4]), add(mul(v[1], m[5][5]), add(mul(v[2], m[5][6]), mul(v[3], m[5][7]))))));
-    psi[I + d1 + d2] = (add(tmp[6], add(mul(v[0], m[6][4]), add(mul(v[1], m[6][5]), add(mul(v[2], m[6][6]), mul(v[3], m[6][7]))))));
-    psi[I + d0 + d1 + d2] = (add(tmp[7], add(mul(v[0], m[7][4]), add(mul(v[1], m[7][5]), add(mul(v[2], m[7][6]), mul(v[3], m[7][7]))))));
-
+    psi[I]
+        = (add(tmp[0], add(mul(v[0], m[0][4]), add(mul(v[1], m[0][5]), add(mul(v[2], m[0][6]), mul(v[3], m[0][7]))))));
+    psi[I + d0]
+        = (add(tmp[1], add(mul(v[0], m[1][4]), add(mul(v[1], m[1][5]), add(mul(v[2], m[1][6]), mul(v[3], m[1][7]))))));
+    psi[I + d1]
+        = (add(tmp[2], add(mul(v[0], m[2][4]), add(mul(v[1], m[2][5]), add(mul(v[2], m[2][6]), mul(v[3], m[2][7]))))));
+    psi[I + d0 + d1]
+        = (add(tmp[3], add(mul(v[0], m[3][4]), add(mul(v[1], m[3][5]), add(mul(v[2], m[3][6]), mul(v[3], m[3][7]))))));
+    psi[I + d2]
+        = (add(tmp[4], add(mul(v[0], m[4][4]), add(mul(v[1], m[4][5]), add(mul(v[2], m[4][6]), mul(v[3], m[4][7]))))));
+    psi[I + d0 + d2]
+        = (add(tmp[5], add(mul(v[0], m[5][4]), add(mul(v[1], m[5][5]), add(mul(v[2], m[5][6]), mul(v[3], m[5][7]))))));
+    psi[I + d1 + d2]
+        = (add(tmp[6], add(mul(v[0], m[6][4]), add(mul(v[1], m[6][5]), add(mul(v[2], m[6][6]), mul(v[3], m[6][7]))))));
+    psi[I + d0 + d1 + d2]
+        = (add(tmp[7], add(mul(v[0], m[7][4]), add(mul(v[1], m[7][5]), add(mul(v[2], m[7][6]), mul(v[3], m[7][7]))))));
 }
 
 // bit indices id[.] are given from high to low (e.g. control first for CNOT)
 template <class V, class M>
-void kernel(V &psi, unsigned id2, unsigned id1, unsigned id0, M const& m, std::size_t ctrlmask)
-{
+void kernel(V& psi, unsigned id2, unsigned id1, unsigned id0, M const& m, std::size_t ctrlmask) {
     std::size_t n = psi.size();
     std::size_t d0 = 1UL << id0;
     std::size_t d1 = 1UL << id1;
     std::size_t d2 = 1UL << id2;
-    std::size_t dsorted[] = {d0 , d1, d2};
+    std::size_t dsorted[] = {d0, d1, d2};
     std::sort(dsorted, dsorted + 3, std::greater<std::size_t>());
 
-    if (ctrlmask == 0){
-        #pragma omp for collapse(LOOP_COLLAPSE3) schedule(static)
-        for (std::size_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]){
-            for (std::size_t i1 = 0; i1 < dsorted[0]; i1 += 2 * dsorted[1]){
-                for (std::size_t i2 = 0; i2 < dsorted[1]; i2 += 2 * dsorted[2]){
-                    for (std::size_t i3 = 0; i3 < dsorted[2]; ++i3){
+    if (ctrlmask == 0) {
+#pragma omp for collapse(LOOP_COLLAPSE3) schedule(static)
+        for (omp::idx_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]) {
+            for (omp::idx_t i1 = 0; i1 < dsorted[0]; i1 += 2 * dsorted[1]) {
+                for (omp::idx_t i2 = 0; i2 < dsorted[1]; i2 += 2 * dsorted[2]) {
+                    for (omp::idx_t i3 = 0; i3 < dsorted[2]; ++i3) {
                         kernel_core(psi, i0 + i1 + i2 + i3, d0, d1, d2, m);
                     }
                 }
             }
         }
-    }
-    else{
-        #pragma omp for collapse(LOOP_COLLAPSE3) schedule(static)
-        for (std::size_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]){
-            for (std::size_t i1 = 0; i1 < dsorted[0]; i1 += 2 * dsorted[1]){
-                for (std::size_t i2 = 0; i2 < dsorted[1]; i2 += 2 * dsorted[2]){
-                    for (std::size_t i3 = 0; i3 < dsorted[2]; ++i3){
-                        if (((i0 + i1 + i2 + i3)&ctrlmask) == ctrlmask)
+    } else {
+#pragma omp for collapse(LOOP_COLLAPSE3) schedule(static)
+        for (omp::idx_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]) {
+            for (omp::idx_t i1 = 0; i1 < dsorted[0]; i1 += 2 * dsorted[1]) {
+                for (omp::idx_t i2 = 0; i2 < dsorted[1]; i2 += 2 * dsorted[2]) {
+                    for (omp::idx_t i3 = 0; i3 < dsorted[2]; ++i3) {
+                        if (((i0 + i1 + i2 + i3) & ctrlmask) == ctrlmask)
                             kernel_core(psi, i0 + i1 + i2 + i3, d0, d1, d2, m);
                     }
                 }
diff -Npur projectq-orig/projectq/backends/_sim/_cppkernels/nointrin/kernel4.hpp projectq-new/projectq/backends/_sim/_cppkernels/nointrin/kernel4.hpp
--- projectq-orig/projectq/backends/_sim/_cppkernels/nointrin/kernel4.hpp	2022-04-27 11:49:17.000000000 +0200
+++ projectq-new/projectq/backends/_sim/_cppkernels/nointrin/kernel4.hpp	2022-06-17 12:37:17.816198916 +0200
@@ -13,8 +13,8 @@
 // limitations under the License.
 
 template <class V, class M>
-inline void kernel_core(V &psi, std::size_t I, std::size_t d0, std::size_t d1, std::size_t d2, std::size_t d3, M const& m)
-{
+inline void kernel_core(V& psi, std::size_t I, std::size_t d0, std::size_t d1, std::size_t d2, std::size_t d3,
+                        M const& m) {
     std::complex<double> v[4];
     v[0] = psi[I];
     v[1] = psi[I + d0];
@@ -55,93 +55,132 @@ inline void kernel_core(V &psi, std::siz
     tmp[7] = add(tmp[7], add(mul(v[0], m[7][4]), add(mul(v[1], m[7][5]), add(mul(v[2], m[7][6]), mul(v[3], m[7][7])))));
     tmp[8] = add(tmp[8], add(mul(v[0], m[8][4]), add(mul(v[1], m[8][5]), add(mul(v[2], m[8][6]), mul(v[3], m[8][7])))));
     tmp[9] = add(tmp[9], add(mul(v[0], m[9][4]), add(mul(v[1], m[9][5]), add(mul(v[2], m[9][6]), mul(v[3], m[9][7])))));
-    tmp[10] = add(tmp[10], add(mul(v[0], m[10][4]), add(mul(v[1], m[10][5]), add(mul(v[2], m[10][6]), mul(v[3], m[10][7])))));
-    tmp[11] = add(tmp[11], add(mul(v[0], m[11][4]), add(mul(v[1], m[11][5]), add(mul(v[2], m[11][6]), mul(v[3], m[11][7])))));
-    tmp[12] = add(tmp[12], add(mul(v[0], m[12][4]), add(mul(v[1], m[12][5]), add(mul(v[2], m[12][6]), mul(v[3], m[12][7])))));
-    tmp[13] = add(tmp[13], add(mul(v[0], m[13][4]), add(mul(v[1], m[13][5]), add(mul(v[2], m[13][6]), mul(v[3], m[13][7])))));
-    tmp[14] = add(tmp[14], add(mul(v[0], m[14][4]), add(mul(v[1], m[14][5]), add(mul(v[2], m[14][6]), mul(v[3], m[14][7])))));
-    tmp[15] = add(tmp[15], add(mul(v[0], m[15][4]), add(mul(v[1], m[15][5]), add(mul(v[2], m[15][6]), mul(v[3], m[15][7])))));
+    tmp[10] = add(tmp[10],
+                  add(mul(v[0], m[10][4]), add(mul(v[1], m[10][5]), add(mul(v[2], m[10][6]), mul(v[3], m[10][7])))));
+    tmp[11] = add(tmp[11],
+                  add(mul(v[0], m[11][4]), add(mul(v[1], m[11][5]), add(mul(v[2], m[11][6]), mul(v[3], m[11][7])))));
+    tmp[12] = add(tmp[12],
+                  add(mul(v[0], m[12][4]), add(mul(v[1], m[12][5]), add(mul(v[2], m[12][6]), mul(v[3], m[12][7])))));
+    tmp[13] = add(tmp[13],
+                  add(mul(v[0], m[13][4]), add(mul(v[1], m[13][5]), add(mul(v[2], m[13][6]), mul(v[3], m[13][7])))));
+    tmp[14] = add(tmp[14],
+                  add(mul(v[0], m[14][4]), add(mul(v[1], m[14][5]), add(mul(v[2], m[14][6]), mul(v[3], m[14][7])))));
+    tmp[15] = add(tmp[15],
+                  add(mul(v[0], m[15][4]), add(mul(v[1], m[15][5]), add(mul(v[2], m[15][6]), mul(v[3], m[15][7])))));
 
     v[0] = psi[I + d3];
     v[1] = psi[I + d0 + d3];
     v[2] = psi[I + d1 + d3];
     v[3] = psi[I + d0 + d1 + d3];
 
-    tmp[0] = add(tmp[0], add(mul(v[0], m[0][8]), add(mul(v[1], m[0][9]), add(mul(v[2], m[0][10]), mul(v[3], m[0][11])))));
-    tmp[1] = add(tmp[1], add(mul(v[0], m[1][8]), add(mul(v[1], m[1][9]), add(mul(v[2], m[1][10]), mul(v[3], m[1][11])))));
-    tmp[2] = add(tmp[2], add(mul(v[0], m[2][8]), add(mul(v[1], m[2][9]), add(mul(v[2], m[2][10]), mul(v[3], m[2][11])))));
-    tmp[3] = add(tmp[3], add(mul(v[0], m[3][8]), add(mul(v[1], m[3][9]), add(mul(v[2], m[3][10]), mul(v[3], m[3][11])))));
-    tmp[4] = add(tmp[4], add(mul(v[0], m[4][8]), add(mul(v[1], m[4][9]), add(mul(v[2], m[4][10]), mul(v[3], m[4][11])))));
-    tmp[5] = add(tmp[5], add(mul(v[0], m[5][8]), add(mul(v[1], m[5][9]), add(mul(v[2], m[5][10]), mul(v[3], m[5][11])))));
-    tmp[6] = add(tmp[6], add(mul(v[0], m[6][8]), add(mul(v[1], m[6][9]), add(mul(v[2], m[6][10]), mul(v[3], m[6][11])))));
-    tmp[7] = add(tmp[7], add(mul(v[0], m[7][8]), add(mul(v[1], m[7][9]), add(mul(v[2], m[7][10]), mul(v[3], m[7][11])))));
-    tmp[8] = add(tmp[8], add(mul(v[0], m[8][8]), add(mul(v[1], m[8][9]), add(mul(v[2], m[8][10]), mul(v[3], m[8][11])))));
-    tmp[9] = add(tmp[9], add(mul(v[0], m[9][8]), add(mul(v[1], m[9][9]), add(mul(v[2], m[9][10]), mul(v[3], m[9][11])))));
-    tmp[10] = add(tmp[10], add(mul(v[0], m[10][8]), add(mul(v[1], m[10][9]), add(mul(v[2], m[10][10]), mul(v[3], m[10][11])))));
-    tmp[11] = add(tmp[11], add(mul(v[0], m[11][8]), add(mul(v[1], m[11][9]), add(mul(v[2], m[11][10]), mul(v[3], m[11][11])))));
-    tmp[12] = add(tmp[12], add(mul(v[0], m[12][8]), add(mul(v[1], m[12][9]), add(mul(v[2], m[12][10]), mul(v[3], m[12][11])))));
-    tmp[13] = add(tmp[13], add(mul(v[0], m[13][8]), add(mul(v[1], m[13][9]), add(mul(v[2], m[13][10]), mul(v[3], m[13][11])))));
-    tmp[14] = add(tmp[14], add(mul(v[0], m[14][8]), add(mul(v[1], m[14][9]), add(mul(v[2], m[14][10]), mul(v[3], m[14][11])))));
-    tmp[15] = add(tmp[15], add(mul(v[0], m[15][8]), add(mul(v[1], m[15][9]), add(mul(v[2], m[15][10]), mul(v[3], m[15][11])))));
+    tmp[0] = add(tmp[0],
+                 add(mul(v[0], m[0][8]), add(mul(v[1], m[0][9]), add(mul(v[2], m[0][10]), mul(v[3], m[0][11])))));
+    tmp[1] = add(tmp[1],
+                 add(mul(v[0], m[1][8]), add(mul(v[1], m[1][9]), add(mul(v[2], m[1][10]), mul(v[3], m[1][11])))));
+    tmp[2] = add(tmp[2],
+                 add(mul(v[0], m[2][8]), add(mul(v[1], m[2][9]), add(mul(v[2], m[2][10]), mul(v[3], m[2][11])))));
+    tmp[3] = add(tmp[3],
+                 add(mul(v[0], m[3][8]), add(mul(v[1], m[3][9]), add(mul(v[2], m[3][10]), mul(v[3], m[3][11])))));
+    tmp[4] = add(tmp[4],
+                 add(mul(v[0], m[4][8]), add(mul(v[1], m[4][9]), add(mul(v[2], m[4][10]), mul(v[3], m[4][11])))));
+    tmp[5] = add(tmp[5],
+                 add(mul(v[0], m[5][8]), add(mul(v[1], m[5][9]), add(mul(v[2], m[5][10]), mul(v[3], m[5][11])))));
+    tmp[6] = add(tmp[6],
+                 add(mul(v[0], m[6][8]), add(mul(v[1], m[6][9]), add(mul(v[2], m[6][10]), mul(v[3], m[6][11])))));
+    tmp[7] = add(tmp[7],
+                 add(mul(v[0], m[7][8]), add(mul(v[1], m[7][9]), add(mul(v[2], m[7][10]), mul(v[3], m[7][11])))));
+    tmp[8] = add(tmp[8],
+                 add(mul(v[0], m[8][8]), add(mul(v[1], m[8][9]), add(mul(v[2], m[8][10]), mul(v[3], m[8][11])))));
+    tmp[9] = add(tmp[9],
+                 add(mul(v[0], m[9][8]), add(mul(v[1], m[9][9]), add(mul(v[2], m[9][10]), mul(v[3], m[9][11])))));
+    tmp[10] = add(tmp[10],
+                  add(mul(v[0], m[10][8]), add(mul(v[1], m[10][9]), add(mul(v[2], m[10][10]), mul(v[3], m[10][11])))));
+    tmp[11] = add(tmp[11],
+                  add(mul(v[0], m[11][8]), add(mul(v[1], m[11][9]), add(mul(v[2], m[11][10]), mul(v[3], m[11][11])))));
+    tmp[12] = add(tmp[12],
+                  add(mul(v[0], m[12][8]), add(mul(v[1], m[12][9]), add(mul(v[2], m[12][10]), mul(v[3], m[12][11])))));
+    tmp[13] = add(tmp[13],
+                  add(mul(v[0], m[13][8]), add(mul(v[1], m[13][9]), add(mul(v[2], m[13][10]), mul(v[3], m[13][11])))));
+    tmp[14] = add(tmp[14],
+                  add(mul(v[0], m[14][8]), add(mul(v[1], m[14][9]), add(mul(v[2], m[14][10]), mul(v[3], m[14][11])))));
+    tmp[15] = add(tmp[15],
+                  add(mul(v[0], m[15][8]), add(mul(v[1], m[15][9]), add(mul(v[2], m[15][10]), mul(v[3], m[15][11])))));
 
     v[0] = psi[I + d2 + d3];
     v[1] = psi[I + d0 + d2 + d3];
     v[2] = psi[I + d1 + d2 + d3];
     v[3] = psi[I + d0 + d1 + d2 + d3];
 
-    psi[I] = (add(tmp[0], add(mul(v[0], m[0][12]), add(mul(v[1], m[0][13]), add(mul(v[2], m[0][14]), mul(v[3], m[0][15]))))));
-    psi[I + d0] = (add(tmp[1], add(mul(v[0], m[1][12]), add(mul(v[1], m[1][13]), add(mul(v[2], m[1][14]), mul(v[3], m[1][15]))))));
-    psi[I + d1] = (add(tmp[2], add(mul(v[0], m[2][12]), add(mul(v[1], m[2][13]), add(mul(v[2], m[2][14]), mul(v[3], m[2][15]))))));
-    psi[I + d0 + d1] = (add(tmp[3], add(mul(v[0], m[3][12]), add(mul(v[1], m[3][13]), add(mul(v[2], m[3][14]), mul(v[3], m[3][15]))))));
-    psi[I + d2] = (add(tmp[4], add(mul(v[0], m[4][12]), add(mul(v[1], m[4][13]), add(mul(v[2], m[4][14]), mul(v[3], m[4][15]))))));
-    psi[I + d0 + d2] = (add(tmp[5], add(mul(v[0], m[5][12]), add(mul(v[1], m[5][13]), add(mul(v[2], m[5][14]), mul(v[3], m[5][15]))))));
-    psi[I + d1 + d2] = (add(tmp[6], add(mul(v[0], m[6][12]), add(mul(v[1], m[6][13]), add(mul(v[2], m[6][14]), mul(v[3], m[6][15]))))));
-    psi[I + d0 + d1 + d2] = (add(tmp[7], add(mul(v[0], m[7][12]), add(mul(v[1], m[7][13]), add(mul(v[2], m[7][14]), mul(v[3], m[7][15]))))));
-    psi[I + d3] = (add(tmp[8], add(mul(v[0], m[8][12]), add(mul(v[1], m[8][13]), add(mul(v[2], m[8][14]), mul(v[3], m[8][15]))))));
-    psi[I + d0 + d3] = (add(tmp[9], add(mul(v[0], m[9][12]), add(mul(v[1], m[9][13]), add(mul(v[2], m[9][14]), mul(v[3], m[9][15]))))));
-    psi[I + d1 + d3] = (add(tmp[10], add(mul(v[0], m[10][12]), add(mul(v[1], m[10][13]), add(mul(v[2], m[10][14]), mul(v[3], m[10][15]))))));
-    psi[I + d0 + d1 + d3] = (add(tmp[11], add(mul(v[0], m[11][12]), add(mul(v[1], m[11][13]), add(mul(v[2], m[11][14]), mul(v[3], m[11][15]))))));
-    psi[I + d2 + d3] = (add(tmp[12], add(mul(v[0], m[12][12]), add(mul(v[1], m[12][13]), add(mul(v[2], m[12][14]), mul(v[3], m[12][15]))))));
-    psi[I + d0 + d2 + d3] = (add(tmp[13], add(mul(v[0], m[13][12]), add(mul(v[1], m[13][13]), add(mul(v[2], m[13][14]), mul(v[3], m[13][15]))))));
-    psi[I + d1 + d2 + d3] = (add(tmp[14], add(mul(v[0], m[14][12]), add(mul(v[1], m[14][13]), add(mul(v[2], m[14][14]), mul(v[3], m[14][15]))))));
-    psi[I + d0 + d1 + d2 + d3] = (add(tmp[15], add(mul(v[0], m[15][12]), add(mul(v[1], m[15][13]), add(mul(v[2], m[15][14]), mul(v[3], m[15][15]))))));
-
+    psi[I] = (add(tmp[0],
+                  add(mul(v[0], m[0][12]), add(mul(v[1], m[0][13]), add(mul(v[2], m[0][14]), mul(v[3], m[0][15]))))));
+    psi[I + d0] = (add(
+        tmp[1], add(mul(v[0], m[1][12]), add(mul(v[1], m[1][13]), add(mul(v[2], m[1][14]), mul(v[3], m[1][15]))))));
+    psi[I + d1] = (add(
+        tmp[2], add(mul(v[0], m[2][12]), add(mul(v[1], m[2][13]), add(mul(v[2], m[2][14]), mul(v[3], m[2][15]))))));
+    psi[I + d0 + d1] = (add(
+        tmp[3], add(mul(v[0], m[3][12]), add(mul(v[1], m[3][13]), add(mul(v[2], m[3][14]), mul(v[3], m[3][15]))))));
+    psi[I + d2] = (add(
+        tmp[4], add(mul(v[0], m[4][12]), add(mul(v[1], m[4][13]), add(mul(v[2], m[4][14]), mul(v[3], m[4][15]))))));
+    psi[I + d0 + d2] = (add(
+        tmp[5], add(mul(v[0], m[5][12]), add(mul(v[1], m[5][13]), add(mul(v[2], m[5][14]), mul(v[3], m[5][15]))))));
+    psi[I + d1 + d2] = (add(
+        tmp[6], add(mul(v[0], m[6][12]), add(mul(v[1], m[6][13]), add(mul(v[2], m[6][14]), mul(v[3], m[6][15]))))));
+    psi[I + d0 + d1 + d2] = (add(
+        tmp[7], add(mul(v[0], m[7][12]), add(mul(v[1], m[7][13]), add(mul(v[2], m[7][14]), mul(v[3], m[7][15]))))));
+    psi[I + d3] = (add(
+        tmp[8], add(mul(v[0], m[8][12]), add(mul(v[1], m[8][13]), add(mul(v[2], m[8][14]), mul(v[3], m[8][15]))))));
+    psi[I + d0 + d3] = (add(
+        tmp[9], add(mul(v[0], m[9][12]), add(mul(v[1], m[9][13]), add(mul(v[2], m[9][14]), mul(v[3], m[9][15]))))));
+    psi[I + d1 + d3] = (add(tmp[10], add(mul(v[0], m[10][12]),
+                                         add(mul(v[1], m[10][13]), add(mul(v[2], m[10][14]), mul(v[3], m[10][15]))))));
+    psi[I + d0 + d1 + d3]
+        = (add(tmp[11],
+               add(mul(v[0], m[11][12]), add(mul(v[1], m[11][13]), add(mul(v[2], m[11][14]), mul(v[3], m[11][15]))))));
+    psi[I + d2 + d3] = (add(tmp[12], add(mul(v[0], m[12][12]),
+                                         add(mul(v[1], m[12][13]), add(mul(v[2], m[12][14]), mul(v[3], m[12][15]))))));
+    psi[I + d0 + d2 + d3]
+        = (add(tmp[13],
+               add(mul(v[0], m[13][12]), add(mul(v[1], m[13][13]), add(mul(v[2], m[13][14]), mul(v[3], m[13][15]))))));
+    psi[I + d1 + d2 + d3]
+        = (add(tmp[14],
+               add(mul(v[0], m[14][12]), add(mul(v[1], m[14][13]), add(mul(v[2], m[14][14]), mul(v[3], m[14][15]))))));
+    psi[I + d0 + d1 + d2 + d3]
+        = (add(tmp[15],
+               add(mul(v[0], m[15][12]), add(mul(v[1], m[15][13]), add(mul(v[2], m[15][14]), mul(v[3], m[15][15]))))));
 }
 
 // bit indices id[.] are given from high to low (e.g. control first for CNOT)
 template <class V, class M>
-void kernel(V &psi, unsigned id3, unsigned id2, unsigned id1, unsigned id0, M const& m, std::size_t ctrlmask)
-{
+void kernel(V& psi, unsigned id3, unsigned id2, unsigned id1, unsigned id0, M const& m, std::size_t ctrlmask) {
     std::size_t n = psi.size();
     std::size_t d0 = 1UL << id0;
     std::size_t d1 = 1UL << id1;
     std::size_t d2 = 1UL << id2;
     std::size_t d3 = 1UL << id3;
-    std::size_t dsorted[] = {d0 , d1, d2, d3};
+    std::size_t dsorted[] = {d0, d1, d2, d3};
     std::sort(dsorted, dsorted + 4, std::greater<std::size_t>());
 
-    if (ctrlmask == 0){
-        #pragma omp for collapse(LOOP_COLLAPSE4) schedule(static)
-        for (std::size_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]){
-            for (std::size_t i1 = 0; i1 < dsorted[0]; i1 += 2 * dsorted[1]){
-                for (std::size_t i2 = 0; i2 < dsorted[1]; i2 += 2 * dsorted[2]){
-                    for (std::size_t i3 = 0; i3 < dsorted[2]; i3 += 2 * dsorted[3]){
-                        for (std::size_t i4 = 0; i4 < dsorted[3]; ++i4){
+    if (ctrlmask == 0) {
+#pragma omp for collapse(LOOP_COLLAPSE4) schedule(static)
+        for (omp::idx_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]) {
+            for (omp::idx_t i1 = 0; i1 < dsorted[0]; i1 += 2 * dsorted[1]) {
+                for (omp::idx_t i2 = 0; i2 < dsorted[1]; i2 += 2 * dsorted[2]) {
+                    for (omp::idx_t i3 = 0; i3 < dsorted[2]; i3 += 2 * dsorted[3]) {
+                        for (omp::idx_t i4 = 0; i4 < dsorted[3]; ++i4) {
                             kernel_core(psi, i0 + i1 + i2 + i3 + i4, d0, d1, d2, d3, m);
                         }
                     }
                 }
             }
         }
-    }
-    else{
-        #pragma omp for collapse(LOOP_COLLAPSE4) schedule(static)
-        for (std::size_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]){
-            for (std::size_t i1 = 0; i1 < dsorted[0]; i1 += 2 * dsorted[1]){
-                for (std::size_t i2 = 0; i2 < dsorted[1]; i2 += 2 * dsorted[2]){
-                    for (std::size_t i3 = 0; i3 < dsorted[2]; i3 += 2 * dsorted[3]){
-                        for (std::size_t i4 = 0; i4 < dsorted[3]; ++i4){
-                            if (((i0 + i1 + i2 + i3 + i4)&ctrlmask) == ctrlmask)
+    } else {
+#pragma omp for collapse(LOOP_COLLAPSE4) schedule(static)
+        for (omp::idx_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]) {
+            for (omp::idx_t i1 = 0; i1 < dsorted[0]; i1 += 2 * dsorted[1]) {
+                for (omp::idx_t i2 = 0; i2 < dsorted[1]; i2 += 2 * dsorted[2]) {
+                    for (omp::idx_t i3 = 0; i3 < dsorted[2]; i3 += 2 * dsorted[3]) {
+                        for (omp::idx_t i4 = 0; i4 < dsorted[3]; ++i4) {
+                            if (((i0 + i1 + i2 + i3 + i4) & ctrlmask) == ctrlmask)
                                 kernel_core(psi, i0 + i1 + i2 + i3 + i4, d0, d1, d2, d3, m);
                         }
                     }
diff -Npur projectq-orig/projectq/backends/_sim/_cppkernels/nointrin/kernel5.hpp projectq-new/projectq/backends/_sim/_cppkernels/nointrin/kernel5.hpp
--- projectq-orig/projectq/backends/_sim/_cppkernels/nointrin/kernel5.hpp	2022-04-27 11:49:17.000000000 +0200
+++ projectq-new/projectq/backends/_sim/_cppkernels/nointrin/kernel5.hpp	2022-06-17 12:37:17.819532363 +0200
@@ -13,8 +13,8 @@
 // limitations under the License.
 
 template <class V, class M>
-inline void kernel_core(V &psi, std::size_t I, std::size_t d0, std::size_t d1, std::size_t d2, std::size_t d3, std::size_t d4, M const& m)
-{
+inline void kernel_core(V& psi, std::size_t I, std::size_t d0, std::size_t d1, std::size_t d2, std::size_t d3,
+                        std::size_t d4, M const& m) {
     std::complex<double> v[4];
     v[0] = psi[I];
     v[1] = psi[I + d0];
@@ -71,280 +71,508 @@ inline void kernel_core(V &psi, std::siz
     tmp[7] = add(tmp[7], add(mul(v[0], m[7][4]), add(mul(v[1], m[7][5]), add(mul(v[2], m[7][6]), mul(v[3], m[7][7])))));
     tmp[8] = add(tmp[8], add(mul(v[0], m[8][4]), add(mul(v[1], m[8][5]), add(mul(v[2], m[8][6]), mul(v[3], m[8][7])))));
     tmp[9] = add(tmp[9], add(mul(v[0], m[9][4]), add(mul(v[1], m[9][5]), add(mul(v[2], m[9][6]), mul(v[3], m[9][7])))));
-    tmp[10] = add(tmp[10], add(mul(v[0], m[10][4]), add(mul(v[1], m[10][5]), add(mul(v[2], m[10][6]), mul(v[3], m[10][7])))));
-    tmp[11] = add(tmp[11], add(mul(v[0], m[11][4]), add(mul(v[1], m[11][5]), add(mul(v[2], m[11][6]), mul(v[3], m[11][7])))));
-    tmp[12] = add(tmp[12], add(mul(v[0], m[12][4]), add(mul(v[1], m[12][5]), add(mul(v[2], m[12][6]), mul(v[3], m[12][7])))));
-    tmp[13] = add(tmp[13], add(mul(v[0], m[13][4]), add(mul(v[1], m[13][5]), add(mul(v[2], m[13][6]), mul(v[3], m[13][7])))));
-    tmp[14] = add(tmp[14], add(mul(v[0], m[14][4]), add(mul(v[1], m[14][5]), add(mul(v[2], m[14][6]), mul(v[3], m[14][7])))));
-    tmp[15] = add(tmp[15], add(mul(v[0], m[15][4]), add(mul(v[1], m[15][5]), add(mul(v[2], m[15][6]), mul(v[3], m[15][7])))));
-    tmp[16] = add(tmp[16], add(mul(v[0], m[16][4]), add(mul(v[1], m[16][5]), add(mul(v[2], m[16][6]), mul(v[3], m[16][7])))));
-    tmp[17] = add(tmp[17], add(mul(v[0], m[17][4]), add(mul(v[1], m[17][5]), add(mul(v[2], m[17][6]), mul(v[3], m[17][7])))));
-    tmp[18] = add(tmp[18], add(mul(v[0], m[18][4]), add(mul(v[1], m[18][5]), add(mul(v[2], m[18][6]), mul(v[3], m[18][7])))));
-    tmp[19] = add(tmp[19], add(mul(v[0], m[19][4]), add(mul(v[1], m[19][5]), add(mul(v[2], m[19][6]), mul(v[3], m[19][7])))));
-    tmp[20] = add(tmp[20], add(mul(v[0], m[20][4]), add(mul(v[1], m[20][5]), add(mul(v[2], m[20][6]), mul(v[3], m[20][7])))));
-    tmp[21] = add(tmp[21], add(mul(v[0], m[21][4]), add(mul(v[1], m[21][5]), add(mul(v[2], m[21][6]), mul(v[3], m[21][7])))));
-    tmp[22] = add(tmp[22], add(mul(v[0], m[22][4]), add(mul(v[1], m[22][5]), add(mul(v[2], m[22][6]), mul(v[3], m[22][7])))));
-    tmp[23] = add(tmp[23], add(mul(v[0], m[23][4]), add(mul(v[1], m[23][5]), add(mul(v[2], m[23][6]), mul(v[3], m[23][7])))));
-    tmp[24] = add(tmp[24], add(mul(v[0], m[24][4]), add(mul(v[1], m[24][5]), add(mul(v[2], m[24][6]), mul(v[3], m[24][7])))));
-    tmp[25] = add(tmp[25], add(mul(v[0], m[25][4]), add(mul(v[1], m[25][5]), add(mul(v[2], m[25][6]), mul(v[3], m[25][7])))));
-    tmp[26] = add(tmp[26], add(mul(v[0], m[26][4]), add(mul(v[1], m[26][5]), add(mul(v[2], m[26][6]), mul(v[3], m[26][7])))));
-    tmp[27] = add(tmp[27], add(mul(v[0], m[27][4]), add(mul(v[1], m[27][5]), add(mul(v[2], m[27][6]), mul(v[3], m[27][7])))));
-    tmp[28] = add(tmp[28], add(mul(v[0], m[28][4]), add(mul(v[1], m[28][5]), add(mul(v[2], m[28][6]), mul(v[3], m[28][7])))));
-    tmp[29] = add(tmp[29], add(mul(v[0], m[29][4]), add(mul(v[1], m[29][5]), add(mul(v[2], m[29][6]), mul(v[3], m[29][7])))));
-    tmp[30] = add(tmp[30], add(mul(v[0], m[30][4]), add(mul(v[1], m[30][5]), add(mul(v[2], m[30][6]), mul(v[3], m[30][7])))));
-    tmp[31] = add(tmp[31], add(mul(v[0], m[31][4]), add(mul(v[1], m[31][5]), add(mul(v[2], m[31][6]), mul(v[3], m[31][7])))));
+    tmp[10] = add(tmp[10],
+                  add(mul(v[0], m[10][4]), add(mul(v[1], m[10][5]), add(mul(v[2], m[10][6]), mul(v[3], m[10][7])))));
+    tmp[11] = add(tmp[11],
+                  add(mul(v[0], m[11][4]), add(mul(v[1], m[11][5]), add(mul(v[2], m[11][6]), mul(v[3], m[11][7])))));
+    tmp[12] = add(tmp[12],
+                  add(mul(v[0], m[12][4]), add(mul(v[1], m[12][5]), add(mul(v[2], m[12][6]), mul(v[3], m[12][7])))));
+    tmp[13] = add(tmp[13],
+                  add(mul(v[0], m[13][4]), add(mul(v[1], m[13][5]), add(mul(v[2], m[13][6]), mul(v[3], m[13][7])))));
+    tmp[14] = add(tmp[14],
+                  add(mul(v[0], m[14][4]), add(mul(v[1], m[14][5]), add(mul(v[2], m[14][6]), mul(v[3], m[14][7])))));
+    tmp[15] = add(tmp[15],
+                  add(mul(v[0], m[15][4]), add(mul(v[1], m[15][5]), add(mul(v[2], m[15][6]), mul(v[3], m[15][7])))));
+    tmp[16] = add(tmp[16],
+                  add(mul(v[0], m[16][4]), add(mul(v[1], m[16][5]), add(mul(v[2], m[16][6]), mul(v[3], m[16][7])))));
+    tmp[17] = add(tmp[17],
+                  add(mul(v[0], m[17][4]), add(mul(v[1], m[17][5]), add(mul(v[2], m[17][6]), mul(v[3], m[17][7])))));
+    tmp[18] = add(tmp[18],
+                  add(mul(v[0], m[18][4]), add(mul(v[1], m[18][5]), add(mul(v[2], m[18][6]), mul(v[3], m[18][7])))));
+    tmp[19] = add(tmp[19],
+                  add(mul(v[0], m[19][4]), add(mul(v[1], m[19][5]), add(mul(v[2], m[19][6]), mul(v[3], m[19][7])))));
+    tmp[20] = add(tmp[20],
+                  add(mul(v[0], m[20][4]), add(mul(v[1], m[20][5]), add(mul(v[2], m[20][6]), mul(v[3], m[20][7])))));
+    tmp[21] = add(tmp[21],
+                  add(mul(v[0], m[21][4]), add(mul(v[1], m[21][5]), add(mul(v[2], m[21][6]), mul(v[3], m[21][7])))));
+    tmp[22] = add(tmp[22],
+                  add(mul(v[0], m[22][4]), add(mul(v[1], m[22][5]), add(mul(v[2], m[22][6]), mul(v[3], m[22][7])))));
+    tmp[23] = add(tmp[23],
+                  add(mul(v[0], m[23][4]), add(mul(v[1], m[23][5]), add(mul(v[2], m[23][6]), mul(v[3], m[23][7])))));
+    tmp[24] = add(tmp[24],
+                  add(mul(v[0], m[24][4]), add(mul(v[1], m[24][5]), add(mul(v[2], m[24][6]), mul(v[3], m[24][7])))));
+    tmp[25] = add(tmp[25],
+                  add(mul(v[0], m[25][4]), add(mul(v[1], m[25][5]), add(mul(v[2], m[25][6]), mul(v[3], m[25][7])))));
+    tmp[26] = add(tmp[26],
+                  add(mul(v[0], m[26][4]), add(mul(v[1], m[26][5]), add(mul(v[2], m[26][6]), mul(v[3], m[26][7])))));
+    tmp[27] = add(tmp[27],
+                  add(mul(v[0], m[27][4]), add(mul(v[1], m[27][5]), add(mul(v[2], m[27][6]), mul(v[3], m[27][7])))));
+    tmp[28] = add(tmp[28],
+                  add(mul(v[0], m[28][4]), add(mul(v[1], m[28][5]), add(mul(v[2], m[28][6]), mul(v[3], m[28][7])))));
+    tmp[29] = add(tmp[29],
+                  add(mul(v[0], m[29][4]), add(mul(v[1], m[29][5]), add(mul(v[2], m[29][6]), mul(v[3], m[29][7])))));
+    tmp[30] = add(tmp[30],
+                  add(mul(v[0], m[30][4]), add(mul(v[1], m[30][5]), add(mul(v[2], m[30][6]), mul(v[3], m[30][7])))));
+    tmp[31] = add(tmp[31],
+                  add(mul(v[0], m[31][4]), add(mul(v[1], m[31][5]), add(mul(v[2], m[31][6]), mul(v[3], m[31][7])))));
 
     v[0] = psi[I + d3];
     v[1] = psi[I + d0 + d3];
     v[2] = psi[I + d1 + d3];
     v[3] = psi[I + d0 + d1 + d3];
 
-    tmp[0] = add(tmp[0], add(mul(v[0], m[0][8]), add(mul(v[1], m[0][9]), add(mul(v[2], m[0][10]), mul(v[3], m[0][11])))));
-    tmp[1] = add(tmp[1], add(mul(v[0], m[1][8]), add(mul(v[1], m[1][9]), add(mul(v[2], m[1][10]), mul(v[3], m[1][11])))));
-    tmp[2] = add(tmp[2], add(mul(v[0], m[2][8]), add(mul(v[1], m[2][9]), add(mul(v[2], m[2][10]), mul(v[3], m[2][11])))));
-    tmp[3] = add(tmp[3], add(mul(v[0], m[3][8]), add(mul(v[1], m[3][9]), add(mul(v[2], m[3][10]), mul(v[3], m[3][11])))));
-    tmp[4] = add(tmp[4], add(mul(v[0], m[4][8]), add(mul(v[1], m[4][9]), add(mul(v[2], m[4][10]), mul(v[3], m[4][11])))));
-    tmp[5] = add(tmp[5], add(mul(v[0], m[5][8]), add(mul(v[1], m[5][9]), add(mul(v[2], m[5][10]), mul(v[3], m[5][11])))));
-    tmp[6] = add(tmp[6], add(mul(v[0], m[6][8]), add(mul(v[1], m[6][9]), add(mul(v[2], m[6][10]), mul(v[3], m[6][11])))));
-    tmp[7] = add(tmp[7], add(mul(v[0], m[7][8]), add(mul(v[1], m[7][9]), add(mul(v[2], m[7][10]), mul(v[3], m[7][11])))));
-    tmp[8] = add(tmp[8], add(mul(v[0], m[8][8]), add(mul(v[1], m[8][9]), add(mul(v[2], m[8][10]), mul(v[3], m[8][11])))));
-    tmp[9] = add(tmp[9], add(mul(v[0], m[9][8]), add(mul(v[1], m[9][9]), add(mul(v[2], m[9][10]), mul(v[3], m[9][11])))));
-    tmp[10] = add(tmp[10], add(mul(v[0], m[10][8]), add(mul(v[1], m[10][9]), add(mul(v[2], m[10][10]), mul(v[3], m[10][11])))));
-    tmp[11] = add(tmp[11], add(mul(v[0], m[11][8]), add(mul(v[1], m[11][9]), add(mul(v[2], m[11][10]), mul(v[3], m[11][11])))));
-    tmp[12] = add(tmp[12], add(mul(v[0], m[12][8]), add(mul(v[1], m[12][9]), add(mul(v[2], m[12][10]), mul(v[3], m[12][11])))));
-    tmp[13] = add(tmp[13], add(mul(v[0], m[13][8]), add(mul(v[1], m[13][9]), add(mul(v[2], m[13][10]), mul(v[3], m[13][11])))));
-    tmp[14] = add(tmp[14], add(mul(v[0], m[14][8]), add(mul(v[1], m[14][9]), add(mul(v[2], m[14][10]), mul(v[3], m[14][11])))));
-    tmp[15] = add(tmp[15], add(mul(v[0], m[15][8]), add(mul(v[1], m[15][9]), add(mul(v[2], m[15][10]), mul(v[3], m[15][11])))));
-    tmp[16] = add(tmp[16], add(mul(v[0], m[16][8]), add(mul(v[1], m[16][9]), add(mul(v[2], m[16][10]), mul(v[3], m[16][11])))));
-    tmp[17] = add(tmp[17], add(mul(v[0], m[17][8]), add(mul(v[1], m[17][9]), add(mul(v[2], m[17][10]), mul(v[3], m[17][11])))));
-    tmp[18] = add(tmp[18], add(mul(v[0], m[18][8]), add(mul(v[1], m[18][9]), add(mul(v[2], m[18][10]), mul(v[3], m[18][11])))));
-    tmp[19] = add(tmp[19], add(mul(v[0], m[19][8]), add(mul(v[1], m[19][9]), add(mul(v[2], m[19][10]), mul(v[3], m[19][11])))));
-    tmp[20] = add(tmp[20], add(mul(v[0], m[20][8]), add(mul(v[1], m[20][9]), add(mul(v[2], m[20][10]), mul(v[3], m[20][11])))));
-    tmp[21] = add(tmp[21], add(mul(v[0], m[21][8]), add(mul(v[1], m[21][9]), add(mul(v[2], m[21][10]), mul(v[3], m[21][11])))));
-    tmp[22] = add(tmp[22], add(mul(v[0], m[22][8]), add(mul(v[1], m[22][9]), add(mul(v[2], m[22][10]), mul(v[3], m[22][11])))));
-    tmp[23] = add(tmp[23], add(mul(v[0], m[23][8]), add(mul(v[1], m[23][9]), add(mul(v[2], m[23][10]), mul(v[3], m[23][11])))));
-    tmp[24] = add(tmp[24], add(mul(v[0], m[24][8]), add(mul(v[1], m[24][9]), add(mul(v[2], m[24][10]), mul(v[3], m[24][11])))));
-    tmp[25] = add(tmp[25], add(mul(v[0], m[25][8]), add(mul(v[1], m[25][9]), add(mul(v[2], m[25][10]), mul(v[3], m[25][11])))));
-    tmp[26] = add(tmp[26], add(mul(v[0], m[26][8]), add(mul(v[1], m[26][9]), add(mul(v[2], m[26][10]), mul(v[3], m[26][11])))));
-    tmp[27] = add(tmp[27], add(mul(v[0], m[27][8]), add(mul(v[1], m[27][9]), add(mul(v[2], m[27][10]), mul(v[3], m[27][11])))));
-    tmp[28] = add(tmp[28], add(mul(v[0], m[28][8]), add(mul(v[1], m[28][9]), add(mul(v[2], m[28][10]), mul(v[3], m[28][11])))));
-    tmp[29] = add(tmp[29], add(mul(v[0], m[29][8]), add(mul(v[1], m[29][9]), add(mul(v[2], m[29][10]), mul(v[3], m[29][11])))));
-    tmp[30] = add(tmp[30], add(mul(v[0], m[30][8]), add(mul(v[1], m[30][9]), add(mul(v[2], m[30][10]), mul(v[3], m[30][11])))));
-    tmp[31] = add(tmp[31], add(mul(v[0], m[31][8]), add(mul(v[1], m[31][9]), add(mul(v[2], m[31][10]), mul(v[3], m[31][11])))));
+    tmp[0] = add(tmp[0],
+                 add(mul(v[0], m[0][8]), add(mul(v[1], m[0][9]), add(mul(v[2], m[0][10]), mul(v[3], m[0][11])))));
+    tmp[1] = add(tmp[1],
+                 add(mul(v[0], m[1][8]), add(mul(v[1], m[1][9]), add(mul(v[2], m[1][10]), mul(v[3], m[1][11])))));
+    tmp[2] = add(tmp[2],
+                 add(mul(v[0], m[2][8]), add(mul(v[1], m[2][9]), add(mul(v[2], m[2][10]), mul(v[3], m[2][11])))));
+    tmp[3] = add(tmp[3],
+                 add(mul(v[0], m[3][8]), add(mul(v[1], m[3][9]), add(mul(v[2], m[3][10]), mul(v[3], m[3][11])))));
+    tmp[4] = add(tmp[4],
+                 add(mul(v[0], m[4][8]), add(mul(v[1], m[4][9]), add(mul(v[2], m[4][10]), mul(v[3], m[4][11])))));
+    tmp[5] = add(tmp[5],
+                 add(mul(v[0], m[5][8]), add(mul(v[1], m[5][9]), add(mul(v[2], m[5][10]), mul(v[3], m[5][11])))));
+    tmp[6] = add(tmp[6],
+                 add(mul(v[0], m[6][8]), add(mul(v[1], m[6][9]), add(mul(v[2], m[6][10]), mul(v[3], m[6][11])))));
+    tmp[7] = add(tmp[7],
+                 add(mul(v[0], m[7][8]), add(mul(v[1], m[7][9]), add(mul(v[2], m[7][10]), mul(v[3], m[7][11])))));
+    tmp[8] = add(tmp[8],
+                 add(mul(v[0], m[8][8]), add(mul(v[1], m[8][9]), add(mul(v[2], m[8][10]), mul(v[3], m[8][11])))));
+    tmp[9] = add(tmp[9],
+                 add(mul(v[0], m[9][8]), add(mul(v[1], m[9][9]), add(mul(v[2], m[9][10]), mul(v[3], m[9][11])))));
+    tmp[10] = add(tmp[10],
+                  add(mul(v[0], m[10][8]), add(mul(v[1], m[10][9]), add(mul(v[2], m[10][10]), mul(v[3], m[10][11])))));
+    tmp[11] = add(tmp[11],
+                  add(mul(v[0], m[11][8]), add(mul(v[1], m[11][9]), add(mul(v[2], m[11][10]), mul(v[3], m[11][11])))));
+    tmp[12] = add(tmp[12],
+                  add(mul(v[0], m[12][8]), add(mul(v[1], m[12][9]), add(mul(v[2], m[12][10]), mul(v[3], m[12][11])))));
+    tmp[13] = add(tmp[13],
+                  add(mul(v[0], m[13][8]), add(mul(v[1], m[13][9]), add(mul(v[2], m[13][10]), mul(v[3], m[13][11])))));
+    tmp[14] = add(tmp[14],
+                  add(mul(v[0], m[14][8]), add(mul(v[1], m[14][9]), add(mul(v[2], m[14][10]), mul(v[3], m[14][11])))));
+    tmp[15] = add(tmp[15],
+                  add(mul(v[0], m[15][8]), add(mul(v[1], m[15][9]), add(mul(v[2], m[15][10]), mul(v[3], m[15][11])))));
+    tmp[16] = add(tmp[16],
+                  add(mul(v[0], m[16][8]), add(mul(v[1], m[16][9]), add(mul(v[2], m[16][10]), mul(v[3], m[16][11])))));
+    tmp[17] = add(tmp[17],
+                  add(mul(v[0], m[17][8]), add(mul(v[1], m[17][9]), add(mul(v[2], m[17][10]), mul(v[3], m[17][11])))));
+    tmp[18] = add(tmp[18],
+                  add(mul(v[0], m[18][8]), add(mul(v[1], m[18][9]), add(mul(v[2], m[18][10]), mul(v[3], m[18][11])))));
+    tmp[19] = add(tmp[19],
+                  add(mul(v[0], m[19][8]), add(mul(v[1], m[19][9]), add(mul(v[2], m[19][10]), mul(v[3], m[19][11])))));
+    tmp[20] = add(tmp[20],
+                  add(mul(v[0], m[20][8]), add(mul(v[1], m[20][9]), add(mul(v[2], m[20][10]), mul(v[3], m[20][11])))));
+    tmp[21] = add(tmp[21],
+                  add(mul(v[0], m[21][8]), add(mul(v[1], m[21][9]), add(mul(v[2], m[21][10]), mul(v[3], m[21][11])))));
+    tmp[22] = add(tmp[22],
+                  add(mul(v[0], m[22][8]), add(mul(v[1], m[22][9]), add(mul(v[2], m[22][10]), mul(v[3], m[22][11])))));
+    tmp[23] = add(tmp[23],
+                  add(mul(v[0], m[23][8]), add(mul(v[1], m[23][9]), add(mul(v[2], m[23][10]), mul(v[3], m[23][11])))));
+    tmp[24] = add(tmp[24],
+                  add(mul(v[0], m[24][8]), add(mul(v[1], m[24][9]), add(mul(v[2], m[24][10]), mul(v[3], m[24][11])))));
+    tmp[25] = add(tmp[25],
+                  add(mul(v[0], m[25][8]), add(mul(v[1], m[25][9]), add(mul(v[2], m[25][10]), mul(v[3], m[25][11])))));
+    tmp[26] = add(tmp[26],
+                  add(mul(v[0], m[26][8]), add(mul(v[1], m[26][9]), add(mul(v[2], m[26][10]), mul(v[3], m[26][11])))));
+    tmp[27] = add(tmp[27],
+                  add(mul(v[0], m[27][8]), add(mul(v[1], m[27][9]), add(mul(v[2], m[27][10]), mul(v[3], m[27][11])))));
+    tmp[28] = add(tmp[28],
+                  add(mul(v[0], m[28][8]), add(mul(v[1], m[28][9]), add(mul(v[2], m[28][10]), mul(v[3], m[28][11])))));
+    tmp[29] = add(tmp[29],
+                  add(mul(v[0], m[29][8]), add(mul(v[1], m[29][9]), add(mul(v[2], m[29][10]), mul(v[3], m[29][11])))));
+    tmp[30] = add(tmp[30],
+                  add(mul(v[0], m[30][8]), add(mul(v[1], m[30][9]), add(mul(v[2], m[30][10]), mul(v[3], m[30][11])))));
+    tmp[31] = add(tmp[31],
+                  add(mul(v[0], m[31][8]), add(mul(v[1], m[31][9]), add(mul(v[2], m[31][10]), mul(v[3], m[31][11])))));
 
     v[0] = psi[I + d2 + d3];
     v[1] = psi[I + d0 + d2 + d3];
     v[2] = psi[I + d1 + d2 + d3];
     v[3] = psi[I + d0 + d1 + d2 + d3];
 
-    tmp[0] = add(tmp[0], add(mul(v[0], m[0][12]), add(mul(v[1], m[0][13]), add(mul(v[2], m[0][14]), mul(v[3], m[0][15])))));
-    tmp[1] = add(tmp[1], add(mul(v[0], m[1][12]), add(mul(v[1], m[1][13]), add(mul(v[2], m[1][14]), mul(v[3], m[1][15])))));
-    tmp[2] = add(tmp[2], add(mul(v[0], m[2][12]), add(mul(v[1], m[2][13]), add(mul(v[2], m[2][14]), mul(v[3], m[2][15])))));
-    tmp[3] = add(tmp[3], add(mul(v[0], m[3][12]), add(mul(v[1], m[3][13]), add(mul(v[2], m[3][14]), mul(v[3], m[3][15])))));
-    tmp[4] = add(tmp[4], add(mul(v[0], m[4][12]), add(mul(v[1], m[4][13]), add(mul(v[2], m[4][14]), mul(v[3], m[4][15])))));
-    tmp[5] = add(tmp[5], add(mul(v[0], m[5][12]), add(mul(v[1], m[5][13]), add(mul(v[2], m[5][14]), mul(v[3], m[5][15])))));
-    tmp[6] = add(tmp[6], add(mul(v[0], m[6][12]), add(mul(v[1], m[6][13]), add(mul(v[2], m[6][14]), mul(v[3], m[6][15])))));
-    tmp[7] = add(tmp[7], add(mul(v[0], m[7][12]), add(mul(v[1], m[7][13]), add(mul(v[2], m[7][14]), mul(v[3], m[7][15])))));
-    tmp[8] = add(tmp[8], add(mul(v[0], m[8][12]), add(mul(v[1], m[8][13]), add(mul(v[2], m[8][14]), mul(v[3], m[8][15])))));
-    tmp[9] = add(tmp[9], add(mul(v[0], m[9][12]), add(mul(v[1], m[9][13]), add(mul(v[2], m[9][14]), mul(v[3], m[9][15])))));
-    tmp[10] = add(tmp[10], add(mul(v[0], m[10][12]), add(mul(v[1], m[10][13]), add(mul(v[2], m[10][14]), mul(v[3], m[10][15])))));
-    tmp[11] = add(tmp[11], add(mul(v[0], m[11][12]), add(mul(v[1], m[11][13]), add(mul(v[2], m[11][14]), mul(v[3], m[11][15])))));
-    tmp[12] = add(tmp[12], add(mul(v[0], m[12][12]), add(mul(v[1], m[12][13]), add(mul(v[2], m[12][14]), mul(v[3], m[12][15])))));
-    tmp[13] = add(tmp[13], add(mul(v[0], m[13][12]), add(mul(v[1], m[13][13]), add(mul(v[2], m[13][14]), mul(v[3], m[13][15])))));
-    tmp[14] = add(tmp[14], add(mul(v[0], m[14][12]), add(mul(v[1], m[14][13]), add(mul(v[2], m[14][14]), mul(v[3], m[14][15])))));
-    tmp[15] = add(tmp[15], add(mul(v[0], m[15][12]), add(mul(v[1], m[15][13]), add(mul(v[2], m[15][14]), mul(v[3], m[15][15])))));
-    tmp[16] = add(tmp[16], add(mul(v[0], m[16][12]), add(mul(v[1], m[16][13]), add(mul(v[2], m[16][14]), mul(v[3], m[16][15])))));
-    tmp[17] = add(tmp[17], add(mul(v[0], m[17][12]), add(mul(v[1], m[17][13]), add(mul(v[2], m[17][14]), mul(v[3], m[17][15])))));
-    tmp[18] = add(tmp[18], add(mul(v[0], m[18][12]), add(mul(v[1], m[18][13]), add(mul(v[2], m[18][14]), mul(v[3], m[18][15])))));
-    tmp[19] = add(tmp[19], add(mul(v[0], m[19][12]), add(mul(v[1], m[19][13]), add(mul(v[2], m[19][14]), mul(v[3], m[19][15])))));
-    tmp[20] = add(tmp[20], add(mul(v[0], m[20][12]), add(mul(v[1], m[20][13]), add(mul(v[2], m[20][14]), mul(v[3], m[20][15])))));
-    tmp[21] = add(tmp[21], add(mul(v[0], m[21][12]), add(mul(v[1], m[21][13]), add(mul(v[2], m[21][14]), mul(v[3], m[21][15])))));
-    tmp[22] = add(tmp[22], add(mul(v[0], m[22][12]), add(mul(v[1], m[22][13]), add(mul(v[2], m[22][14]), mul(v[3], m[22][15])))));
-    tmp[23] = add(tmp[23], add(mul(v[0], m[23][12]), add(mul(v[1], m[23][13]), add(mul(v[2], m[23][14]), mul(v[3], m[23][15])))));
-    tmp[24] = add(tmp[24], add(mul(v[0], m[24][12]), add(mul(v[1], m[24][13]), add(mul(v[2], m[24][14]), mul(v[3], m[24][15])))));
-    tmp[25] = add(tmp[25], add(mul(v[0], m[25][12]), add(mul(v[1], m[25][13]), add(mul(v[2], m[25][14]), mul(v[3], m[25][15])))));
-    tmp[26] = add(tmp[26], add(mul(v[0], m[26][12]), add(mul(v[1], m[26][13]), add(mul(v[2], m[26][14]), mul(v[3], m[26][15])))));
-    tmp[27] = add(tmp[27], add(mul(v[0], m[27][12]), add(mul(v[1], m[27][13]), add(mul(v[2], m[27][14]), mul(v[3], m[27][15])))));
-    tmp[28] = add(tmp[28], add(mul(v[0], m[28][12]), add(mul(v[1], m[28][13]), add(mul(v[2], m[28][14]), mul(v[3], m[28][15])))));
-    tmp[29] = add(tmp[29], add(mul(v[0], m[29][12]), add(mul(v[1], m[29][13]), add(mul(v[2], m[29][14]), mul(v[3], m[29][15])))));
-    tmp[30] = add(tmp[30], add(mul(v[0], m[30][12]), add(mul(v[1], m[30][13]), add(mul(v[2], m[30][14]), mul(v[3], m[30][15])))));
-    tmp[31] = add(tmp[31], add(mul(v[0], m[31][12]), add(mul(v[1], m[31][13]), add(mul(v[2], m[31][14]), mul(v[3], m[31][15])))));
+    tmp[0] = add(tmp[0],
+                 add(mul(v[0], m[0][12]), add(mul(v[1], m[0][13]), add(mul(v[2], m[0][14]), mul(v[3], m[0][15])))));
+    tmp[1] = add(tmp[1],
+                 add(mul(v[0], m[1][12]), add(mul(v[1], m[1][13]), add(mul(v[2], m[1][14]), mul(v[3], m[1][15])))));
+    tmp[2] = add(tmp[2],
+                 add(mul(v[0], m[2][12]), add(mul(v[1], m[2][13]), add(mul(v[2], m[2][14]), mul(v[3], m[2][15])))));
+    tmp[3] = add(tmp[3],
+                 add(mul(v[0], m[3][12]), add(mul(v[1], m[3][13]), add(mul(v[2], m[3][14]), mul(v[3], m[3][15])))));
+    tmp[4] = add(tmp[4],
+                 add(mul(v[0], m[4][12]), add(mul(v[1], m[4][13]), add(mul(v[2], m[4][14]), mul(v[3], m[4][15])))));
+    tmp[5] = add(tmp[5],
+                 add(mul(v[0], m[5][12]), add(mul(v[1], m[5][13]), add(mul(v[2], m[5][14]), mul(v[3], m[5][15])))));
+    tmp[6] = add(tmp[6],
+                 add(mul(v[0], m[6][12]), add(mul(v[1], m[6][13]), add(mul(v[2], m[6][14]), mul(v[3], m[6][15])))));
+    tmp[7] = add(tmp[7],
+                 add(mul(v[0], m[7][12]), add(mul(v[1], m[7][13]), add(mul(v[2], m[7][14]), mul(v[3], m[7][15])))));
+    tmp[8] = add(tmp[8],
+                 add(mul(v[0], m[8][12]), add(mul(v[1], m[8][13]), add(mul(v[2], m[8][14]), mul(v[3], m[8][15])))));
+    tmp[9] = add(tmp[9],
+                 add(mul(v[0], m[9][12]), add(mul(v[1], m[9][13]), add(mul(v[2], m[9][14]), mul(v[3], m[9][15])))));
+    tmp[10] = add(
+        tmp[10], add(mul(v[0], m[10][12]), add(mul(v[1], m[10][13]), add(mul(v[2], m[10][14]), mul(v[3], m[10][15])))));
+    tmp[11] = add(
+        tmp[11], add(mul(v[0], m[11][12]), add(mul(v[1], m[11][13]), add(mul(v[2], m[11][14]), mul(v[3], m[11][15])))));
+    tmp[12] = add(
+        tmp[12], add(mul(v[0], m[12][12]), add(mul(v[1], m[12][13]), add(mul(v[2], m[12][14]), mul(v[3], m[12][15])))));
+    tmp[13] = add(
+        tmp[13], add(mul(v[0], m[13][12]), add(mul(v[1], m[13][13]), add(mul(v[2], m[13][14]), mul(v[3], m[13][15])))));
+    tmp[14] = add(
+        tmp[14], add(mul(v[0], m[14][12]), add(mul(v[1], m[14][13]), add(mul(v[2], m[14][14]), mul(v[3], m[14][15])))));
+    tmp[15] = add(
+        tmp[15], add(mul(v[0], m[15][12]), add(mul(v[1], m[15][13]), add(mul(v[2], m[15][14]), mul(v[3], m[15][15])))));
+    tmp[16] = add(
+        tmp[16], add(mul(v[0], m[16][12]), add(mul(v[1], m[16][13]), add(mul(v[2], m[16][14]), mul(v[3], m[16][15])))));
+    tmp[17] = add(
+        tmp[17], add(mul(v[0], m[17][12]), add(mul(v[1], m[17][13]), add(mul(v[2], m[17][14]), mul(v[3], m[17][15])))));
+    tmp[18] = add(
+        tmp[18], add(mul(v[0], m[18][12]), add(mul(v[1], m[18][13]), add(mul(v[2], m[18][14]), mul(v[3], m[18][15])))));
+    tmp[19] = add(
+        tmp[19], add(mul(v[0], m[19][12]), add(mul(v[1], m[19][13]), add(mul(v[2], m[19][14]), mul(v[3], m[19][15])))));
+    tmp[20] = add(
+        tmp[20], add(mul(v[0], m[20][12]), add(mul(v[1], m[20][13]), add(mul(v[2], m[20][14]), mul(v[3], m[20][15])))));
+    tmp[21] = add(
+        tmp[21], add(mul(v[0], m[21][12]), add(mul(v[1], m[21][13]), add(mul(v[2], m[21][14]), mul(v[3], m[21][15])))));
+    tmp[22] = add(
+        tmp[22], add(mul(v[0], m[22][12]), add(mul(v[1], m[22][13]), add(mul(v[2], m[22][14]), mul(v[3], m[22][15])))));
+    tmp[23] = add(
+        tmp[23], add(mul(v[0], m[23][12]), add(mul(v[1], m[23][13]), add(mul(v[2], m[23][14]), mul(v[3], m[23][15])))));
+    tmp[24] = add(
+        tmp[24], add(mul(v[0], m[24][12]), add(mul(v[1], m[24][13]), add(mul(v[2], m[24][14]), mul(v[3], m[24][15])))));
+    tmp[25] = add(
+        tmp[25], add(mul(v[0], m[25][12]), add(mul(v[1], m[25][13]), add(mul(v[2], m[25][14]), mul(v[3], m[25][15])))));
+    tmp[26] = add(
+        tmp[26], add(mul(v[0], m[26][12]), add(mul(v[1], m[26][13]), add(mul(v[2], m[26][14]), mul(v[3], m[26][15])))));
+    tmp[27] = add(
+        tmp[27], add(mul(v[0], m[27][12]), add(mul(v[1], m[27][13]), add(mul(v[2], m[27][14]), mul(v[3], m[27][15])))));
+    tmp[28] = add(
+        tmp[28], add(mul(v[0], m[28][12]), add(mul(v[1], m[28][13]), add(mul(v[2], m[28][14]), mul(v[3], m[28][15])))));
+    tmp[29] = add(
+        tmp[29], add(mul(v[0], m[29][12]), add(mul(v[1], m[29][13]), add(mul(v[2], m[29][14]), mul(v[3], m[29][15])))));
+    tmp[30] = add(
+        tmp[30], add(mul(v[0], m[30][12]), add(mul(v[1], m[30][13]), add(mul(v[2], m[30][14]), mul(v[3], m[30][15])))));
+    tmp[31] = add(
+        tmp[31], add(mul(v[0], m[31][12]), add(mul(v[1], m[31][13]), add(mul(v[2], m[31][14]), mul(v[3], m[31][15])))));
 
     v[0] = psi[I + d4];
     v[1] = psi[I + d0 + d4];
     v[2] = psi[I + d1 + d4];
     v[3] = psi[I + d0 + d1 + d4];
 
-    tmp[0] = add(tmp[0], add(mul(v[0], m[0][16]), add(mul(v[1], m[0][17]), add(mul(v[2], m[0][18]), mul(v[3], m[0][19])))));
-    tmp[1] = add(tmp[1], add(mul(v[0], m[1][16]), add(mul(v[1], m[1][17]), add(mul(v[2], m[1][18]), mul(v[3], m[1][19])))));
-    tmp[2] = add(tmp[2], add(mul(v[0], m[2][16]), add(mul(v[1], m[2][17]), add(mul(v[2], m[2][18]), mul(v[3], m[2][19])))));
-    tmp[3] = add(tmp[3], add(mul(v[0], m[3][16]), add(mul(v[1], m[3][17]), add(mul(v[2], m[3][18]), mul(v[3], m[3][19])))));
-    tmp[4] = add(tmp[4], add(mul(v[0], m[4][16]), add(mul(v[1], m[4][17]), add(mul(v[2], m[4][18]), mul(v[3], m[4][19])))));
-    tmp[5] = add(tmp[5], add(mul(v[0], m[5][16]), add(mul(v[1], m[5][17]), add(mul(v[2], m[5][18]), mul(v[3], m[5][19])))));
-    tmp[6] = add(tmp[6], add(mul(v[0], m[6][16]), add(mul(v[1], m[6][17]), add(mul(v[2], m[6][18]), mul(v[3], m[6][19])))));
-    tmp[7] = add(tmp[7], add(mul(v[0], m[7][16]), add(mul(v[1], m[7][17]), add(mul(v[2], m[7][18]), mul(v[3], m[7][19])))));
-    tmp[8] = add(tmp[8], add(mul(v[0], m[8][16]), add(mul(v[1], m[8][17]), add(mul(v[2], m[8][18]), mul(v[3], m[8][19])))));
-    tmp[9] = add(tmp[9], add(mul(v[0], m[9][16]), add(mul(v[1], m[9][17]), add(mul(v[2], m[9][18]), mul(v[3], m[9][19])))));
-    tmp[10] = add(tmp[10], add(mul(v[0], m[10][16]), add(mul(v[1], m[10][17]), add(mul(v[2], m[10][18]), mul(v[3], m[10][19])))));
-    tmp[11] = add(tmp[11], add(mul(v[0], m[11][16]), add(mul(v[1], m[11][17]), add(mul(v[2], m[11][18]), mul(v[3], m[11][19])))));
-    tmp[12] = add(tmp[12], add(mul(v[0], m[12][16]), add(mul(v[1], m[12][17]), add(mul(v[2], m[12][18]), mul(v[3], m[12][19])))));
-    tmp[13] = add(tmp[13], add(mul(v[0], m[13][16]), add(mul(v[1], m[13][17]), add(mul(v[2], m[13][18]), mul(v[3], m[13][19])))));
-    tmp[14] = add(tmp[14], add(mul(v[0], m[14][16]), add(mul(v[1], m[14][17]), add(mul(v[2], m[14][18]), mul(v[3], m[14][19])))));
-    tmp[15] = add(tmp[15], add(mul(v[0], m[15][16]), add(mul(v[1], m[15][17]), add(mul(v[2], m[15][18]), mul(v[3], m[15][19])))));
-    tmp[16] = add(tmp[16], add(mul(v[0], m[16][16]), add(mul(v[1], m[16][17]), add(mul(v[2], m[16][18]), mul(v[3], m[16][19])))));
-    tmp[17] = add(tmp[17], add(mul(v[0], m[17][16]), add(mul(v[1], m[17][17]), add(mul(v[2], m[17][18]), mul(v[3], m[17][19])))));
-    tmp[18] = add(tmp[18], add(mul(v[0], m[18][16]), add(mul(v[1], m[18][17]), add(mul(v[2], m[18][18]), mul(v[3], m[18][19])))));
-    tmp[19] = add(tmp[19], add(mul(v[0], m[19][16]), add(mul(v[1], m[19][17]), add(mul(v[2], m[19][18]), mul(v[3], m[19][19])))));
-    tmp[20] = add(tmp[20], add(mul(v[0], m[20][16]), add(mul(v[1], m[20][17]), add(mul(v[2], m[20][18]), mul(v[3], m[20][19])))));
-    tmp[21] = add(tmp[21], add(mul(v[0], m[21][16]), add(mul(v[1], m[21][17]), add(mul(v[2], m[21][18]), mul(v[3], m[21][19])))));
-    tmp[22] = add(tmp[22], add(mul(v[0], m[22][16]), add(mul(v[1], m[22][17]), add(mul(v[2], m[22][18]), mul(v[3], m[22][19])))));
-    tmp[23] = add(tmp[23], add(mul(v[0], m[23][16]), add(mul(v[1], m[23][17]), add(mul(v[2], m[23][18]), mul(v[3], m[23][19])))));
-    tmp[24] = add(tmp[24], add(mul(v[0], m[24][16]), add(mul(v[1], m[24][17]), add(mul(v[2], m[24][18]), mul(v[3], m[24][19])))));
-    tmp[25] = add(tmp[25], add(mul(v[0], m[25][16]), add(mul(v[1], m[25][17]), add(mul(v[2], m[25][18]), mul(v[3], m[25][19])))));
-    tmp[26] = add(tmp[26], add(mul(v[0], m[26][16]), add(mul(v[1], m[26][17]), add(mul(v[2], m[26][18]), mul(v[3], m[26][19])))));
-    tmp[27] = add(tmp[27], add(mul(v[0], m[27][16]), add(mul(v[1], m[27][17]), add(mul(v[2], m[27][18]), mul(v[3], m[27][19])))));
-    tmp[28] = add(tmp[28], add(mul(v[0], m[28][16]), add(mul(v[1], m[28][17]), add(mul(v[2], m[28][18]), mul(v[3], m[28][19])))));
-    tmp[29] = add(tmp[29], add(mul(v[0], m[29][16]), add(mul(v[1], m[29][17]), add(mul(v[2], m[29][18]), mul(v[3], m[29][19])))));
-    tmp[30] = add(tmp[30], add(mul(v[0], m[30][16]), add(mul(v[1], m[30][17]), add(mul(v[2], m[30][18]), mul(v[3], m[30][19])))));
-    tmp[31] = add(tmp[31], add(mul(v[0], m[31][16]), add(mul(v[1], m[31][17]), add(mul(v[2], m[31][18]), mul(v[3], m[31][19])))));
+    tmp[0] = add(tmp[0],
+                 add(mul(v[0], m[0][16]), add(mul(v[1], m[0][17]), add(mul(v[2], m[0][18]), mul(v[3], m[0][19])))));
+    tmp[1] = add(tmp[1],
+                 add(mul(v[0], m[1][16]), add(mul(v[1], m[1][17]), add(mul(v[2], m[1][18]), mul(v[3], m[1][19])))));
+    tmp[2] = add(tmp[2],
+                 add(mul(v[0], m[2][16]), add(mul(v[1], m[2][17]), add(mul(v[2], m[2][18]), mul(v[3], m[2][19])))));
+    tmp[3] = add(tmp[3],
+                 add(mul(v[0], m[3][16]), add(mul(v[1], m[3][17]), add(mul(v[2], m[3][18]), mul(v[3], m[3][19])))));
+    tmp[4] = add(tmp[4],
+                 add(mul(v[0], m[4][16]), add(mul(v[1], m[4][17]), add(mul(v[2], m[4][18]), mul(v[3], m[4][19])))));
+    tmp[5] = add(tmp[5],
+                 add(mul(v[0], m[5][16]), add(mul(v[1], m[5][17]), add(mul(v[2], m[5][18]), mul(v[3], m[5][19])))));
+    tmp[6] = add(tmp[6],
+                 add(mul(v[0], m[6][16]), add(mul(v[1], m[6][17]), add(mul(v[2], m[6][18]), mul(v[3], m[6][19])))));
+    tmp[7] = add(tmp[7],
+                 add(mul(v[0], m[7][16]), add(mul(v[1], m[7][17]), add(mul(v[2], m[7][18]), mul(v[3], m[7][19])))));
+    tmp[8] = add(tmp[8],
+                 add(mul(v[0], m[8][16]), add(mul(v[1], m[8][17]), add(mul(v[2], m[8][18]), mul(v[3], m[8][19])))));
+    tmp[9] = add(tmp[9],
+                 add(mul(v[0], m[9][16]), add(mul(v[1], m[9][17]), add(mul(v[2], m[9][18]), mul(v[3], m[9][19])))));
+    tmp[10] = add(
+        tmp[10], add(mul(v[0], m[10][16]), add(mul(v[1], m[10][17]), add(mul(v[2], m[10][18]), mul(v[3], m[10][19])))));
+    tmp[11] = add(
+        tmp[11], add(mul(v[0], m[11][16]), add(mul(v[1], m[11][17]), add(mul(v[2], m[11][18]), mul(v[3], m[11][19])))));
+    tmp[12] = add(
+        tmp[12], add(mul(v[0], m[12][16]), add(mul(v[1], m[12][17]), add(mul(v[2], m[12][18]), mul(v[3], m[12][19])))));
+    tmp[13] = add(
+        tmp[13], add(mul(v[0], m[13][16]), add(mul(v[1], m[13][17]), add(mul(v[2], m[13][18]), mul(v[3], m[13][19])))));
+    tmp[14] = add(
+        tmp[14], add(mul(v[0], m[14][16]), add(mul(v[1], m[14][17]), add(mul(v[2], m[14][18]), mul(v[3], m[14][19])))));
+    tmp[15] = add(
+        tmp[15], add(mul(v[0], m[15][16]), add(mul(v[1], m[15][17]), add(mul(v[2], m[15][18]), mul(v[3], m[15][19])))));
+    tmp[16] = add(
+        tmp[16], add(mul(v[0], m[16][16]), add(mul(v[1], m[16][17]), add(mul(v[2], m[16][18]), mul(v[3], m[16][19])))));
+    tmp[17] = add(
+        tmp[17], add(mul(v[0], m[17][16]), add(mul(v[1], m[17][17]), add(mul(v[2], m[17][18]), mul(v[3], m[17][19])))));
+    tmp[18] = add(
+        tmp[18], add(mul(v[0], m[18][16]), add(mul(v[1], m[18][17]), add(mul(v[2], m[18][18]), mul(v[3], m[18][19])))));
+    tmp[19] = add(
+        tmp[19], add(mul(v[0], m[19][16]), add(mul(v[1], m[19][17]), add(mul(v[2], m[19][18]), mul(v[3], m[19][19])))));
+    tmp[20] = add(
+        tmp[20], add(mul(v[0], m[20][16]), add(mul(v[1], m[20][17]), add(mul(v[2], m[20][18]), mul(v[3], m[20][19])))));
+    tmp[21] = add(
+        tmp[21], add(mul(v[0], m[21][16]), add(mul(v[1], m[21][17]), add(mul(v[2], m[21][18]), mul(v[3], m[21][19])))));
+    tmp[22] = add(
+        tmp[22], add(mul(v[0], m[22][16]), add(mul(v[1], m[22][17]), add(mul(v[2], m[22][18]), mul(v[3], m[22][19])))));
+    tmp[23] = add(
+        tmp[23], add(mul(v[0], m[23][16]), add(mul(v[1], m[23][17]), add(mul(v[2], m[23][18]), mul(v[3], m[23][19])))));
+    tmp[24] = add(
+        tmp[24], add(mul(v[0], m[24][16]), add(mul(v[1], m[24][17]), add(mul(v[2], m[24][18]), mul(v[3], m[24][19])))));
+    tmp[25] = add(
+        tmp[25], add(mul(v[0], m[25][16]), add(mul(v[1], m[25][17]), add(mul(v[2], m[25][18]), mul(v[3], m[25][19])))));
+    tmp[26] = add(
+        tmp[26], add(mul(v[0], m[26][16]), add(mul(v[1], m[26][17]), add(mul(v[2], m[26][18]), mul(v[3], m[26][19])))));
+    tmp[27] = add(
+        tmp[27], add(mul(v[0], m[27][16]), add(mul(v[1], m[27][17]), add(mul(v[2], m[27][18]), mul(v[3], m[27][19])))));
+    tmp[28] = add(
+        tmp[28], add(mul(v[0], m[28][16]), add(mul(v[1], m[28][17]), add(mul(v[2], m[28][18]), mul(v[3], m[28][19])))));
+    tmp[29] = add(
+        tmp[29], add(mul(v[0], m[29][16]), add(mul(v[1], m[29][17]), add(mul(v[2], m[29][18]), mul(v[3], m[29][19])))));
+    tmp[30] = add(
+        tmp[30], add(mul(v[0], m[30][16]), add(mul(v[1], m[30][17]), add(mul(v[2], m[30][18]), mul(v[3], m[30][19])))));
+    tmp[31] = add(
+        tmp[31], add(mul(v[0], m[31][16]), add(mul(v[1], m[31][17]), add(mul(v[2], m[31][18]), mul(v[3], m[31][19])))));
 
     v[0] = psi[I + d2 + d4];
     v[1] = psi[I + d0 + d2 + d4];
     v[2] = psi[I + d1 + d2 + d4];
     v[3] = psi[I + d0 + d1 + d2 + d4];
 
-    tmp[0] = add(tmp[0], add(mul(v[0], m[0][20]), add(mul(v[1], m[0][21]), add(mul(v[2], m[0][22]), mul(v[3], m[0][23])))));
-    tmp[1] = add(tmp[1], add(mul(v[0], m[1][20]), add(mul(v[1], m[1][21]), add(mul(v[2], m[1][22]), mul(v[3], m[1][23])))));
-    tmp[2] = add(tmp[2], add(mul(v[0], m[2][20]), add(mul(v[1], m[2][21]), add(mul(v[2], m[2][22]), mul(v[3], m[2][23])))));
-    tmp[3] = add(tmp[3], add(mul(v[0], m[3][20]), add(mul(v[1], m[3][21]), add(mul(v[2], m[3][22]), mul(v[3], m[3][23])))));
-    tmp[4] = add(tmp[4], add(mul(v[0], m[4][20]), add(mul(v[1], m[4][21]), add(mul(v[2], m[4][22]), mul(v[3], m[4][23])))));
-    tmp[5] = add(tmp[5], add(mul(v[0], m[5][20]), add(mul(v[1], m[5][21]), add(mul(v[2], m[5][22]), mul(v[3], m[5][23])))));
-    tmp[6] = add(tmp[6], add(mul(v[0], m[6][20]), add(mul(v[1], m[6][21]), add(mul(v[2], m[6][22]), mul(v[3], m[6][23])))));
-    tmp[7] = add(tmp[7], add(mul(v[0], m[7][20]), add(mul(v[1], m[7][21]), add(mul(v[2], m[7][22]), mul(v[3], m[7][23])))));
-    tmp[8] = add(tmp[8], add(mul(v[0], m[8][20]), add(mul(v[1], m[8][21]), add(mul(v[2], m[8][22]), mul(v[3], m[8][23])))));
-    tmp[9] = add(tmp[9], add(mul(v[0], m[9][20]), add(mul(v[1], m[9][21]), add(mul(v[2], m[9][22]), mul(v[3], m[9][23])))));
-    tmp[10] = add(tmp[10], add(mul(v[0], m[10][20]), add(mul(v[1], m[10][21]), add(mul(v[2], m[10][22]), mul(v[3], m[10][23])))));
-    tmp[11] = add(tmp[11], add(mul(v[0], m[11][20]), add(mul(v[1], m[11][21]), add(mul(v[2], m[11][22]), mul(v[3], m[11][23])))));
-    tmp[12] = add(tmp[12], add(mul(v[0], m[12][20]), add(mul(v[1], m[12][21]), add(mul(v[2], m[12][22]), mul(v[3], m[12][23])))));
-    tmp[13] = add(tmp[13], add(mul(v[0], m[13][20]), add(mul(v[1], m[13][21]), add(mul(v[2], m[13][22]), mul(v[3], m[13][23])))));
-    tmp[14] = add(tmp[14], add(mul(v[0], m[14][20]), add(mul(v[1], m[14][21]), add(mul(v[2], m[14][22]), mul(v[3], m[14][23])))));
-    tmp[15] = add(tmp[15], add(mul(v[0], m[15][20]), add(mul(v[1], m[15][21]), add(mul(v[2], m[15][22]), mul(v[3], m[15][23])))));
-    tmp[16] = add(tmp[16], add(mul(v[0], m[16][20]), add(mul(v[1], m[16][21]), add(mul(v[2], m[16][22]), mul(v[3], m[16][23])))));
-    tmp[17] = add(tmp[17], add(mul(v[0], m[17][20]), add(mul(v[1], m[17][21]), add(mul(v[2], m[17][22]), mul(v[3], m[17][23])))));
-    tmp[18] = add(tmp[18], add(mul(v[0], m[18][20]), add(mul(v[1], m[18][21]), add(mul(v[2], m[18][22]), mul(v[3], m[18][23])))));
-    tmp[19] = add(tmp[19], add(mul(v[0], m[19][20]), add(mul(v[1], m[19][21]), add(mul(v[2], m[19][22]), mul(v[3], m[19][23])))));
-    tmp[20] = add(tmp[20], add(mul(v[0], m[20][20]), add(mul(v[1], m[20][21]), add(mul(v[2], m[20][22]), mul(v[3], m[20][23])))));
-    tmp[21] = add(tmp[21], add(mul(v[0], m[21][20]), add(mul(v[1], m[21][21]), add(mul(v[2], m[21][22]), mul(v[3], m[21][23])))));
-    tmp[22] = add(tmp[22], add(mul(v[0], m[22][20]), add(mul(v[1], m[22][21]), add(mul(v[2], m[22][22]), mul(v[3], m[22][23])))));
-    tmp[23] = add(tmp[23], add(mul(v[0], m[23][20]), add(mul(v[1], m[23][21]), add(mul(v[2], m[23][22]), mul(v[3], m[23][23])))));
-    tmp[24] = add(tmp[24], add(mul(v[0], m[24][20]), add(mul(v[1], m[24][21]), add(mul(v[2], m[24][22]), mul(v[3], m[24][23])))));
-    tmp[25] = add(tmp[25], add(mul(v[0], m[25][20]), add(mul(v[1], m[25][21]), add(mul(v[2], m[25][22]), mul(v[3], m[25][23])))));
-    tmp[26] = add(tmp[26], add(mul(v[0], m[26][20]), add(mul(v[1], m[26][21]), add(mul(v[2], m[26][22]), mul(v[3], m[26][23])))));
-    tmp[27] = add(tmp[27], add(mul(v[0], m[27][20]), add(mul(v[1], m[27][21]), add(mul(v[2], m[27][22]), mul(v[3], m[27][23])))));
-    tmp[28] = add(tmp[28], add(mul(v[0], m[28][20]), add(mul(v[1], m[28][21]), add(mul(v[2], m[28][22]), mul(v[3], m[28][23])))));
-    tmp[29] = add(tmp[29], add(mul(v[0], m[29][20]), add(mul(v[1], m[29][21]), add(mul(v[2], m[29][22]), mul(v[3], m[29][23])))));
-    tmp[30] = add(tmp[30], add(mul(v[0], m[30][20]), add(mul(v[1], m[30][21]), add(mul(v[2], m[30][22]), mul(v[3], m[30][23])))));
-    tmp[31] = add(tmp[31], add(mul(v[0], m[31][20]), add(mul(v[1], m[31][21]), add(mul(v[2], m[31][22]), mul(v[3], m[31][23])))));
+    tmp[0] = add(tmp[0],
+                 add(mul(v[0], m[0][20]), add(mul(v[1], m[0][21]), add(mul(v[2], m[0][22]), mul(v[3], m[0][23])))));
+    tmp[1] = add(tmp[1],
+                 add(mul(v[0], m[1][20]), add(mul(v[1], m[1][21]), add(mul(v[2], m[1][22]), mul(v[3], m[1][23])))));
+    tmp[2] = add(tmp[2],
+                 add(mul(v[0], m[2][20]), add(mul(v[1], m[2][21]), add(mul(v[2], m[2][22]), mul(v[3], m[2][23])))));
+    tmp[3] = add(tmp[3],
+                 add(mul(v[0], m[3][20]), add(mul(v[1], m[3][21]), add(mul(v[2], m[3][22]), mul(v[3], m[3][23])))));
+    tmp[4] = add(tmp[4],
+                 add(mul(v[0], m[4][20]), add(mul(v[1], m[4][21]), add(mul(v[2], m[4][22]), mul(v[3], m[4][23])))));
+    tmp[5] = add(tmp[5],
+                 add(mul(v[0], m[5][20]), add(mul(v[1], m[5][21]), add(mul(v[2], m[5][22]), mul(v[3], m[5][23])))));
+    tmp[6] = add(tmp[6],
+                 add(mul(v[0], m[6][20]), add(mul(v[1], m[6][21]), add(mul(v[2], m[6][22]), mul(v[3], m[6][23])))));
+    tmp[7] = add(tmp[7],
+                 add(mul(v[0], m[7][20]), add(mul(v[1], m[7][21]), add(mul(v[2], m[7][22]), mul(v[3], m[7][23])))));
+    tmp[8] = add(tmp[8],
+                 add(mul(v[0], m[8][20]), add(mul(v[1], m[8][21]), add(mul(v[2], m[8][22]), mul(v[3], m[8][23])))));
+    tmp[9] = add(tmp[9],
+                 add(mul(v[0], m[9][20]), add(mul(v[1], m[9][21]), add(mul(v[2], m[9][22]), mul(v[3], m[9][23])))));
+    tmp[10] = add(
+        tmp[10], add(mul(v[0], m[10][20]), add(mul(v[1], m[10][21]), add(mul(v[2], m[10][22]), mul(v[3], m[10][23])))));
+    tmp[11] = add(
+        tmp[11], add(mul(v[0], m[11][20]), add(mul(v[1], m[11][21]), add(mul(v[2], m[11][22]), mul(v[3], m[11][23])))));
+    tmp[12] = add(
+        tmp[12], add(mul(v[0], m[12][20]), add(mul(v[1], m[12][21]), add(mul(v[2], m[12][22]), mul(v[3], m[12][23])))));
+    tmp[13] = add(
+        tmp[13], add(mul(v[0], m[13][20]), add(mul(v[1], m[13][21]), add(mul(v[2], m[13][22]), mul(v[3], m[13][23])))));
+    tmp[14] = add(
+        tmp[14], add(mul(v[0], m[14][20]), add(mul(v[1], m[14][21]), add(mul(v[2], m[14][22]), mul(v[3], m[14][23])))));
+    tmp[15] = add(
+        tmp[15], add(mul(v[0], m[15][20]), add(mul(v[1], m[15][21]), add(mul(v[2], m[15][22]), mul(v[3], m[15][23])))));
+    tmp[16] = add(
+        tmp[16], add(mul(v[0], m[16][20]), add(mul(v[1], m[16][21]), add(mul(v[2], m[16][22]), mul(v[3], m[16][23])))));
+    tmp[17] = add(
+        tmp[17], add(mul(v[0], m[17][20]), add(mul(v[1], m[17][21]), add(mul(v[2], m[17][22]), mul(v[3], m[17][23])))));
+    tmp[18] = add(
+        tmp[18], add(mul(v[0], m[18][20]), add(mul(v[1], m[18][21]), add(mul(v[2], m[18][22]), mul(v[3], m[18][23])))));
+    tmp[19] = add(
+        tmp[19], add(mul(v[0], m[19][20]), add(mul(v[1], m[19][21]), add(mul(v[2], m[19][22]), mul(v[3], m[19][23])))));
+    tmp[20] = add(
+        tmp[20], add(mul(v[0], m[20][20]), add(mul(v[1], m[20][21]), add(mul(v[2], m[20][22]), mul(v[3], m[20][23])))));
+    tmp[21] = add(
+        tmp[21], add(mul(v[0], m[21][20]), add(mul(v[1], m[21][21]), add(mul(v[2], m[21][22]), mul(v[3], m[21][23])))));
+    tmp[22] = add(
+        tmp[22], add(mul(v[0], m[22][20]), add(mul(v[1], m[22][21]), add(mul(v[2], m[22][22]), mul(v[3], m[22][23])))));
+    tmp[23] = add(
+        tmp[23], add(mul(v[0], m[23][20]), add(mul(v[1], m[23][21]), add(mul(v[2], m[23][22]), mul(v[3], m[23][23])))));
+    tmp[24] = add(
+        tmp[24], add(mul(v[0], m[24][20]), add(mul(v[1], m[24][21]), add(mul(v[2], m[24][22]), mul(v[3], m[24][23])))));
+    tmp[25] = add(
+        tmp[25], add(mul(v[0], m[25][20]), add(mul(v[1], m[25][21]), add(mul(v[2], m[25][22]), mul(v[3], m[25][23])))));
+    tmp[26] = add(
+        tmp[26], add(mul(v[0], m[26][20]), add(mul(v[1], m[26][21]), add(mul(v[2], m[26][22]), mul(v[3], m[26][23])))));
+    tmp[27] = add(
+        tmp[27], add(mul(v[0], m[27][20]), add(mul(v[1], m[27][21]), add(mul(v[2], m[27][22]), mul(v[3], m[27][23])))));
+    tmp[28] = add(
+        tmp[28], add(mul(v[0], m[28][20]), add(mul(v[1], m[28][21]), add(mul(v[2], m[28][22]), mul(v[3], m[28][23])))));
+    tmp[29] = add(
+        tmp[29], add(mul(v[0], m[29][20]), add(mul(v[1], m[29][21]), add(mul(v[2], m[29][22]), mul(v[3], m[29][23])))));
+    tmp[30] = add(
+        tmp[30], add(mul(v[0], m[30][20]), add(mul(v[1], m[30][21]), add(mul(v[2], m[30][22]), mul(v[3], m[30][23])))));
+    tmp[31] = add(
+        tmp[31], add(mul(v[0], m[31][20]), add(mul(v[1], m[31][21]), add(mul(v[2], m[31][22]), mul(v[3], m[31][23])))));
 
     v[0] = psi[I + d3 + d4];
     v[1] = psi[I + d0 + d3 + d4];
     v[2] = psi[I + d1 + d3 + d4];
     v[3] = psi[I + d0 + d1 + d3 + d4];
 
-    tmp[0] = add(tmp[0], add(mul(v[0], m[0][24]), add(mul(v[1], m[0][25]), add(mul(v[2], m[0][26]), mul(v[3], m[0][27])))));
-    tmp[1] = add(tmp[1], add(mul(v[0], m[1][24]), add(mul(v[1], m[1][25]), add(mul(v[2], m[1][26]), mul(v[3], m[1][27])))));
-    tmp[2] = add(tmp[2], add(mul(v[0], m[2][24]), add(mul(v[1], m[2][25]), add(mul(v[2], m[2][26]), mul(v[3], m[2][27])))));
-    tmp[3] = add(tmp[3], add(mul(v[0], m[3][24]), add(mul(v[1], m[3][25]), add(mul(v[2], m[3][26]), mul(v[3], m[3][27])))));
-    tmp[4] = add(tmp[4], add(mul(v[0], m[4][24]), add(mul(v[1], m[4][25]), add(mul(v[2], m[4][26]), mul(v[3], m[4][27])))));
-    tmp[5] = add(tmp[5], add(mul(v[0], m[5][24]), add(mul(v[1], m[5][25]), add(mul(v[2], m[5][26]), mul(v[3], m[5][27])))));
-    tmp[6] = add(tmp[6], add(mul(v[0], m[6][24]), add(mul(v[1], m[6][25]), add(mul(v[2], m[6][26]), mul(v[3], m[6][27])))));
-    tmp[7] = add(tmp[7], add(mul(v[0], m[7][24]), add(mul(v[1], m[7][25]), add(mul(v[2], m[7][26]), mul(v[3], m[7][27])))));
-    tmp[8] = add(tmp[8], add(mul(v[0], m[8][24]), add(mul(v[1], m[8][25]), add(mul(v[2], m[8][26]), mul(v[3], m[8][27])))));
-    tmp[9] = add(tmp[9], add(mul(v[0], m[9][24]), add(mul(v[1], m[9][25]), add(mul(v[2], m[9][26]), mul(v[3], m[9][27])))));
-    tmp[10] = add(tmp[10], add(mul(v[0], m[10][24]), add(mul(v[1], m[10][25]), add(mul(v[2], m[10][26]), mul(v[3], m[10][27])))));
-    tmp[11] = add(tmp[11], add(mul(v[0], m[11][24]), add(mul(v[1], m[11][25]), add(mul(v[2], m[11][26]), mul(v[3], m[11][27])))));
-    tmp[12] = add(tmp[12], add(mul(v[0], m[12][24]), add(mul(v[1], m[12][25]), add(mul(v[2], m[12][26]), mul(v[3], m[12][27])))));
-    tmp[13] = add(tmp[13], add(mul(v[0], m[13][24]), add(mul(v[1], m[13][25]), add(mul(v[2], m[13][26]), mul(v[3], m[13][27])))));
-    tmp[14] = add(tmp[14], add(mul(v[0], m[14][24]), add(mul(v[1], m[14][25]), add(mul(v[2], m[14][26]), mul(v[3], m[14][27])))));
-    tmp[15] = add(tmp[15], add(mul(v[0], m[15][24]), add(mul(v[1], m[15][25]), add(mul(v[2], m[15][26]), mul(v[3], m[15][27])))));
-    tmp[16] = add(tmp[16], add(mul(v[0], m[16][24]), add(mul(v[1], m[16][25]), add(mul(v[2], m[16][26]), mul(v[3], m[16][27])))));
-    tmp[17] = add(tmp[17], add(mul(v[0], m[17][24]), add(mul(v[1], m[17][25]), add(mul(v[2], m[17][26]), mul(v[3], m[17][27])))));
-    tmp[18] = add(tmp[18], add(mul(v[0], m[18][24]), add(mul(v[1], m[18][25]), add(mul(v[2], m[18][26]), mul(v[3], m[18][27])))));
-    tmp[19] = add(tmp[19], add(mul(v[0], m[19][24]), add(mul(v[1], m[19][25]), add(mul(v[2], m[19][26]), mul(v[3], m[19][27])))));
-    tmp[20] = add(tmp[20], add(mul(v[0], m[20][24]), add(mul(v[1], m[20][25]), add(mul(v[2], m[20][26]), mul(v[3], m[20][27])))));
-    tmp[21] = add(tmp[21], add(mul(v[0], m[21][24]), add(mul(v[1], m[21][25]), add(mul(v[2], m[21][26]), mul(v[3], m[21][27])))));
-    tmp[22] = add(tmp[22], add(mul(v[0], m[22][24]), add(mul(v[1], m[22][25]), add(mul(v[2], m[22][26]), mul(v[3], m[22][27])))));
-    tmp[23] = add(tmp[23], add(mul(v[0], m[23][24]), add(mul(v[1], m[23][25]), add(mul(v[2], m[23][26]), mul(v[3], m[23][27])))));
-    tmp[24] = add(tmp[24], add(mul(v[0], m[24][24]), add(mul(v[1], m[24][25]), add(mul(v[2], m[24][26]), mul(v[3], m[24][27])))));
-    tmp[25] = add(tmp[25], add(mul(v[0], m[25][24]), add(mul(v[1], m[25][25]), add(mul(v[2], m[25][26]), mul(v[3], m[25][27])))));
-    tmp[26] = add(tmp[26], add(mul(v[0], m[26][24]), add(mul(v[1], m[26][25]), add(mul(v[2], m[26][26]), mul(v[3], m[26][27])))));
-    tmp[27] = add(tmp[27], add(mul(v[0], m[27][24]), add(mul(v[1], m[27][25]), add(mul(v[2], m[27][26]), mul(v[3], m[27][27])))));
-    tmp[28] = add(tmp[28], add(mul(v[0], m[28][24]), add(mul(v[1], m[28][25]), add(mul(v[2], m[28][26]), mul(v[3], m[28][27])))));
-    tmp[29] = add(tmp[29], add(mul(v[0], m[29][24]), add(mul(v[1], m[29][25]), add(mul(v[2], m[29][26]), mul(v[3], m[29][27])))));
-    tmp[30] = add(tmp[30], add(mul(v[0], m[30][24]), add(mul(v[1], m[30][25]), add(mul(v[2], m[30][26]), mul(v[3], m[30][27])))));
-    tmp[31] = add(tmp[31], add(mul(v[0], m[31][24]), add(mul(v[1], m[31][25]), add(mul(v[2], m[31][26]), mul(v[3], m[31][27])))));
+    tmp[0] = add(tmp[0],
+                 add(mul(v[0], m[0][24]), add(mul(v[1], m[0][25]), add(mul(v[2], m[0][26]), mul(v[3], m[0][27])))));
+    tmp[1] = add(tmp[1],
+                 add(mul(v[0], m[1][24]), add(mul(v[1], m[1][25]), add(mul(v[2], m[1][26]), mul(v[3], m[1][27])))));
+    tmp[2] = add(tmp[2],
+                 add(mul(v[0], m[2][24]), add(mul(v[1], m[2][25]), add(mul(v[2], m[2][26]), mul(v[3], m[2][27])))));
+    tmp[3] = add(tmp[3],
+                 add(mul(v[0], m[3][24]), add(mul(v[1], m[3][25]), add(mul(v[2], m[3][26]), mul(v[3], m[3][27])))));
+    tmp[4] = add(tmp[4],
+                 add(mul(v[0], m[4][24]), add(mul(v[1], m[4][25]), add(mul(v[2], m[4][26]), mul(v[3], m[4][27])))));
+    tmp[5] = add(tmp[5],
+                 add(mul(v[0], m[5][24]), add(mul(v[1], m[5][25]), add(mul(v[2], m[5][26]), mul(v[3], m[5][27])))));
+    tmp[6] = add(tmp[6],
+                 add(mul(v[0], m[6][24]), add(mul(v[1], m[6][25]), add(mul(v[2], m[6][26]), mul(v[3], m[6][27])))));
+    tmp[7] = add(tmp[7],
+                 add(mul(v[0], m[7][24]), add(mul(v[1], m[7][25]), add(mul(v[2], m[7][26]), mul(v[3], m[7][27])))));
+    tmp[8] = add(tmp[8],
+                 add(mul(v[0], m[8][24]), add(mul(v[1], m[8][25]), add(mul(v[2], m[8][26]), mul(v[3], m[8][27])))));
+    tmp[9] = add(tmp[9],
+                 add(mul(v[0], m[9][24]), add(mul(v[1], m[9][25]), add(mul(v[2], m[9][26]), mul(v[3], m[9][27])))));
+    tmp[10] = add(
+        tmp[10], add(mul(v[0], m[10][24]), add(mul(v[1], m[10][25]), add(mul(v[2], m[10][26]), mul(v[3], m[10][27])))));
+    tmp[11] = add(
+        tmp[11], add(mul(v[0], m[11][24]), add(mul(v[1], m[11][25]), add(mul(v[2], m[11][26]), mul(v[3], m[11][27])))));
+    tmp[12] = add(
+        tmp[12], add(mul(v[0], m[12][24]), add(mul(v[1], m[12][25]), add(mul(v[2], m[12][26]), mul(v[3], m[12][27])))));
+    tmp[13] = add(
+        tmp[13], add(mul(v[0], m[13][24]), add(mul(v[1], m[13][25]), add(mul(v[2], m[13][26]), mul(v[3], m[13][27])))));
+    tmp[14] = add(
+        tmp[14], add(mul(v[0], m[14][24]), add(mul(v[1], m[14][25]), add(mul(v[2], m[14][26]), mul(v[3], m[14][27])))));
+    tmp[15] = add(
+        tmp[15], add(mul(v[0], m[15][24]), add(mul(v[1], m[15][25]), add(mul(v[2], m[15][26]), mul(v[3], m[15][27])))));
+    tmp[16] = add(
+        tmp[16], add(mul(v[0], m[16][24]), add(mul(v[1], m[16][25]), add(mul(v[2], m[16][26]), mul(v[3], m[16][27])))));
+    tmp[17] = add(
+        tmp[17], add(mul(v[0], m[17][24]), add(mul(v[1], m[17][25]), add(mul(v[2], m[17][26]), mul(v[3], m[17][27])))));
+    tmp[18] = add(
+        tmp[18], add(mul(v[0], m[18][24]), add(mul(v[1], m[18][25]), add(mul(v[2], m[18][26]), mul(v[3], m[18][27])))));
+    tmp[19] = add(
+        tmp[19], add(mul(v[0], m[19][24]), add(mul(v[1], m[19][25]), add(mul(v[2], m[19][26]), mul(v[3], m[19][27])))));
+    tmp[20] = add(
+        tmp[20], add(mul(v[0], m[20][24]), add(mul(v[1], m[20][25]), add(mul(v[2], m[20][26]), mul(v[3], m[20][27])))));
+    tmp[21] = add(
+        tmp[21], add(mul(v[0], m[21][24]), add(mul(v[1], m[21][25]), add(mul(v[2], m[21][26]), mul(v[3], m[21][27])))));
+    tmp[22] = add(
+        tmp[22], add(mul(v[0], m[22][24]), add(mul(v[1], m[22][25]), add(mul(v[2], m[22][26]), mul(v[3], m[22][27])))));
+    tmp[23] = add(
+        tmp[23], add(mul(v[0], m[23][24]), add(mul(v[1], m[23][25]), add(mul(v[2], m[23][26]), mul(v[3], m[23][27])))));
+    tmp[24] = add(
+        tmp[24], add(mul(v[0], m[24][24]), add(mul(v[1], m[24][25]), add(mul(v[2], m[24][26]), mul(v[3], m[24][27])))));
+    tmp[25] = add(
+        tmp[25], add(mul(v[0], m[25][24]), add(mul(v[1], m[25][25]), add(mul(v[2], m[25][26]), mul(v[3], m[25][27])))));
+    tmp[26] = add(
+        tmp[26], add(mul(v[0], m[26][24]), add(mul(v[1], m[26][25]), add(mul(v[2], m[26][26]), mul(v[3], m[26][27])))));
+    tmp[27] = add(
+        tmp[27], add(mul(v[0], m[27][24]), add(mul(v[1], m[27][25]), add(mul(v[2], m[27][26]), mul(v[3], m[27][27])))));
+    tmp[28] = add(
+        tmp[28], add(mul(v[0], m[28][24]), add(mul(v[1], m[28][25]), add(mul(v[2], m[28][26]), mul(v[3], m[28][27])))));
+    tmp[29] = add(
+        tmp[29], add(mul(v[0], m[29][24]), add(mul(v[1], m[29][25]), add(mul(v[2], m[29][26]), mul(v[3], m[29][27])))));
+    tmp[30] = add(
+        tmp[30], add(mul(v[0], m[30][24]), add(mul(v[1], m[30][25]), add(mul(v[2], m[30][26]), mul(v[3], m[30][27])))));
+    tmp[31] = add(
+        tmp[31], add(mul(v[0], m[31][24]), add(mul(v[1], m[31][25]), add(mul(v[2], m[31][26]), mul(v[3], m[31][27])))));
 
     v[0] = psi[I + d2 + d3 + d4];
     v[1] = psi[I + d0 + d2 + d3 + d4];
     v[2] = psi[I + d1 + d2 + d3 + d4];
     v[3] = psi[I + d0 + d1 + d2 + d3 + d4];
 
-    psi[I] = (add(tmp[0], add(mul(v[0], m[0][28]), add(mul(v[1], m[0][29]), add(mul(v[2], m[0][30]), mul(v[3], m[0][31]))))));
-    psi[I + d0] = (add(tmp[1], add(mul(v[0], m[1][28]), add(mul(v[1], m[1][29]), add(mul(v[2], m[1][30]), mul(v[3], m[1][31]))))));
-    psi[I + d1] = (add(tmp[2], add(mul(v[0], m[2][28]), add(mul(v[1], m[2][29]), add(mul(v[2], m[2][30]), mul(v[3], m[2][31]))))));
-    psi[I + d0 + d1] = (add(tmp[3], add(mul(v[0], m[3][28]), add(mul(v[1], m[3][29]), add(mul(v[2], m[3][30]), mul(v[3], m[3][31]))))));
-    psi[I + d2] = (add(tmp[4], add(mul(v[0], m[4][28]), add(mul(v[1], m[4][29]), add(mul(v[2], m[4][30]), mul(v[3], m[4][31]))))));
-    psi[I + d0 + d2] = (add(tmp[5], add(mul(v[0], m[5][28]), add(mul(v[1], m[5][29]), add(mul(v[2], m[5][30]), mul(v[3], m[5][31]))))));
-    psi[I + d1 + d2] = (add(tmp[6], add(mul(v[0], m[6][28]), add(mul(v[1], m[6][29]), add(mul(v[2], m[6][30]), mul(v[3], m[6][31]))))));
-    psi[I + d0 + d1 + d2] = (add(tmp[7], add(mul(v[0], m[7][28]), add(mul(v[1], m[7][29]), add(mul(v[2], m[7][30]), mul(v[3], m[7][31]))))));
-    psi[I + d3] = (add(tmp[8], add(mul(v[0], m[8][28]), add(mul(v[1], m[8][29]), add(mul(v[2], m[8][30]), mul(v[3], m[8][31]))))));
-    psi[I + d0 + d3] = (add(tmp[9], add(mul(v[0], m[9][28]), add(mul(v[1], m[9][29]), add(mul(v[2], m[9][30]), mul(v[3], m[9][31]))))));
-    psi[I + d1 + d3] = (add(tmp[10], add(mul(v[0], m[10][28]), add(mul(v[1], m[10][29]), add(mul(v[2], m[10][30]), mul(v[3], m[10][31]))))));
-    psi[I + d0 + d1 + d3] = (add(tmp[11], add(mul(v[0], m[11][28]), add(mul(v[1], m[11][29]), add(mul(v[2], m[11][30]), mul(v[3], m[11][31]))))));
-    psi[I + d2 + d3] = (add(tmp[12], add(mul(v[0], m[12][28]), add(mul(v[1], m[12][29]), add(mul(v[2], m[12][30]), mul(v[3], m[12][31]))))));
-    psi[I + d0 + d2 + d3] = (add(tmp[13], add(mul(v[0], m[13][28]), add(mul(v[1], m[13][29]), add(mul(v[2], m[13][30]), mul(v[3], m[13][31]))))));
-    psi[I + d1 + d2 + d3] = (add(tmp[14], add(mul(v[0], m[14][28]), add(mul(v[1], m[14][29]), add(mul(v[2], m[14][30]), mul(v[3], m[14][31]))))));
-    psi[I + d0 + d1 + d2 + d3] = (add(tmp[15], add(mul(v[0], m[15][28]), add(mul(v[1], m[15][29]), add(mul(v[2], m[15][30]), mul(v[3], m[15][31]))))));
-    psi[I + d4] = (add(tmp[16], add(mul(v[0], m[16][28]), add(mul(v[1], m[16][29]), add(mul(v[2], m[16][30]), mul(v[3], m[16][31]))))));
-    psi[I + d0 + d4] = (add(tmp[17], add(mul(v[0], m[17][28]), add(mul(v[1], m[17][29]), add(mul(v[2], m[17][30]), mul(v[3], m[17][31]))))));
-    psi[I + d1 + d4] = (add(tmp[18], add(mul(v[0], m[18][28]), add(mul(v[1], m[18][29]), add(mul(v[2], m[18][30]), mul(v[3], m[18][31]))))));
-    psi[I + d0 + d1 + d4] = (add(tmp[19], add(mul(v[0], m[19][28]), add(mul(v[1], m[19][29]), add(mul(v[2], m[19][30]), mul(v[3], m[19][31]))))));
-    psi[I + d2 + d4] = (add(tmp[20], add(mul(v[0], m[20][28]), add(mul(v[1], m[20][29]), add(mul(v[2], m[20][30]), mul(v[3], m[20][31]))))));
-    psi[I + d0 + d2 + d4] = (add(tmp[21], add(mul(v[0], m[21][28]), add(mul(v[1], m[21][29]), add(mul(v[2], m[21][30]), mul(v[3], m[21][31]))))));
-    psi[I + d1 + d2 + d4] = (add(tmp[22], add(mul(v[0], m[22][28]), add(mul(v[1], m[22][29]), add(mul(v[2], m[22][30]), mul(v[3], m[22][31]))))));
-    psi[I + d0 + d1 + d2 + d4] = (add(tmp[23], add(mul(v[0], m[23][28]), add(mul(v[1], m[23][29]), add(mul(v[2], m[23][30]), mul(v[3], m[23][31]))))));
-    psi[I + d3 + d4] = (add(tmp[24], add(mul(v[0], m[24][28]), add(mul(v[1], m[24][29]), add(mul(v[2], m[24][30]), mul(v[3], m[24][31]))))));
-    psi[I + d0 + d3 + d4] = (add(tmp[25], add(mul(v[0], m[25][28]), add(mul(v[1], m[25][29]), add(mul(v[2], m[25][30]), mul(v[3], m[25][31]))))));
-    psi[I + d1 + d3 + d4] = (add(tmp[26], add(mul(v[0], m[26][28]), add(mul(v[1], m[26][29]), add(mul(v[2], m[26][30]), mul(v[3], m[26][31]))))));
-    psi[I + d0 + d1 + d3 + d4] = (add(tmp[27], add(mul(v[0], m[27][28]), add(mul(v[1], m[27][29]), add(mul(v[2], m[27][30]), mul(v[3], m[27][31]))))));
-    psi[I + d2 + d3 + d4] = (add(tmp[28], add(mul(v[0], m[28][28]), add(mul(v[1], m[28][29]), add(mul(v[2], m[28][30]), mul(v[3], m[28][31]))))));
-    psi[I + d0 + d2 + d3 + d4] = (add(tmp[29], add(mul(v[0], m[29][28]), add(mul(v[1], m[29][29]), add(mul(v[2], m[29][30]), mul(v[3], m[29][31]))))));
-    psi[I + d1 + d2 + d3 + d4] = (add(tmp[30], add(mul(v[0], m[30][28]), add(mul(v[1], m[30][29]), add(mul(v[2], m[30][30]), mul(v[3], m[30][31]))))));
-    psi[I + d0 + d1 + d2 + d3 + d4] = (add(tmp[31], add(mul(v[0], m[31][28]), add(mul(v[1], m[31][29]), add(mul(v[2], m[31][30]), mul(v[3], m[31][31]))))));
-
+    psi[I] = (add(tmp[0],
+                  add(mul(v[0], m[0][28]), add(mul(v[1], m[0][29]), add(mul(v[2], m[0][30]), mul(v[3], m[0][31]))))));
+    psi[I + d0] = (add(
+        tmp[1], add(mul(v[0], m[1][28]), add(mul(v[1], m[1][29]), add(mul(v[2], m[1][30]), mul(v[3], m[1][31]))))));
+    psi[I + d1] = (add(
+        tmp[2], add(mul(v[0], m[2][28]), add(mul(v[1], m[2][29]), add(mul(v[2], m[2][30]), mul(v[3], m[2][31]))))));
+    psi[I + d0 + d1] = (add(
+        tmp[3], add(mul(v[0], m[3][28]), add(mul(v[1], m[3][29]), add(mul(v[2], m[3][30]), mul(v[3], m[3][31]))))));
+    psi[I + d2] = (add(
+        tmp[4], add(mul(v[0], m[4][28]), add(mul(v[1], m[4][29]), add(mul(v[2], m[4][30]), mul(v[3], m[4][31]))))));
+    psi[I + d0 + d2] = (add(
+        tmp[5], add(mul(v[0], m[5][28]), add(mul(v[1], m[5][29]), add(mul(v[2], m[5][30]), mul(v[3], m[5][31]))))));
+    psi[I + d1 + d2] = (add(
+        tmp[6], add(mul(v[0], m[6][28]), add(mul(v[1], m[6][29]), add(mul(v[2], m[6][30]), mul(v[3], m[6][31]))))));
+    psi[I + d0 + d1 + d2] = (add(
+        tmp[7], add(mul(v[0], m[7][28]), add(mul(v[1], m[7][29]), add(mul(v[2], m[7][30]), mul(v[3], m[7][31]))))));
+    psi[I + d3] = (add(
+        tmp[8], add(mul(v[0], m[8][28]), add(mul(v[1], m[8][29]), add(mul(v[2], m[8][30]), mul(v[3], m[8][31]))))));
+    psi[I + d0 + d3] = (add(
+        tmp[9], add(mul(v[0], m[9][28]), add(mul(v[1], m[9][29]), add(mul(v[2], m[9][30]), mul(v[3], m[9][31]))))));
+    psi[I + d1 + d3] = (add(tmp[10], add(mul(v[0], m[10][28]),
+                                         add(mul(v[1], m[10][29]), add(mul(v[2], m[10][30]), mul(v[3], m[10][31]))))));
+    psi[I + d0 + d1 + d3]
+        = (add(tmp[11],
+               add(mul(v[0], m[11][28]), add(mul(v[1], m[11][29]), add(mul(v[2], m[11][30]), mul(v[3], m[11][31]))))));
+    psi[I + d2 + d3] = (add(tmp[12], add(mul(v[0], m[12][28]),
+                                         add(mul(v[1], m[12][29]), add(mul(v[2], m[12][30]), mul(v[3], m[12][31]))))));
+    psi[I + d0 + d2 + d3]
+        = (add(tmp[13],
+               add(mul(v[0], m[13][28]), add(mul(v[1], m[13][29]), add(mul(v[2], m[13][30]), mul(v[3], m[13][31]))))));
+    psi[I + d1 + d2 + d3]
+        = (add(tmp[14],
+               add(mul(v[0], m[14][28]), add(mul(v[1], m[14][29]), add(mul(v[2], m[14][30]), mul(v[3], m[14][31]))))));
+    psi[I + d0 + d1 + d2 + d3]
+        = (add(tmp[15],
+               add(mul(v[0], m[15][28]), add(mul(v[1], m[15][29]), add(mul(v[2], m[15][30]), mul(v[3], m[15][31]))))));
+    psi[I + d4] = (add(tmp[16], add(mul(v[0], m[16][28]),
+                                    add(mul(v[1], m[16][29]), add(mul(v[2], m[16][30]), mul(v[3], m[16][31]))))));
+    psi[I + d0 + d4] = (add(tmp[17], add(mul(v[0], m[17][28]),
+                                         add(mul(v[1], m[17][29]), add(mul(v[2], m[17][30]), mul(v[3], m[17][31]))))));
+    psi[I + d1 + d4] = (add(tmp[18], add(mul(v[0], m[18][28]),
+                                         add(mul(v[1], m[18][29]), add(mul(v[2], m[18][30]), mul(v[3], m[18][31]))))));
+    psi[I + d0 + d1 + d4]
+        = (add(tmp[19],
+               add(mul(v[0], m[19][28]), add(mul(v[1], m[19][29]), add(mul(v[2], m[19][30]), mul(v[3], m[19][31]))))));
+    psi[I + d2 + d4] = (add(tmp[20], add(mul(v[0], m[20][28]),
+                                         add(mul(v[1], m[20][29]), add(mul(v[2], m[20][30]), mul(v[3], m[20][31]))))));
+    psi[I + d0 + d2 + d4]
+        = (add(tmp[21],
+               add(mul(v[0], m[21][28]), add(mul(v[1], m[21][29]), add(mul(v[2], m[21][30]), mul(v[3], m[21][31]))))));
+    psi[I + d1 + d2 + d4]
+        = (add(tmp[22],
+               add(mul(v[0], m[22][28]), add(mul(v[1], m[22][29]), add(mul(v[2], m[22][30]), mul(v[3], m[22][31]))))));
+    psi[I + d0 + d1 + d2 + d4]
+        = (add(tmp[23],
+               add(mul(v[0], m[23][28]), add(mul(v[1], m[23][29]), add(mul(v[2], m[23][30]), mul(v[3], m[23][31]))))));
+    psi[I + d3 + d4] = (add(tmp[24], add(mul(v[0], m[24][28]),
+                                         add(mul(v[1], m[24][29]), add(mul(v[2], m[24][30]), mul(v[3], m[24][31]))))));
+    psi[I + d0 + d3 + d4]
+        = (add(tmp[25],
+               add(mul(v[0], m[25][28]), add(mul(v[1], m[25][29]), add(mul(v[2], m[25][30]), mul(v[3], m[25][31]))))));
+    psi[I + d1 + d3 + d4]
+        = (add(tmp[26],
+               add(mul(v[0], m[26][28]), add(mul(v[1], m[26][29]), add(mul(v[2], m[26][30]), mul(v[3], m[26][31]))))));
+    psi[I + d0 + d1 + d3 + d4]
+        = (add(tmp[27],
+               add(mul(v[0], m[27][28]), add(mul(v[1], m[27][29]), add(mul(v[2], m[27][30]), mul(v[3], m[27][31]))))));
+    psi[I + d2 + d3 + d4]
+        = (add(tmp[28],
+               add(mul(v[0], m[28][28]), add(mul(v[1], m[28][29]), add(mul(v[2], m[28][30]), mul(v[3], m[28][31]))))));
+    psi[I + d0 + d2 + d3 + d4]
+        = (add(tmp[29],
+               add(mul(v[0], m[29][28]), add(mul(v[1], m[29][29]), add(mul(v[2], m[29][30]), mul(v[3], m[29][31]))))));
+    psi[I + d1 + d2 + d3 + d4]
+        = (add(tmp[30],
+               add(mul(v[0], m[30][28]), add(mul(v[1], m[30][29]), add(mul(v[2], m[30][30]), mul(v[3], m[30][31]))))));
+    psi[I + d0 + d1 + d2 + d3 + d4]
+        = (add(tmp[31],
+               add(mul(v[0], m[31][28]), add(mul(v[1], m[31][29]), add(mul(v[2], m[31][30]), mul(v[3], m[31][31]))))));
 }
 
 // bit indices id[.] are given from high to low (e.g. control first for CNOT)
 template <class V, class M>
-void kernel(V &psi, unsigned id4, unsigned id3, unsigned id2, unsigned id1, unsigned id0, M const& m, std::size_t ctrlmask)
-{
+void kernel(V& psi, unsigned id4, unsigned id3, unsigned id2, unsigned id1, unsigned id0, M const& m,
+            std::size_t ctrlmask) {
     std::size_t n = psi.size();
     std::size_t d0 = 1UL << id0;
     std::size_t d1 = 1UL << id1;
     std::size_t d2 = 1UL << id2;
     std::size_t d3 = 1UL << id3;
     std::size_t d4 = 1UL << id4;
-    std::size_t dsorted[] = {d0 , d1, d2, d3, d4};
+    std::size_t dsorted[] = {d0, d1, d2, d3, d4};
     std::sort(dsorted, dsorted + 5, std::greater<std::size_t>());
 
-    if (ctrlmask == 0){
-        #pragma omp for collapse(LOOP_COLLAPSE5) schedule(static)
-        for (std::size_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]){
-            for (std::size_t i1 = 0; i1 < dsorted[0]; i1 += 2 * dsorted[1]){
-                for (std::size_t i2 = 0; i2 < dsorted[1]; i2 += 2 * dsorted[2]){
-                    for (std::size_t i3 = 0; i3 < dsorted[2]; i3 += 2 * dsorted[3]){
-                        for (std::size_t i4 = 0; i4 < dsorted[3]; i4 += 2 * dsorted[4]){
-                            for (std::size_t i5 = 0; i5 < dsorted[4]; ++i5){
+    if (ctrlmask == 0) {
+#pragma omp for collapse(LOOP_COLLAPSE5) schedule(static)
+        for (omp::idx_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]) {
+            for (omp::idx_t i1 = 0; i1 < dsorted[0]; i1 += 2 * dsorted[1]) {
+                for (omp::idx_t i2 = 0; i2 < dsorted[1]; i2 += 2 * dsorted[2]) {
+                    for (omp::idx_t i3 = 0; i3 < dsorted[2]; i3 += 2 * dsorted[3]) {
+                        for (omp::idx_t i4 = 0; i4 < dsorted[3]; i4 += 2 * dsorted[4]) {
+                            for (omp::idx_t i5 = 0; i5 < dsorted[4]; ++i5) {
                                 kernel_core(psi, i0 + i1 + i2 + i3 + i4 + i5, d0, d1, d2, d3, d4, m);
                             }
                         }
@@ -352,16 +580,15 @@ void kernel(V &psi, unsigned id4, unsign
                 }
             }
         }
-    }
-    else{
-        #pragma omp for collapse(LOOP_COLLAPSE5) schedule(static)
-        for (std::size_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]){
-            for (std::size_t i1 = 0; i1 < dsorted[0]; i1 += 2 * dsorted[1]){
-                for (std::size_t i2 = 0; i2 < dsorted[1]; i2 += 2 * dsorted[2]){
-                    for (std::size_t i3 = 0; i3 < dsorted[2]; i3 += 2 * dsorted[3]){
-                        for (std::size_t i4 = 0; i4 < dsorted[3]; i4 += 2 * dsorted[4]){
-                            for (std::size_t i5 = 0; i5 < dsorted[4]; ++i5){
-                                if (((i0 + i1 + i2 + i3 + i4 + i5)&ctrlmask) == ctrlmask)
+    } else {
+#pragma omp for collapse(LOOP_COLLAPSE5) schedule(static)
+        for (omp::idx_t i0 = 0; i0 < n; i0 += 2 * dsorted[0]) {
+            for (omp::idx_t i1 = 0; i1 < dsorted[0]; i1 += 2 * dsorted[1]) {
+                for (omp::idx_t i2 = 0; i2 < dsorted[1]; i2 += 2 * dsorted[2]) {
+                    for (omp::idx_t i3 = 0; i3 < dsorted[2]; i3 += 2 * dsorted[3]) {
+                        for (omp::idx_t i4 = 0; i4 < dsorted[3]; i4 += 2 * dsorted[4]) {
+                            for (omp::idx_t i5 = 0; i5 < dsorted[4]; ++i5) {
+                                if (((i0 + i1 + i2 + i3 + i4 + i5) & ctrlmask) == ctrlmask)
                                     kernel_core(psi, i0 + i1 + i2 + i3 + i4 + i5, d0, d1, d2, d3, d4, m);
                             }
                         }
diff -Npur projectq-orig/projectq/backends/_sim/_cppkernels/nointrin/kernels.hpp projectq-new/projectq/backends/_sim/_cppkernels/nointrin/kernels.hpp
--- projectq-orig/projectq/backends/_sim/_cppkernels/nointrin/kernels.hpp	2022-04-27 11:49:17.000000000 +0200
+++ projectq-new/projectq/backends/_sim/_cppkernels/nointrin/kernels.hpp	2022-06-17 12:37:17.819532363 +0200
@@ -13,19 +13,25 @@
 // limitations under the License.
 
 #include <cmath>
-#include <cstdlib>
-#include <vector>
+
+#include <algorithm>
 #include <complex>
+#include <cstdlib>
 #include <functional>
-#include <algorithm>
+#include <vector>
+
 #include "../intrin/alignedallocator.hpp"
+#include "config/openmp.hpp"
 
 template <class T>
-inline T add(T a, T b){ return a+b; }
+inline T add(T a, T b) {
+    return a + b;
+}
 
 template <class T>
-inline T mul(T a, T b){ return a*b; }
-
+inline T mul(T a, T b) {
+    return a * b;
+}
 
 #define LOOP_COLLAPSE1 2
 #define LOOP_COLLAPSE2 3
diff -Npur projectq-orig/projectq/backends/_sim/_cppkernels/simulator.hpp projectq-new/projectq/backends/_sim/_cppkernels/simulator.hpp
--- projectq-orig/projectq/backends/_sim/_cppkernels/simulator.hpp	2022-04-27 11:49:17.000000000 +0200
+++ projectq-new/projectq/backends/_sim/_cppkernels/simulator.hpp	2022-06-17 12:37:17.819532363 +0200
@@ -15,125 +15,180 @@
 #ifndef SIMULATOR_HPP_
 #define SIMULATOR_HPP_
 
-#include <vector>
+#include <algorithm>
+#include <cassert>
 #include <complex>
+#include <functional>
+#include <map>
+#include <random>
+#include <tuple>
+#include <utility>
+#include <vector>
+
+#ifdef USE_OPENMP
+#    include <omp.h>
+#endif  // USE_OPENMP  // NOLINT
+
+#include "experimental/core/config.hpp"
+
+#include "config/openmp.hpp"
+#include "fusion.hpp"
+#include "intrin/alignedallocator.hpp"
 
 #if defined(NOINTRIN) || !defined(INTRIN)
-#include "nointrin/kernels.hpp"
+#    include "nointrin/kernels.hpp"
 #else
-#include "intrin/kernels.hpp"
+#    include "intrin/kernels.hpp"
 #endif
 
-#include "intrin/alignedallocator.hpp"
-#include "fusion.hpp"
-#include <map>
-#include <cassert>
-#include <algorithm>
-#include <tuple>
-#include <random>
-#include <functional>
-
+#define USE_NEW 1
+#ifdef USE_NEW
+#    define USE_STATIC_STATEVECTOR 0
+#else
+#    define USE_STATIC_STATEVECTOR 1
+#endif
 
-class Simulator{
-public:
+namespace projectq {
+class Simulator {
+ public:
     using calc_type = double;
     using complex_type = std::complex<calc_type>;
-    using StateVector = std::vector<complex_type, aligned_allocator<complex_type,512>>;
-    using Map = std::map<unsigned, unsigned>;
+    using StateVector = std::vector<complex_type, aligned_allocator<complex_type, 512>>;
+    using qubit_id_t = mindquantum::qubit_id_t;
+    using Map = std::map<qubit_id_t, qubit_id_t>;
     using RndEngine = std::mt19937;
     using Term = std::vector<std::pair<unsigned, char>>;
     using TermsDict = std::vector<std::pair<Term, calc_type>>;
     using ComplexTermsDict = std::vector<std::pair<Term, complex_type>>;
 
-    Simulator(unsigned seed = 1) : N_(0), vec_(1,0.), fusion_qubits_min_(4),
-                                   fusion_qubits_max_(5), rnd_eng_(seed) {
-        vec_[0]=1.; // all-zero initial state
+    explicit Simulator(unsigned seed = 1)
+        : N_(0), vec_(1, 0.), fusion_qubits_min_(4), fusion_qubits_max_(5), rnd_eng_(seed) {
+        vec_[0] = 1.;  // all-zero initial state
         std::uniform_real_distribution<double> dist(0., 1.);
         rng_ = std::bind(dist, std::ref(rnd_eng_));
     }
 
-    void allocate_qubit(unsigned id){
-        if (map_.count(id) == 0){
+    bool has_qubit(qubit_id_t id) const noexcept {
+        return map_.count(id) > 0;
+    }
+
+    void allocate_qubit(qubit_id_t id) {
+        if (map_.count(id) == 0) {
             map_[id] = N_++;
-            StateVector newvec; // avoid large memory allocations
-            if( tmpBuff1_.capacity() >= (1UL << N_) )
-              std::swap(newvec, tmpBuff1_);
+#ifdef USE_NEW
+#    ifndef _OPENMP
+            // NB: if realloc occurs, then old elements are copied and the new ones initialized to 0.
+            vec_.resize(1UL << N_, 0.);
+#    else
+            // Same as above, but we use OpenMP
+            auto newvec = StateVector(1UL << N_, 0.);
+#        pragma omp parallel for schedule(static)
+            for (omp::idx_t i = 0; i < vec_.size(); ++i) {
+                newvec[i] = vec_[i];
+            }
+            vec_ = std::move(newvec);
+#    endif  // !_OPENMP
+#else
+#    if !USE_STATIC_STATEVECTOR
+            auto newvec = StateVector(1UL << N_);
+#    else
+            StateVector newvec;  // avoid large memory allocations
+            if (tmpBuff1_.capacity() >= (1UL << N_)) {
+                std::swap(newvec, tmpBuff1_);
+            }
             newvec.resize(1UL << N_);
-#pragma omp parallel for schedule(static)
-            for (std::size_t i = 0; i < newvec.size(); ++i)
-                newvec[i] = (i < vec_.size())?vec_[i]:0.;
+#    endif  // !USE_STATIC_STATEVECTOR
+#    pragma omp parallel for schedule(static)
+            for (std::size_t i = 0; i < newvec.size(); ++i) {
+                newvec[i] = (i < vec_.size()) ? vec_[i] : 0.;
+            }
+#    if !USE_STATIC_STATEVECTOR
+            vec_ = std::move(newvec);
+#    else
             std::swap(vec_, newvec);
             // recycle large memory
             std::swap(tmpBuff1_, newvec);
-            if( tmpBuff1_.capacity() < tmpBuff2_.capacity() )
-              std::swap(tmpBuff1_, tmpBuff2_);
-        }
-        else
-            throw(std::runtime_error(
-                "AllocateQubit: ID already exists. Qubit IDs should be unique."));
+            if (tmpBuff1_.capacity() < tmpBuff2_.capacity()) {
+                std::swap(tmpBuff1_, tmpBuff2_);
+            }
+#    endif  // !USE_STATIC_STATEVECTOR
+#endif      // USE_NEW
+        } else
+            throw(
+                std::runtime_error("AllocateQubit: ID already exists. Qubit "
+                                   "IDs should be unique."));
     }
 
-    bool get_classical_value(unsigned id, calc_type tol = 1.e-12){
+    bool get_classical_value(qubit_id_t id, calc_type tol = 1.e-12) {
         run();
-        unsigned pos = map_[id];
+        auto pos = map_[id];
         std::size_t delta = (1UL << pos);
 
-        for (std::size_t i = 0; i < vec_.size(); i += 2*delta){
-            for (std::size_t j = 0; j < delta; ++j){
-                if (std::norm(vec_[i+j]) > tol)
+        for (std::size_t i = 0; i < vec_.size(); i += 2 * delta) {
+            for (std::size_t j = 0; j < delta; ++j) {
+                if (std::norm(vec_[i + j]) > tol)
                     return false;
-                if (std::norm(vec_[i+j+delta]) > tol)
+                if (std::norm(vec_[i + j + delta]) > tol)
                     return true;
             }
         }
-        assert(false); // this will never happen
-        return false; // suppress 'control reaches end of non-void...'
+        assert(false);  // this will never happen
+        return false;   // suppress 'control reaches end of non-void...'
     }
 
-    bool is_classical(unsigned id, calc_type tol = 1.e-12){
+    bool is_classical(qubit_id_t id, calc_type tol = 1.e-12) {
         run();
-        unsigned pos = map_[id];
+        auto pos = map_[id];
         std::size_t delta = (1UL << pos);
 
-        short up = 0, down = 0;
-        #pragma omp parallel for schedule(static) reduction(|:up,down)
-        for (std::size_t i = 0; i < vec_.size(); i += 2*delta){
-            for (std::size_t j = 0; j < delta; ++j){
-                up = up | ((std::norm(vec_[i+j]) > tol)&1);
-                down = down | ((std::norm(vec_[i+j+delta]) > tol)&1);
+        int16_t up = 0, down = 0;
+#pragma omp parallel for schedule(static) reduction(| : up, down)
+        for (omp::idx_t i = 0; i < vec_.size(); i += 2 * delta) {
+            for (std::size_t j = 0; j < delta; ++j) {
+                up = up | ((std::norm(vec_[i + j]) > tol) & 1);
+                down = down | ((std::norm(vec_[i + j + delta]) > tol) & 1);
             }
         }
 
-        return 1 == (up^down);
+        return 1 == (up ^ down);
     }
 
-    void collapse_vector(unsigned id, bool value = false, bool shrink = false){
+    void collapse_vector(qubit_id_t id, bool value = false, bool shrink = false) {
         run();
-        unsigned pos = map_[id];
+        auto pos = map_[id];
         std::size_t delta = (1UL << pos);
 
-        if (!shrink){
-            #pragma omp parallel for schedule(static)
-            for (std::size_t i = 0; i < vec_.size(); i += 2*delta){
+        if (!shrink) {
+#pragma omp parallel for schedule(static)
+            for (omp::idx_t i = 0; i < vec_.size(); i += 2 * delta) {
                 for (std::size_t j = 0; j < delta; ++j)
-                    vec_[i+j+static_cast<std::size_t>(!value)*delta] = 0.;
+                    vec_[i + j + static_cast<std::size_t>(!value) * delta] = 0.;
             }
-        }
-        else{
-            StateVector newvec; // avoid costly memory reallocations
-            if( tmpBuff1_.capacity() >= (1UL << (N_-1)) )
-              std::swap(tmpBuff1_, newvec);
-            newvec.resize((1UL << (N_-1)));
-            #pragma omp parallel for schedule(static) if(0)
-            for (std::size_t i = 0; i < vec_.size(); i += 2*delta)
-                std::copy_n(&vec_[i + static_cast<std::size_t>(value)*delta],
-                            delta, &newvec[i/2]);
+        } else {
+#if !USE_STATIC_STATEVECTOR
+            StateVector newvec((1UL << (N_ - 1)));
+#    pragma omp parallel for schedule(static)
+#else
+            StateVector newvec;  // avoid costly memory reallocations
+            if (tmpBuff1_.capacity() >= (1UL << (N_ - 1UL))) {
+                std::swap(tmpBuff1_, newvec);
+            }
+            newvec.resize((1UL << (N_ - 1UL)));
+#    pragma omp parallel for schedule(static) if (0)
+#endif
+            for (omp::idx_t i = 0; i < vec_.size(); i += 2 * delta)
+                std::copy_n(&vec_[i + static_cast<std::size_t>(value) * delta], delta, &newvec[i / 2]);
+#if !USE_STATIC_STATEVECTOR
+            vec_ = std::move(newvec);
+#else
             std::swap(vec_, newvec);
             std::swap(tmpBuff1_, newvec);
-            if( tmpBuff1_.capacity() < tmpBuff2_.capacity() )
-              std::swap(tmpBuff1_, tmpBuff2_);
+            if (tmpBuff1_.capacity() < tmpBuff2_.capacity())
+                std::swap(tmpBuff1_, tmpBuff2_);
 
-            for (auto& p : map_){
+#endif
+
+            for (auto& p : map_) {
                 if (p.second > pos)
                     p.second--;
             }
@@ -142,10 +197,10 @@ public:
         }
     }
 
-    void measure_qubits(std::vector<unsigned> const& ids, std::vector<bool> &res){
+    void measure_qubits(std::vector<qubit_id_t> const& ids, std::vector<bool>& res) {
         run();
 
-        std::vector<unsigned> positions(ids.size());
+        std::vector<qubit_id_t> positions(ids.size());
         for (unsigned i = 0; i < ids.size(); ++i)
             positions[i] = map_[ids[i]];
 
@@ -159,71 +214,77 @@ public:
 
         pick--;
         // determine result vector (boolean values for each qubit)
-        // and create mask to detect bad entries (i.e., entries that don't agree with measurement)
+        // and create mask to detect bad entries (i.e., entries that
+        // don't agree with measurement)
         res = std::vector<bool>(ids.size());
         std::size_t mask = 0;
         std::size_t val = 0;
-        for (unsigned i = 0; i < ids.size(); ++i){
+        for (unsigned i = 0; i < ids.size(); ++i) {
             bool r = ((pick >> positions[i]) & 1) == 1;
             res[i] = r;
             mask |= (1UL << positions[i]);
-            val |= (static_cast<std::size_t>(r&1) << positions[i]);
+            val |= (static_cast<std::size_t>(r & 1) << positions[i]);
         }
         // set bad entries to 0
         calc_type N = 0.;
-        #pragma omp parallel for reduction(+:N) schedule(static)
-        for (std::size_t i = 0; i < vec_.size(); ++i){
+#pragma omp parallel for reduction(+ : N) schedule(static)
+        for (omp::idx_t i = 0; i < vec_.size(); ++i) {
             if ((i & mask) != val)
                 vec_[i] = 0.;
             else
                 N += std::norm(vec_[i]);
         }
         // re-normalize
-        N = 1./std::sqrt(N);
-        #pragma omp parallel for schedule(static)
-        for (std::size_t i = 0; i < vec_.size(); ++i)
+        N = 1. / std::sqrt(N);
+#pragma omp parallel for schedule(static)
+        for (omp::idx_t i = 0; i < vec_.size(); ++i)
             vec_[i] *= N;
     }
 
-    std::vector<bool> measure_qubits_return(std::vector<unsigned> const& ids){
+    std::vector<bool> measure_qubits_return(std::vector<qubit_id_t> const& ids) {
         std::vector<bool> ret;
         measure_qubits(ids, ret);
         return ret;
     }
 
-    void deallocate_qubit(unsigned id){
+    void deallocate_qubit(qubit_id_t id) {
         run();
         assert(map_.count(id) == 1);
         if (!is_classical(id))
-            throw(std::runtime_error("Error: Qubit has not been measured / uncomputed! There is most likely a bug in your code."));
+            throw(
+                std::runtime_error("Error: Qubit has not been measured "
+                                   "/ uncomputed! There is "
+                                   "most likely a bug in your code."));
 
         bool value = get_classical_value(id);
         collapse_vector(id, value, true);
     }
 
     template <class M>
-    void apply_controlled_gate(M const& m, const std::vector<unsigned>& ids,
-                               const std::vector<unsigned>& ctrl){
-        auto fused_gates = fused_gates_;
-        fused_gates.insert(m, ids, ctrl);
-
-        if (fused_gates.num_qubits() >= fusion_qubits_min_
-                && fused_gates.num_qubits() <= fusion_qubits_max_){
-            fused_gates_ = fused_gates;
-            run();
-        }
-        else if (fused_gates.num_qubits() > fusion_qubits_max_
-                 || (fused_gates.num_qubits() - ids.size()) > fused_gates_.num_qubits()){
-            run();
-            fused_gates_.insert(m, ids, ctrl);
-        }
-        else
-            fused_gates_ = fused_gates;
+    void apply_controlled_gate(M const& m, const std::vector<qubit_id_t>& ids, const std::vector<qubit_id_t>& ctrl) {
+        fused_gates_.insert(m, ids, ctrl);
+        run();
+
+        // auto fused_gates = fused_gates_;
+        // fused_gates.insert(m, ids, ctrl);
+
+        // if (fused_gates.num_qubits() >= fusion_qubits_min_
+        //     && fused_gates.num_qubits() <= fusion_qubits_max_) {
+        //      fused_gates_ = std::move(fused_gates);
+        //      run();
+        // }
+        // else if (fused_gates.num_qubits() > fusion_qubits_max_
+        //          || (fused_gates.num_qubits() - ids.size())
+        //                 > fused_gates_.num_qubits()) {
+        //      run();
+        //      fused_gates_.insert(m, ids, ctrl);
+        // }
+        // else
+        //      fused_gates_ = std::move(fused_gates);
     }
 
     template <class F, class QuReg>
-    void emulate_math(F const& f, QuReg quregs, const std::vector<unsigned>& ctrl,
-                      bool parallelize = false){
+    void emulate_math(F const& f, QuReg quregs, const std::vector<qubit_id_t>& ctrl, bool parallelize = false) {
         run();
         auto ctrlmask = get_control_mask(ctrl);
 
@@ -231,205 +292,259 @@ public:
             for (unsigned j = 0; j < quregs[i].size(); ++j)
                 quregs[i][j] = map_[quregs[i][j]];
 
-        StateVector newvec; // avoid costly memory reallocations
-        if( tmpBuff1_.capacity() >= vec_.size() )
-          std::swap(newvec, tmpBuff1_);
+#if !USE_STATIC_STATEVECTOR
+        StateVector newvec(vec_.size(), 0.);
+        std::vector<int> res(quregs.size());
+#    pragma omp parallel for schedule(static) firstprivate(res)
+#else
+        StateVector newvec;  // avoid costly memory reallocations
+        if (tmpBuff1_.capacity() >= vec_.size()) {
+            std::swap(newvec, tmpBuff1_);
+        }
         newvec.resize(vec_.size());
-#pragma omp parallel for schedule(static)
-        for (std::size_t i = 0; i < vec_.size(); i++)
-          newvec[i] = 0;
-
-//#pragma omp parallel reduction(+:newvec[:newvec.size()]) if(parallelize) // requires OpenMP 4.5
+#    pragma omp parallel for schedule(static)
+        for (omp::idx_t i = 0; i < vec_.size(); i++) {
+            newvec[i] = 0;
+        }
+#    if _OPENMP >= 201511  // OpenMP 4.5+
+#        pragma omp parallel reduction(+ : newvec[:newvec.size()]) if (parallelize)
+#    endif  // _OPENMP >= 201511
         {
-          std::vector<int> res(quregs.size());
-          //#pragma omp for schedule(static)
-          for (std::size_t i = 0; i < vec_.size(); ++i){
-              if ((ctrlmask&i) == ctrlmask){
-                  for (unsigned qr_i = 0; qr_i < quregs.size(); ++qr_i){
-                      res[qr_i] = 0;
-                      for (unsigned qb_i = 0; qb_i < quregs[qr_i].size(); ++qb_i)
-                          res[qr_i] |= ((i >> quregs[qr_i][qb_i])&1) << qb_i;
-                  }
-                  f(res);
-                  auto new_i = i;
-                  for (unsigned qr_i = 0; qr_i < quregs.size(); ++qr_i){
-                      for (unsigned qb_i = 0; qb_i < quregs[qr_i].size(); ++qb_i){
-                          if (!(((new_i >> quregs[qr_i][qb_i])&1) == ((res[qr_i] >> qb_i)&1)))
-                              new_i ^= (1UL << quregs[qr_i][qb_i]);
-                      }
-                  }
-                  newvec[new_i] += vec_[i];
-              }
-              else
-                  newvec[i] += vec_[i];
-          }
+            std::vector<int> res(quregs.size());
+            // #pragma omp for schedule(static)
+#endif
+        for (omp::idx_t i = 0; i < vec_.size(); ++i) {
+            if ((ctrlmask & i) == ctrlmask) {
+                for (unsigned qr_i = 0; qr_i < quregs.size(); ++qr_i) {
+                    res[qr_i] = 0;
+                    for (unsigned qb_i = 0; qb_i < quregs[qr_i].size(); ++qb_i)
+                        res[qr_i] |= ((i >> quregs[qr_i][qb_i]) & 1) << qb_i;
+                }
+                f(res);
+                auto new_i = i;
+                for (unsigned qr_i = 0; qr_i < quregs.size(); ++qr_i) {
+                    for (unsigned qb_i = 0; qb_i < quregs[qr_i].size(); ++qb_i) {
+                        if (!(((new_i >> quregs[qr_i][qb_i]) & 1) == ((res[qr_i] >> qb_i) & 1)))
+                            new_i ^= (1UL << quregs[qr_i][qb_i]);
+                    }
+                }
+                newvec[new_i] += vec_[i];
+            } else
+                newvec[i] += vec_[i];
+        }
+#if !USE_STATIC_STATEVECTOR
+        vec_ = std::move(newvec);
+#else
         }
         std::swap(vec_, newvec);
         std::swap(tmpBuff1_, newvec);
+#endif
     }
 
     // faster version without calling python
-    template<class QuReg>
-    inline void emulate_math_addConstant(int a, const QuReg& quregs, const std::vector<unsigned>& ctrl)
-    {
-      emulate_math([a](std::vector<int> &res){for(auto& x: res) x = x + a;}, quregs, ctrl, true);
+    template <class QuReg>
+    inline void emulate_math_addConstant(int a, const QuReg& quregs, const std::vector<qubit_id_t>& ctrl) {
+        emulate_math(
+            [a](std::vector<int>& res) {
+                for (auto& x : res)
+                    x = x + a;
+            },
+            quregs, ctrl, true);
     }
 
     // faster version without calling python
-    template<class QuReg>
-    inline void emulate_math_addConstantModN(int a, int N, const QuReg& quregs, const std::vector<unsigned>& ctrl)
-    {
-      emulate_math([a,N](std::vector<int> &res){for(auto& x: res) x = (x + a) % N;}, quregs, ctrl, true);
+    template <class QuReg>
+    inline void emulate_math_addConstantModN(int a, int N, const QuReg& quregs, const std::vector<qubit_id_t>& ctrl) {
+        emulate_math(
+            [a, N](std::vector<int>& res) {
+                for (auto& x : res)
+                    x = (x + a) % N;
+            },
+            quregs, ctrl, true);
     }
 
     // faster version without calling python
-    template<class QuReg>
-    inline void emulate_math_multiplyByConstantModN(int a, int N, const QuReg& quregs, const std::vector<unsigned>& ctrl)
-    {
-      emulate_math([a,N](std::vector<int> &res){for(auto& x: res) x = (x * a) % N;}, quregs, ctrl, true);
+    template <class QuReg>
+    inline void emulate_math_multiplyByConstantModN(int a, int N, const QuReg& quregs,
+                                                    const std::vector<qubit_id_t>& ctrl) {
+        emulate_math(
+            [a, N](std::vector<int>& res) {
+                for (auto& x : res)
+                    x = (x * a) % N;
+            },
+            quregs, ctrl, true);
     }
 
-    calc_type get_expectation_value(TermsDict const& td, std::vector<unsigned> const& ids){
+    calc_type get_expectation_value(TermsDict const& td, std::vector<qubit_id_t> const& ids) {
         run();
         calc_type expectation = 0.;
 
-        StateVector current_state; // avoid costly memory reallocations
-        if( tmpBuff1_.capacity() >= vec_.size() )
-          std::swap(tmpBuff1_, current_state);
+#if !USE_STATIC_STATEVECTOR
+        auto current_state = vec_;
+#else
+        StateVector current_state;  // avoid costly memory reallocations
+        if (tmpBuff1_.capacity() >= vec_.size()) {
+            std::swap(tmpBuff1_, current_state);
+        }
         current_state.resize(vec_.size());
-#pragma omp parallel for schedule(static)
-        for (std::size_t i = 0; i < vec_.size(); ++i)
-          current_state[i] = vec_[i];
-
-        for (auto const& term : td){
+#    pragma omp parallel for schedule(static)
+        for (omp::idx_t i = 0; i < vec_.size(); ++i) {
+            current_state[i] = vec_[i];
+        }
+#endif
+        for (auto const& term : td) {
             auto const& coefficient = term.second;
             apply_term(term.first, ids, {});
             calc_type delta = 0.;
-            #pragma omp parallel for reduction(+:delta) schedule(static)
-            for (std::size_t i = 0; i < vec_.size(); ++i){
+#pragma omp parallel for reduction(+ : delta) schedule(static)
+            for (omp::idx_t i = 0; i < vec_.size(); ++i) {
                 auto const a1 = std::real(current_state[i]);
                 auto const b1 = -std::imag(current_state[i]);
                 auto const a2 = std::real(vec_[i]);
                 auto const b2 = std::imag(vec_[i]);
                 delta += a1 * a2 - b1 * b2;
+#if USE_STATIC_STATEVECTOR
                 // reset vec_
                 vec_[i] = current_state[i];
+#endif
             }
             expectation += coefficient * delta;
+#if !USE_STATIC_STATEVECTOR
+            vec_ = current_state;
+#endif
         }
+#if USE_STATIC_STATEVECTOR
         std::swap(current_state, tmpBuff1_);
+#endif
         return expectation;
     }
 
-    void apply_qubit_operator(ComplexTermsDict const& td, std::vector<unsigned> const& ids){
+    void apply_qubit_operator(ComplexTermsDict const& td, std::vector<qubit_id_t> const& ids) {
         run();
-        StateVector new_state, current_state; // avoid costly memory reallocations
-        if( tmpBuff1_.capacity() >= vec_.size() )
-          std::swap(tmpBuff1_, new_state);
-        if( tmpBuff2_.capacity() >= vec_.size() )
-          std::swap(tmpBuff2_, current_state);
+#if !USE_STATIC_STATEVECTOR
+        auto new_state = StateVector(vec_.size(), 0.);
+        auto current_state = vec_;
+#else
+        StateVector new_state;
+        StateVector current_state;  // avoid costly memory reallocations
+        if (tmpBuff1_.capacity() >= vec_.size()) {
+            std::swap(tmpBuff1_, new_state);
+        }
+        if (tmpBuff2_.capacity() >= vec_.size()) {
+            std::swap(tmpBuff2_, current_state);
+        }
         new_state.resize(vec_.size());
         current_state.resize(vec_.size());
-#pragma omp parallel for schedule(static)
-        for (std::size_t i = 0; i < vec_.size(); ++i){
-          new_state[i] = 0;
-          current_state[i] = vec_[i];
+#    pragma omp parallel for schedule(static)
+        for (omp::idx_t i = 0; i < vec_.size(); ++i) {
+            new_state[i] = 0;
+            current_state[i] = vec_[i];
         }
-        for (auto const& term : td){
+#endif
+        for (auto const& term : td) {
             auto const& coefficient = term.second;
             apply_term(term.first, ids, {});
-            #pragma omp parallel for schedule(static)
-            for (std::size_t i = 0; i < vec_.size(); ++i){
+#pragma omp parallel for schedule(static)
+            for (omp::idx_t i = 0; i < vec_.size(); ++i) {
                 new_state[i] += coefficient * vec_[i];
                 vec_[i] = current_state[i];
             }
         }
+#if !USE_STATIC_STATEVECTOR
+        vec_ = std::move(new_state);
+#else
         std::swap(vec_, new_state);
         std::swap(tmpBuff1_, new_state);
         std::swap(tmpBuff2_, current_state);
+#endif
     }
 
-    calc_type get_probability(std::vector<bool> const& bit_string,
-                              std::vector<unsigned> const& ids){
+    calc_type get_probability(std::vector<bool> const& bit_string, std::vector<qubit_id_t> const& ids) {
         run();
         if (!check_ids(ids))
-            throw(std::runtime_error("get_probability(): Unknown qubit id. Please make sure you have called eng.flush()."));
+            throw(
+                std::runtime_error("get_probability(): Unknown qubit "
+                                   "id. Please make sure you "
+                                   "have called eng.flush()."));
         std::size_t mask = 0, bit_str = 0;
-        for (unsigned i = 0; i < ids.size(); ++i){
+        for (unsigned i = 0; i < ids.size(); ++i) {
             mask |= 1UL << map_[ids[i]];
-            bit_str |= (bit_string[i]?1UL:0UL) << map_[ids[i]];
+            bit_str |= (bit_string[i] ? 1UL : 0UL) << map_[ids[i]];
         }
         calc_type probability = 0.;
-        #pragma omp parallel for reduction(+:probability) schedule(static)
-        for (std::size_t i = 0; i < vec_.size(); ++i)
+#pragma omp parallel for reduction(+ : probability) schedule(static)
+        for (omp::idx_t i = 0; i < vec_.size(); ++i)
             if ((i & mask) == bit_str)
                 probability += std::norm(vec_[i]);
         return probability;
     }
 
-    complex_type const& get_amplitude(std::vector<bool> const& bit_string,
-                                      std::vector<unsigned> const& ids){
+    complex_type const& get_amplitude(std::vector<bool> const& bit_string, std::vector<qubit_id_t> const& ids) {
         run();
         std::size_t chk = 0;
         std::size_t index = 0;
-        for (unsigned i = 0; i < ids.size(); ++i){
+        for (unsigned i = 0; i < ids.size(); ++i) {
             if (map_.count(ids[i]) == 0)
                 break;
             chk |= 1UL << map_[ids[i]];
-            index |= (bit_string[i]?1UL:0UL) << map_[ids[i]];
+            index |= (bit_string[i] ? 1UL : 0UL) << map_[ids[i]];
         }
         if (chk + 1 != vec_.size())
-            throw(std::runtime_error("The second argument to get_amplitude() must be a permutation of all allocated qubits. Please make sure you have called eng.flush()."));
+            throw(
+                std::runtime_error("The second argument to get_amplitude() must be a "
+                                   "permutation of all allocated qubits. Please make sure "
+                                   "you "
+                                   "have called eng.flush()."));
         return vec_[index];
     }
 
-    void emulate_time_evolution(TermsDict const& tdict, calc_type const& time,
-                                std::vector<unsigned> const& ids,
-                                std::vector<unsigned> const& ctrl){
+    void emulate_time_evolution(ComplexTermsDict const& tdict, calc_type const& time,
+                                std::vector<qubit_id_t> const& ids, std::vector<qubit_id_t> const& ctrl) {
         run();
         complex_type I(0., 1.);
-        calc_type tr = 0., op_nrm = 0.;
-        TermsDict td;
-        for (unsigned i = 0; i < tdict.size(); ++i){
+        complex_type tr = 0.;
+        calc_type op_nrm = 0.;
+        ComplexTermsDict td;
+        for (unsigned i = 0; i < tdict.size(); ++i) {
             if (tdict[i].first.size() == 0)
                 tr += tdict[i].second;
-            else{
+            else {
                 td.push_back(tdict[i]);
                 op_nrm += std::abs(tdict[i].second);
             }
         }
         unsigned s = std::abs(time) * op_nrm + 1.;
-        complex_type correction = std::exp(-time * I * tr / (double)s);
+        complex_type correction = std::exp(-time * I * tr / static_cast<double>(s));
         auto output_state = vec_;
         auto ctrlmask = get_control_mask(ctrl);
-        for (unsigned i = 0; i < s; ++i){
+        for (unsigned i = 0; i < s; ++i) {
             calc_type nrm_change = 1.;
-            for (unsigned k = 0; nrm_change > 1.e-12; ++k){
+            for (unsigned k = 0; nrm_change > 1.e-12; ++k) {
                 auto coeff = (-time * I) / double(s * (k + 1));
                 auto current_state = vec_;
                 auto update = StateVector(vec_.size(), 0.);
-                for (auto const& tup : td){
+                for (auto const& tup : td) {
                     apply_term(tup.first, ids, {});
-                    #pragma omp parallel for schedule(static)
-                    for (std::size_t j = 0; j < vec_.size(); ++j){
+#pragma omp parallel for schedule(static)
+                    for (omp::idx_t j = 0; j < vec_.size(); ++j) {
                         update[j] += vec_[j] * tup.second;
                         vec_[j] = current_state[j];
                     }
                 }
                 nrm_change = 0.;
-                #pragma omp parallel for reduction(+:nrm_change) schedule(static)
-                for (std::size_t j = 0; j < vec_.size(); ++j){
+#pragma omp parallel for reduction(+ : nrm_change) schedule(static)
+                for (omp::idx_t j = 0; j < vec_.size(); ++j) {
                     update[j] *= coeff;
                     vec_[j] = update[j];
-                    if ((j & ctrlmask) == ctrlmask){
+                    if ((j & ctrlmask) == ctrlmask) {
                         output_state[j] += update[j];
                         nrm_change += std::norm(update[j]);
                     }
                 }
                 nrm_change = std::sqrt(nrm_change);
             }
-            #pragma omp parallel for schedule(static)
-            for (std::size_t j = 0; j < vec_.size(); ++j){
+#pragma omp parallel for schedule(static)
+            for (omp::idx_t j = 0; j < vec_.size(); ++j) {
                 if ((j & ctrlmask) == ctrlmask)
                     output_state[j] *= correction;
                 vec_[j] = output_state[j];
@@ -437,46 +552,55 @@ public:
         }
     }
 
-    void set_wavefunction(StateVector const& wavefunction, std::vector<unsigned> const& ordering){
+    void set_wavefunction(StateVector const& wavefunction, std::vector<qubit_id_t> const& ordering) {
         run();
         // make sure there are 2^n amplitudes for n qubits
         assert(wavefunction.size() == (1UL << ordering.size()));
         // check that all qubits have been allocated previously
         if (map_.size() != ordering.size() || !check_ids(ordering))
-            throw(std::runtime_error("set_wavefunction(): Invalid mapping provided. Please make sure all qubits have been allocated previously (call eng.flush())."));
+            throw(
+                std::runtime_error("set_wavefunction(): Invalid mapping provided. Please "
+                                   "make "
+                                   "sure all qubits have been allocated previously (call "
+                                   "eng.flush())."));
 
         // set mapping and wavefunction
         for (unsigned i = 0; i < ordering.size(); ++i)
             map_[ordering[i]] = i;
-        #pragma omp parallel for schedule(static)
-        for (std::size_t i = 0; i < wavefunction.size(); ++i)
+#pragma omp parallel for schedule(static)
+        for (omp::idx_t i = 0; i < wavefunction.size(); ++i)
             vec_[i] = wavefunction[i];
     }
 
-    void collapse_wavefunction(std::vector<unsigned> const& ids, std::vector<bool> const& values){
+    void collapse_wavefunction(std::vector<qubit_id_t> const& ids, std::vector<bool> const& values) {
         run();
-        if (ids.size() != values.size())
-            throw(std::length_error("collapse_wavefunction(): ids and values size mismatch"));
+        assert(ids.size() == values.size());
         if (!check_ids(ids))
-            throw(std::runtime_error("collapse_wavefunction(): Unknown qubit id(s) provided. Try calling eng.flush() before invoking this function."));
+            throw(
+                std::runtime_error("collapse_wavefunction(): Unknown qubit id(s) "
+                                   "provided. Try "
+                                   "calling eng.flush() before invoking this function."));
         std::size_t mask = 0, val = 0;
-        for (unsigned i = 0; i < ids.size(); ++i){
+        for (unsigned i = 0; i < ids.size(); ++i) {
             mask |= (1UL << map_[ids[i]]);
-            val |= ((values[i]?1UL:0UL) << map_[ids[i]]);
+            val |= ((values[i] ? 1UL : 0UL) << map_[ids[i]]);
         }
-        // set bad entries to 0 and compute probability of outcome to renormalize
+        // set bad entries to 0 and compute probability of outcome to
+        // renormalize
         calc_type N = 0.;
-        #pragma omp parallel for reduction(+:N) schedule(static)
-        for (std::size_t i = 0; i < vec_.size(); ++i){
+#pragma omp parallel for reduction(+ : N) schedule(static)
+        for (omp::idx_t i = 0; i < vec_.size(); ++i) {
             if ((i & mask) == val)
                 N += std::norm(vec_[i]);
         }
         if (N < 1.e-12)
-            throw(std::runtime_error("collapse_wavefunction(): Invalid collapse! Probability is ~0."));
+            throw(
+                std::runtime_error("collapse_wavefunction(): Invalid "
+                                   "collapse! Probability is ~0."));
         // re-normalize (if possible)
-        N = 1./std::sqrt(N);
-        #pragma omp parallel for schedule(static)
-        for (std::size_t i = 0; i < vec_.size(); ++i){
+        N = 1. / std::sqrt(N);
+#pragma omp parallel for schedule(static)
+        for (omp::idx_t i = 0; i < vec_.size(); ++i) {
             if ((i & mask) != val)
                 vec_[i] = 0.;
             else
@@ -484,7 +608,7 @@ public:
         }
     }
 
-    void run(){
+    void run() {
         if (fused_gates_.size() < 1)
             return;
 
@@ -498,71 +622,72 @@ public:
 
         auto ctrlmask = get_control_mask(ctrls);
 
-        switch (ids.size()){
+        switch (ids.size()) {
             case 1:
-                #pragma omp parallel
+#pragma omp parallel
                 kernel(vec_, ids[0], m, ctrlmask);
                 break;
             case 2:
-                #pragma omp parallel
+#pragma omp parallel
                 kernel(vec_, ids[1], ids[0], m, ctrlmask);
                 break;
             case 3:
-                #pragma omp parallel
+#pragma omp parallel
                 kernel(vec_, ids[2], ids[1], ids[0], m, ctrlmask);
                 break;
             case 4:
-                #pragma omp parallel
+#pragma omp parallel
                 kernel(vec_, ids[3], ids[2], ids[1], ids[0], m, ctrlmask);
                 break;
             case 5:
-                #pragma omp parallel
+#pragma omp parallel
                 kernel(vec_, ids[4], ids[3], ids[2], ids[1], ids[0], m, ctrlmask);
                 break;
             default:
-                throw std::invalid_argument("Gates with more than 5 qubits are not supported!");
+                throw std::invalid_argument(
+                    "Gates with more than 5 qubits are not "
+                    "supported!");
         }
 
-        fused_gates_ = Fusion();
+        fused_gates_.clear();
     }
 
-    std::tuple<Map, StateVector&> cheat(){
+    std::tuple<Map, StateVector&> cheat() {
         run();
         return make_tuple(map_, std::ref(vec_));
     }
 
-    ~Simulator(){
+    ~Simulator() {
     }
 
-private:
-    void apply_term(Term const& term, std::vector<unsigned> const& ids,
-                    std::vector<unsigned> const& ctrl){
+ private:
+    void apply_term(Term const& term, std::vector<qubit_id_t> const& ids, std::vector<qubit_id_t> const& ctrl) {
         complex_type I(0., 1.);
         Fusion::Matrix X = {{0., 1.}, {1., 0.}};
         Fusion::Matrix Y = {{0., -I}, {I, 0.}};
         Fusion::Matrix Z = {{1., 0.}, {0., -1.}};
         std::vector<Fusion::Matrix> gates = {X, Y, Z};
-        for (auto const& local_op : term){
-            unsigned id = ids[local_op.first];
+        for (auto const& local_op : term) {
+            qubit_id_t id = ids[local_op.first];
             apply_controlled_gate(gates[local_op.second - 'X'], {id}, ctrl);
         }
         run();
     }
-    std::size_t get_control_mask(std::vector<unsigned> const& ctrls){
+    std::size_t get_control_mask(std::vector<qubit_id_t> const& ctrls) {
         std::size_t ctrlmask = 0;
         for (auto c : ctrls)
             ctrlmask |= (1UL << map_[c]);
         return ctrlmask;
     }
 
-    bool check_ids(std::vector<unsigned> const& ids){
+    bool check_ids(std::vector<qubit_id_t> const& ids) {
         for (auto id : ids)
             if (!map_.count(id))
                 return false;
         return true;
     }
 
-    unsigned N_; // #qubits
+    unsigned N_;  // #qubits
     StateVector vec_;
     Map map_;
     Fusion fused_gates_;
@@ -570,11 +695,17 @@ private:
     RndEngine rnd_eng_;
     std::function<double()> rng_;
 
+#if USE_STATIC_STATEVECTOR
     // large array buffers to avoid costly reallocations
-    static StateVector tmpBuff1_, tmpBuff2_;
+    static StateVector tmpBuff1_, tmpBuff2_;  // NOLINT
+#endif
 };
 
-Simulator::StateVector Simulator::tmpBuff1_;
-Simulator::StateVector Simulator::tmpBuff2_;
+#if USE_STATIC_STATEVECTOR
+inline Simulator::StateVector Simulator::tmpBuff1_;
+inline Simulator::StateVector Simulator::tmpBuff2_;
+#endif
+
+}  // namespace projectq
 
 #endif
